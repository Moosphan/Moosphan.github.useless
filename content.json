{"pages":[],"posts":[{"title":"「2019，路漫漫其修远兮」","text":"上天总是“神不知鬼不觉”地偷走你的时间，每当我们回顾的时候才倍感珍惜。 2019年初规划的“豪情壮志”，如今看来，已然被时间长河掩埋和腐化： Android 深入学习 深入 Kotlin 语言学习和实践 了解跨平台开发及前端开发 了解Flutter并作实例训练 稳定维护一个开源项目 学习 Python 和数据爬虫、分析等 技术文章每月至少发表一篇 了解项目管理相关专业知识 技术、产品、职业发展、个人成长等相关书籍 × 10 五款框架源码阅读、解析和实战应用 划线部分就是今年未完成的计划，有一半都被搁浅了，想来着实惭愧。不过，虽然期间也有很多突发事件打断了原本计划，比如公司业务变迁、项目职责变更、个人兴趣转变、生活琐事等等，但也还是 Get 到了一些计划外的收获，也算给焦躁的内心带来一丝安慰。 回顾 20192019，这短短的一年经历了大大小小的事情，虽然错过了很多，却也收获了很多。首先从技术领域说起。 Android 领域自毕业开始到现在，我已经在 Android 方面摸爬滚打了两个多年头了。2019，已经不像前一年那样进步飞快了，取而代之的是“步履维艰”，让思考和经验来沉淀自己，这应该也算是每个技术人员必经的时期吧。以往开发过程中更多的是“站在巨人的肩膀上”去快速开发和完成任务，缺少个人的思考和对于技术纵向深度的领悟，以至于出现某些特定问题没有给出良好方案去解决的情况。 于是乎，今年便开始了“痛苦而充实”的进阶之路，书籍、博客、课程、文档等等知识涓涓细流灌输于心，让我自身在考虑和解决问题角度及态度方面发生很大转变。比如，在工作流程上，以往完成一项需求开发任务会直接手绘出大概业务逻辑和复杂点，然后便直接着手开发；而今，会在开发前先去通过“需求看板”来细分需求，而后借助于流程图去理清业务关系和用户交互细节，接着通过 TDD（测试驱动开发）模式来编写单元测试并编写和跑通对应的功能代码。当然，在编写代码前也需要考虑很多事情，如选择不同的实现思路，对应的前期投入、开发成本、维护成本等可能会大相径庭。此外，在经历一段时间小团队开发形式后，开发规范的重要性也日益凸显，这就要求我们需要形成一个统一、规范化和系统化的开发模式，同时要养成代码重构的习惯（代码规范可参考阿里Android开发规范）。 另外，比较“幸福的一件事”是采用了 Kotlin 语言慢慢代替先前的 Java 语言，并着手新项目开发以及老项目的迭代和维护工作。就 Android 开发而言，采用哪种语言并没有绝对的好与坏、优与劣之分，关键在于“持剑的人”：一把绝世好刀在大侠手中可能就是劫富济贫的利器，而在屠夫手中可能只是一把充满血腥味的普通的刀而已。 最后，在系统源码阅读方面有了一些进展，通过查看和分析源码，进一步熟悉 App 从安装到启动再到正常运行的过程、UI绘制的流程、组件通信的过程等等，可以很好的学习各种设计模式在Android源码中的灵活应用并显著提升解决问题的能力和代码规范性。当然，过程痛苦，但想要蜕化成蝶，就必须要经历这个思想磨砺的过程。 此处附今年已读部分Android书单： 《Android 开发艺术探索》 《Android 进阶之光》 《Android 源码设计模式解析与实战》 《Gradle in Action》 《Android 移动性能实战》 《Kotlin in Action》 Flutter 方面今年，偶然机会接触了Flutter，虽然问世不久，但从 GitHub 的火热程度以及性能来看，未来发展形势肯定也是一片大好。大概在 11 月初，我参与了公司新项目技术方面的选型和研究，由于新项目需求并不复杂，就考虑到项目可以通过 Flutter 技术来实现的可能性。经过几天的分析和讨论，最后终于确定下来新项目采用 Flutter 来构建。如今，我们小组已经借助于 Flutter 来开发项目有一个多月了，虽然有些磕磕绊绊，但也并没有发现比较棘手的问题，近期项目也一直处于稳步的开发过程中，预计将于年前上线。 开源项目幸运的是，2019 年初，一个偶然的机会，我和几个朋友讨论一些 Android 面试方面的问题，于是便涌起了一个特殊的想法：何不将面试题通过“每天一问”的形式在 GitHub 上面创建一个开放仓库呢？基于这个世界最大的技术社区，大家可以通过 Issue 来讨论每天的面试题，畅所欲言。接着，这个计划 —— Android daily Interview 就于几天后被成功实施，并一直坚持维护到了现在：在不知不觉中已经 300 天了，累计有 200 期了。在此期间，也感谢洋哥的多次推荐，让更多小伙伴参与进来，不论是建议还是参与答题又或是提供面试题，不辞辛苦，都为了这个项目奉献了自己的力量，在这里我要对他们表示最真挚的感谢🙏。 如果你近期或后续有换工作需要，又或是有心想参与进来，欢迎答题 or 一起坚持、维护下去！✊ 另外，最近着手开发一个个人应用 —— Sight，基于 Kotlin 和 JetPack，预计将于年后上架并开源。 文章创作回顾这一年，技术文章产量降低了，虽然更加忙碌了，但始终无法以此为理由来搪塞自己。不过，文章创作上更加有条理性和系统了，不再像以前那样挥笔疾来了，而是先构思一下并思考编撰方式，当然，随之而来的是时间成本的增加，不过，显然这些付出是值得的。也是在今年才陆续在掘金上发表文章，虽然数量仅有几篇，所幸文章的曝光度和反响都还不错，收获了大概 2000 关注度，这也将继续激励我进行后续的文章创作。 技术活动2019 下半年，有幸参加了几场技术分享盛会，收获良多。9 月份的 Google IO 大会上，我再一次感受了科技进步的魅力，几乎每年都能感受到技术变化带来的惊喜，这种喜悦并不只是针对我们技术人员，对于广大民众和整个互联网市场来说也是机遇无限。从 Android 10 问世到 Kotlin 与 JetPack 的进一步发展，Android 应用开发成本大幅度降低，技术栈也更加完善却也呈现“百家争鸣”之态；从 Flutter 1.0 问世到 1.9 版本的发布，跨平台开发将呈现更大的发展态势；从 ARCore 增强现实技术到 TensorFlow 机器学习的不断改进，科幻电影中的“黑科技”将离我们不再遥远。 随着 Material design 设计思想的推广和传播，新的设计的风格也正在一点点被大众所接受…… 业余阅读除了技术书籍以外，我也在一些“边边角角”的时间看了一些其他方面的书籍。从《穷查理宝典》中，能细品查理•芒格的人生智慧，受用无穷；从《增长黑客》中学习了如何零成本推广和发展产品；读《乌合之众》一书，进一步解读大众心态和心理，同时要在普遍从众的现象中保持自我，而不是沦为单纯的“一群只会攻击的野兽”。 新一年规划接下来的 2020，又将是一个新的开始。从若多案例来看，我深知咱们搞技术的如果学不动或者停滞了向前，那么我们离被淘汰也就不远了。生活中肯定不能一直抱着“船到桥头自然直”的心态，提前规划学习目标和制定成长路线显然才是上策。 Android Android 方面才是主技能，吃饭的家伙可不能丢掉，新的一年将继续研读源码、深入研究 View 绘制、Binder 机制、插件化深度探索、JVM虚拟机、Kotlin Coroutines 等内容。后续将尽量减小横向技术的发散，进一步加强纵向技术深度。Android 涉及业务领域众多，我相信，如果在任何一个领域站稳脚跟，那么未来的路都不会太差，重要的是努力找准自己的方向并坚持“钻子精神”。 Flutter Flutter 仅仅接触了不到两个月，虽然时间较短，但作为一项个人辅助技能也是未来可期。所以，未来要加深这部分技术的学习以及部分源码的解读，研究和实践混合开发的那些事，并运用到个人的实际项目中，有必要的话还是需要稍微了解一下 iOS 的打包、仓库配置和插件开发相关知识，毕竟既然接触了跨平台的开发技能，如果仅实践于 Android 端，那也实在说不过去了。 其他 除了加深移动端系统方面的学习，也要留意数据结构算法的步伐不能落下，后续也需要进一步制定各部分的详细计划监督和督促自己，防止不了了之的情况出现。Leetcode 题库的继续收割和训练、操作系统和计算机组成方面知识的回顾和巩固等，这些东西虽然看似平实压根用不上，但是很多地方究其根源还是会牵扯到这部分的扩展，何况也属于面试必考察的知识点，不可忽视！ 提到这，突然想到自己的简历也好久没更新了，年后考虑跳槽，近期需要重新准备一下中/英版简历，此任务优先级较高。 博客 在文章创作方面，预计坚持 1-2 个月产出一篇较高质量的文章，同样，基本都会配上 demo 地址。文章大部分主要发布在掘金这种垂直性的技术社区，文章内容以移动端技术实践和新技术尝鲜为主。并会根据“修炼成果”尝试在下半年创办个人的公众号，主要以技术文章为主。 开源项目 预计在 2020 年主要维护两款开源的项目，即我上面提到的 Android daily Interview 和 Sight。 每日面试题的项目基础题库已经快接近尾声，后续将在 Android 系统源码、难题解决方案、数据结构算法、Kotlin 实践和源码分析、架构等方面来出题，题目几乎来源于国内外各大公司的内部题库，也请大家拭目以待啦！当然，如果你有好的题目，欢迎提交 PR，与我们一起“并肩作战”！ 至于 Sight 这款应用（暂命名），主要用来熟悉和实战 Kotlin 以及 JetPack 全家桶，严格遵循 Material Design，努力达到一款“产品级”应用要求，并将会上架于 Google 和国内应用市场，到时候欢迎大家前来体验和提出 Bug 😄。此外，该项目后续也将通过 Flutter 来混合开发部分页面，并 Clone 项目和 Flutter 重构，尝试将其应用到多端。最终代码将会在应用上架后开源。 个人身心 这是最重要的一点！近期网上各种同行 ICU 或者被逼迫辞职的案例屡见不鲜。一方面，我们也要学会武装自己，利用一些业务时间接触一些法律、心理、创业等其他方面感兴趣的知识，不至于“破釜沉舟”的时候才发现自己只是别人的“垫脚石”。另一方面，对于我们潜心“修炼技术”的人来说，“技术是第一生产力”，但更要明白：身体才是革命的本钱。没了健康，你所拥有的一切也许只是虚妄。所以，大家在做技术的同时一定要坚持锻炼，保持良好的生活态度，心不老，气长存。 往事不回头，岁月不饶人。留给我们的时间不多了，2020，路漫漫其修远兮，吾将上下而求索，一起加油吧！ 最后，送上我喜欢的一句话：“我的剑，留给能够挥舞它的人”。希望大家 2020 年能够挥舞自己心中的那把良剑，斩获 offer，一夫当关万夫莫敌！","link":"/2020/01/08/2019-summary/"},{"title":"Android Gradle3.0开始Implementation 与 Api的爱恨情仇","text":"本文翻译于 Bedanta Bikash Borah 的文章，原文链接如下： Implementation Vs Api in Android Gradle plugin 3.0 当我们在Android项目中使用 Gradle 3.0 及以上版本的插件，你一定会注意到 compile 关键字已经被弃用来支持 implementation 和 api。让我们借助一个例子来了解它们。 示例应用 (Kotlin) 可以在这里找到。 让我们假设有一个 Android 项目包含以下四个 library module： LibraryA LibraryB LibraryC LibraryD 它们之间的依赖关系如下所示： 每个 Library module 都包含一个简单的类。 LibraryD: 123456class ClassD { fun tellMeAJoke():String{ return \"You are funny :D\" }} LibraryC: 12345class ClassC { fun tellMeAJoke(): String { return \"You are funny :C\" }} LibraryB: 12345678class ClassB { val b = ClassD() fun whereIsMyJoke(): String { return b.tellMeAJoke() }} LibraryA: 12345678class ClassA { val c = ClassC() fun whereIsMyJoke(): String { return c.tellMeAJoke() }} 从上面这些类文件中可以看到 LibraryA 和 LibraryB 分别依赖于 LibraryC 和 LibraryD。因此，需要将它们之间的依赖关系添加到 build.gradle 文件当中。 Compile (2.0) or Api (3.0):3.0 中新的 api 关键字与之前版本的 compile 关键字意义完全相同。因此，如果项目中所有 compile 关键字被 api 所取代，这完全可以正常工作。现在，让我们在 LibraryB 中通过 api 关键字来依赖 LibraryD： 1234dependencies { . . . . api project(path: ':libraryD')} 同样地，将 LibraryB 添加到 app 模块中： 1234dependencies { . . . . api project(path: ':libraryB')} 现在，我们可以在 app 模块中访问到 LibraryB 和 LibraryD。在示例应用中，两个库的访问形式如下： Implementation (3.0):现在是时候来找出 implementation 和 api 之间的不同之处了。再次回到上面这个例子，现在让我们在 LibraryA 中通过 implementation 关键字引入 LibraryC： 1234dependencies { . . . . implementation project(path: ':libraryC')} App 模块同理： 1234dependencies { . . . . implementation project(path: ':libraryA')} 现在，如果我们在 app 模块访问 LibraryC，Android studio 将会抛出一个错误： 这意味着如果我们使用 implementation 关键字代替 api，LibraryC 将无法在 App 模块中被访问。那么 implementation 这样做有什么好处呢？ Implementation vs api:在第一个场景中，LibraryD 是通过 api 关键字来编译的。一旦 LibraryD 中的实现做了任何改动，那么 gradle 都需要重新编译 LibraryD，LibraryB 和所有其他引入 LibraryB 的模块一样可能使用的是 LibraryD 中的实现。 但在第二个场景中，如果更改了 LibraryC 中的代码实现，那么 Gradle 只会重新编译 LibraryC 和 LibraryA，因为其他任何没有直接依赖 LibraryC 的类都无法使用其中任何实现。 如果你正在开发具有多个模块的项目，那么这种策略可以显著加快构建过程。我在示例程序中进行了尝试，几秒钟后就有了一些改进。以下是所有方案的构建报告。 全量构建: 变更 LibraryD: 变更 libraryC: 总结Android Gradle 插件版本升级至3.0之后，我们只需要将所有 compile 替换为 implementation 关键字并尝试构建项目。如果可以构建成功，那么很好。否则，请查找任何你可能正在使用的遗漏的依赖库，并找到宿主 library 换用 api 关键字引入这些 library。","link":"/2020/08/19/Android-Gradle3-0%E5%BC%80%E5%A7%8BImplementation-%E4%B8%8E-Api%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/"},{"title":"一篇文章带你领略Android混淆的魅力","text":"在 Android 日常开发过程中，混淆是我们开发 App 的一项必不可少的技能。只要是我们亲身经历过 App 打包上线的过程，或多或少都需要了解一些代码混淆的基本操作。那么，混淆到底是什么？它的好处有哪些？具体效果如何？别急，下面我们来一一探索它的”独特”魅力🐳。 混淆简介 代码混淆（Obfuscated code）是将程序中的代码以某种规则转换为难以阅读和理解的代码的一种行为。 混淆的好处混淆的好处就是它的目的：令 APK 难以被逆向工程，即很大程度上增加反编译的成本。此外，Android 当中的”混淆”还能够在打包时移除无用资源，显著减少 APK 体积。最后，还能以变通方式避免 Android 中常见的 64k 方法数引用的限制。 我们先来看一下混淆前后的 APK 结构对比。 混淆前： 混淆后： 从上面两张图可以看出：经过混淆处理之后，我们的 APK 中包名、类名、成员名等都被替换为随机、无意义的名称，增加了代码阅读和理解的困难程度，提高了反编译的成本。细心的小伙伴可能又会注意到：混淆前后 APK 的体积竟然从 2.7M 减小到了 1.4M，体积缩减了近一倍！真的有这么神奇吗？哈哈，确实是这么神奇，让我们慢慢来揭开它的神秘面纱吧😏。 Android 当中的混淆在 Android 中，我们平常所说的”混淆”其实有两层意思，一个是 Java 代码的混淆，另外一个是资源的压缩。其实这两者之间并没有什么关联，只不过习惯性地放在一起来使用。那么，说了这么多，Android 平台上到底该如何开启混淆呢？ 启用混淆1234567891011...... android { buildTypes { release { minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } }} 以上就是开启混淆的基本操作了，通过 minifyEnabled 设置为 true 来开启混淆。同时，可以设置 shrinkResources 为 true 来开启资源的压缩。不难看出，我们一般在打 release 包时才启用混淆，因为混淆会增加额外的编译时间，所以不建议在 debug 模式下启用。此外，需要注意的是：只有在启用混淆的前提下开启资源压缩才会有效！以上代码中的 proguard-android.txt 表示 Android 系统为我们提供的默认混淆规则文件，而 proguard-rules.pro 则是我们想要自定义的混淆规则，至于如何自定义混淆规则我们将在接下来会讲到😄。 代码混淆其实，Java 平台为我们提供了 Proguard 混淆工具来帮助我们快速地对代码进行混淆。根据 Java 官方介绍，Proguard 对应的具体中文定义如下： 它是一个包含代码文件压缩、优化、混淆和校验等功能的工具 它能够检测并删除无用的类、变量、方法和属性 它能够优化字节码并删除未使用的指令 它能够将类、变量和方法的名字重命名为无意义的名称从而达到混淆效果 最后，它还会校验处理后的代码，主要针对 Java 6 及以上版本和 Java ME 资源压缩Android 中，编译器为我们提供了另外一项强大的功能：资源的压缩。资源压缩能够帮助我们移除项目及依赖仓库中未使用到的资源，有效地降低了apk包的大小。由于资源压缩与代码混淆是协同工作，所以，如果需要开启资源的压缩，切记要先开启代码混淆，否则会出现以下问题： 12ERROR: Removing unused resources requires unused code shrinking to be turned on. See http://d.android.com/r/tools/shrink-resources.html for more information.Affected Modules: app 自定义要保留的资源当我们开启了资源压缩之后，系统会默认替我们移除所有未使用的资源，假如我们需要保留某些特定的资源，可以在我们项目中创建一个被 &lt;resources&gt; 标记的 XML 文件（如 res/raw/keep.xml），并在 tools:keep 属性中指定每个要保留的资源，在 tools:discard 属性中指定每个要舍弃的资源。这两个属性都接受逗号分隔的资源名称列表。同样，我们可以使用字符 * 作为通配符。如： 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources xmlns:tools=\"http://schemas.android.com/tools\" tools:keep=\"@layout/activity_video*,@layout/dialog_update_v2\" tools:discard=\"@layout/unused_layout,@drawable/unused_selector\" /&gt; 启用严格检查模式正常情况下，资源压缩器可准确判定系统是否使用了资源。不过，如果您的代码（包含库）调用 Resources.getIdentifier()，这就表示您的代码将根据动态生成的字符串查询资源名称。这时，资源压缩器会采取防御性行为，将所有具有匹配名称格式的资源标记为可能已使用，无法移除。例如，以下代码会使所有带 img_ 前缀的资源标记为已使用： 12String name = String.format(\"img_%1d\", angle + 1);res = getResources().getIdentifier(name, \"drawable\", getPackageName()); 这时，我可以开启资源的严格审查模式，只会保留确定已使用的资源： 123&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources xmlns:tools=\"http://schemas.android.com/tools\" tools:shrinkMode=\"strict\" /&gt; 移除备用资源Gradle 资源压缩器只会移除未被应用引用的资源，这意味着它不会移除用于不同设备配置的备用资源。必要时，我们可以使用 Android Gradle 插件的 resConfigs 属性来移除您的应用不需要的备用资源文件（常见的有用于国际化支持的 strings.xml，适配用的 layout.xml 等）： 1234567android { defaultConfig { ... //保留中文和英文国际化支持 resConfigs \"en\", \"zh\" }} 自定义混淆规则品尝完了以上”配菜”，下面让我们来品味一下本文的”主菜”：自定义混淆规则。首先，我们来了解一下常见的混淆命令。 keep 命令这里说的 keep 命令指的是一系列以 -keep 开头的命令，它主要用来保留 Java 中不需要进行混淆的元素。以下是常见的 -keep 命令： -keep 作用：保留指定的类和成员，防止被混淆处理。例如： 12345# 保留包：com.moos.media.entity 下面的类以及类成员-keep public class com.moos.media.entity.**# 保留类：NumberProgressBar-keep public class com.moos.media.widget.NumberProgressBar {*;} -keepclassmembers 作用：保留指定的类的成员（变量/方法），它们将不会被混淆。如： 12345# 保留类的成员：MediaUtils类中的特定成员方法-keepclassmembers class com.moos.media.MediaUtils { public static *** getLocalVideos(android.content.Context); public static *** getLocalPictures(android.content.Context);} -keepclasseswithmembers 作用：保留指定的类和其成员（变量/方法），前提是它们在压缩阶段没有被删除。与-keep 使用方式类似： 12345# 保留类：BaseMediaEntity 的子类-keepclasseswithmembers public class * extends com.moos.media.entity.BaseMediaEntity{*;}# 保留类：OnProgressBarListener接口的实现类-keep public class * implements com.moos.media.widget.OnProgressBarListener {*;} @Keep 除了以上方式，你也可以选择使用 @Keep 注解来保留期望代码，防止它们被混淆处理。比如，我们通过 @Keep 修饰一个类来保留它不被混淆： 123456@Keepdata class CloudMusicBean(var createDate: String, var id: Long, var name: String, var url: String, val imgUrl: String) 同样地，我们也可以让 @Keep 来修饰方法或者字段进而保留它们。 其他命令 dontwarn -dontwarn 命令一般在我们引入新的 library 时会使用到，常用于处理 library 中无法解决的警告。如： 123-keep class twitter4j.** { *; }-dontwarn twitter4j.** 其他的命令用法可参考 Android 系统提供的默认混淆规则： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#混淆时不生成大小写混合的类名-dontusemixedcaseclassnames#不跳过非公共的库的类-dontskipnonpubliclibraryclasses#混淆过程中记录日志-verbose#关闭预校验-dontpreverify#关闭优化-dontoptimize#保留注解-keepattributes *Annotation*#保留所有拥有本地方法的类名及本地方法名-keepclasseswithmembernames class * { native &lt;methods&gt;;}#保留自定义View的get和set方法-keepclassmembers public class * extends android.view.View { void set*(***); *** get*();}#保留Activity中View及其子类入参的方法，如: onClick(android.view.View)-keepclassmembers class * extends android.app.Activity { public void *(android.view.View);}#保留枚举-keepclassmembers enum * { **[] $VALUES; public *;}#保留序列化的类-keepclassmembers class * implements android.os.Parcelable { public static final android.os.Parcelable$Creator CREATOR;}#保留R文件的静态成员-keepclassmembers class **.R$* { public static &lt;fields&gt;;}-dontwarn android.support.**-keep class android.support.annotation.Keep-keep @android.support.annotation.Keep class * {*;}-keepclasseswithmembers class * { @android.support.annotation.Keep &lt;methods&gt;;}-keepclasseswithmembers class * { @android.support.annotation.Keep &lt;fields&gt;;}-keepclasseswithmembers class * { @android.support.annotation.Keep &lt;init&gt;(...);} 更多混淆命令可以参考文章：Proguard 最全混淆规则说明 ，这里就不做详细讲解了。 混淆”黑名单”我们在了解了混淆的基本命令之后，很多人应该还是一头雾水：到底哪些内容该混淆？其实，我们在使用代码混淆时，ProGuard 对我们项目中大部分代码进行了混淆操作，为了防止编译时出错，我们应该通过 keep 命令保留一些元素不被混淆。所以，我们只需要知道哪些元素不应该被混淆： 枚举项目中难免可能会用到枚举类型，然而它不能参与到混淆当中去。原因是：枚举类内部存在 values 方法，混淆后该方法会被重新命名，并抛出 NoSuchMethodException。庆幸的是，Android 系统默认的混淆规则中已经添加了对于枚举类的处理，我们无需再去做额外工作。想了解更多枚举内部细节可以去查看源码，篇幅有限不再细说。 被反射的元素被反射使用的类、变量、方法、包名等不应该被混淆处理。原因在于：代码混淆过程中，被反射使用的元素会被重命名，然而反射依旧是按照先前的名称去寻找元素，所以会经常发生 NoSuchMethodException 和 NoSuchFiledException 问题。 实体类实体类即我们常说的”数据类”，当然经常伴随着序列化与反序列化操作。很多人也应该都想到了，混淆是将原本有特定含义的”元素”转变为无意义的名称，所以，经过混淆的”洗礼”之后，序列化之后的 value 对应的 key 已然变为没有意义的字段，这肯定是我们不希望的。同时，反序列化的过程创建对象从根本上来说还是借助于反射，混淆之后 key 会被改变，所以也会违背我们预期的效果。 四大组件Android 中的四大组件同样不应该被混淆。原因在于： 四大组件使用前都需要在 AndroidManifest.xml 文件中进行注册声明，然而混淆处理之后，四大组件的类名就会被篡改，实际使用的类与 manifest 中注册的类并不匹配，故而出错。 其他应用程序访问组件时可能会用到类的包名加类名，如果经过混淆，可能会无法找到对应组件或者产生异常。 JNI 调用的Java 方法当 JNI 调用的 Java 方法被混淆后，方法名会变成无意义的名称，这就与 C++ 中原本的 Java 方法名不匹配，因而会无法找到所调用的方法。 其他不应该被混淆的 自定义控件不需要被混淆 JavaScript 调用 Java 的方法不应混淆 Java 的 native 方法不应该被混淆 项目中引用的第三方库也不建议混淆 混淆后的堆栈跟踪代码经过 ProGuard 混淆处理后，想要读取 StackTrace（堆栈追踪）信息就会变得很困难。由于方法名称和类的名称都经过混淆处理，即使程序发生崩溃问题，也很难定位问题所在。幸运的是，ProGuard 为我们提供了补救的措施，在着手进行之前，我们先来看一下 ProGuard 每次构建后生成了哪些内容。 混淆输出结果混淆构建完成之后，会在 &lt;module-name&gt;/build/outputs/mapping/release/ 目录下生成以下文件： dump.txt 说明 APK 内所有类文件的内部结构。 mapping.txt 提供混淆前后的内容对照表，内容主要包含类、方法和类的成员变量。 seeds.txt 罗列出未进行混淆处理的类和成员。 usage.txt 罗列出从 APK 中移除的代码。 恢复堆栈跟踪了解完混淆构建完毕后输出的内容之后，我们现在就来看一下之前的问题：混淆处理后，StackTrace 定位困难。如何来恢复 StackTrace 的定位能力呢？系统为我们提供了 retrace 工具，结合上文提到的 mapping.txt 文件，就可以将混淆后的崩溃堆栈追踪信息还原成正常情况下的 StackTrace 信息。主要有两种方式来恢复 StackTrace，为了方便理解，我们以下面这段崩溃信息为例，借助两种方式分别来还原： 123456java.lang.RuntimeException: Unable to start activity Caused by: kotlin.KotlinNullPointerException at com.moos.media.ui.ImageSelectActivity.k(ImageSelectActivity.kt:71) at com.moos.media.ui.ImageSelectActivity.onCreate(ImageSelectActivity.kt:58) at android.app.Activity.performCreate(Activity.java:6237) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1107) 通过 retrace 脚本工具 首先我们要进入到 Android SDK 路径的 /tools/proguard/bin 目录中，这里以 Mac 系统为例，可以看到如下内容： 可以看到如上三个文件，而 proguardgui.sh 才是我们需要的 retrace 脚本（Windows系统下为 proguardgui.bat ）。Windows 系统中只需要双击脚本 proguardgui.bat 即可运行，至于 Mac 系统，如果你没有做任何配置，只需要将 proguardgui.sh 脚本拖动到 Mac 自带的终端中，回车键即可运行。接着，我们会看到如下界面： 选择 ReTrace 栏 ，并添加我们项目中混淆生成的 mapping.txt 文件所在位置，然后将我们的混淆后的崩溃信息复制到 Obfuscated stack trace 那一栏，点击 ReTrace! 按钮即可还原出我们的崩溃日志信息，结果如上图所示，我们之前的混淆日志：at com.moos.media.ui.ImageSelectActivity.k(ImageSelectActivity.kt:71) 被还原成了 **at com.moos.media.ui.ImageSelectActivity.initView(ImageSelectActivity.kt:71)**。ImageSelectActivity.k 是我们混淆后的方法名，ImageSelectActivity.initView 则是最初未混淆前的方法名，借助于 ReTrace 工具的帮助，我们就可以像以前一样很快定位到崩溃代码区域了。 通过 retrace 命令行 我们先要将崩溃信息复制到 txt 格式的文件（如：proguard_stacktrace.txt）中保存，然后执行以下命令即可（MAC系统）： 1retrace.sh -verbose mapping.txt proguard_stacktrace.txt 如果你是 windows 系统，可以执行以下命令： 1retrace.bat -verbose mapping.txt proguard_stacktrace.txt 最终还原的结果和之前效果一样： 也许你通过以上两种方式在对 stackTrace 进行恢复时，发现 Unknown Source 问题： 值得注意的是，记得在混淆规则中加上如下配置来提升我们的 StackSource 查找效率： 12# 保留源文件名和具体代码行号-keepattributes SourceFile,LineNumberTable 此外，我们每次使用 ProGuard 创建发布构建时都都会覆盖之前版本的 mapping.txt 文件，因此我们每次发布新版本时都必须小心地保存一个副本。通过为每个发布构建保留一个 mapping.txt 文件副本，我们就可以在用户提交的已混淆的 StackTrace 来对旧版本应用的问题进行调试和修复。 涨姿势的操作经过上文的介绍，我们知道，APK 在经过代码混淆处理后，包名、类名、成员名被转化为无意义、难以理解的名称，增加反编译的成本。Android ProGuard 为我们提供了默认的”混淆字典”，即将元素名称转为英文小写字母的形式。那么，我们可以定义自己的混淆字典吗？卖个关子，我们先来看一张效果图： 这个波操作是不是有点”出类拔萃”了？哈哈，就不卖关子了，其实很简单，只要生成一套自己的 txt 格式的混淆字典，然后在混淆规则 Proguard-rules.pro 中应用一下即可： 本文中使用的混淆字典可以在此处查看并下载：proguard_tradition.txt 当然，大家也可以自己去定制化自己的”混淆字典”，增加反编译的难度。 一路走下来，我们发现，从混淆技术的必要性和优点来看，它还是很值得我们去深入学习和研究的，本文带大家领略的仅仅是”冰山一角”。由于本人的技术水平有限，若大家发现有问题或者阐述不当之处，欢迎指出并修正。 相关参考 Shrink your app 读懂Android中的代码混淆 Practical ProGuard rules example Android ProGuard 代码混淆那些事儿 Proguard 最全混淆规则说明","link":"/2020/06/29/android-proguard/"},{"title":"MotionLayout:)带你进入动画新世界","text":"距离上一篇文章「 MotionLayout：打开动画新世界大门（上篇）」已经过去了很久，由于个人原因，MotionLayout 系列文章姗姗来迟。在之前的文章中，我们领略到了 MotionLayout 的魅力，了解到它继承自 ConstraintLayout，并具有它“约束布局”的特性。同时，关于如何创建和使用 MotionScene 及其内部的 KeyFrameSet 也都做了一些简单介绍。那么，本文来带大家进一步探索 KeyFrameSet 这个大家族中的“神秘宝藏”，并针对上文中留下的一些彩蛋进行讲解，来看看如何实现 MotionLayout 与其他控件的联动。 再探索 KeyFrameSet在上文中我们说到 KeyFrameSet 能够让单调的动画独树一帜，可以根据我们的意愿来描述动画运动的轨迹。之前只是比较详细介绍了 KeyFrameSet 这个大家族中的 Keyposition，那么本文就来和大家窥探一下其他宝藏的秘密吧😄。 首先，我们来看一张熟悉的 MotionLayout 结构图： 从上图我们可以看到，KeyFrameSet 中主要包含了 KeyPosition、KeyAttribute 以及 KeyCycle 三种类型的关键帧。其实除此以外，KeyFrameSet 还提供了 KeyTimeCycle 和 KeyTrigger，具体的用法和使用场景会在后续文章进行介绍。本文中，我们先来详细看一下 KeyAttribute 以及 KeyCycle。 KeyAttribute我们知道，KeyPosition 描述的是目标 View 在某个位置的关键帧，进而改变动画的移动轨迹，至于 KeyAttribute，则是描述这个 View 在某个关键帧时所处的“状态”，即所谓的”高矮胖瘦“。前者侧重的是改变动画的轨迹，后者则是强调更改 View 自身的属性。 从上图的 KeyAttribute 结构图中我们可以看到，它支持各种属性，足够我们来描述一个 View 的状态了。假如我们希望实现如下效果： 其实上面的动画实现很简单，只需要在特定位置添加一些“关键帧”就可以了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;MotionScene xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;Transition app:constraintSetStart=\"@+id/start\" app:constraintSetEnd=\"@+id/end\" app:duration=\"3200\" app:motionInterpolator=\"bounce\"&gt; &lt;KeyFrameSet&gt; &lt;KeyAttribute app:motionTarget=\"@+id/loading_ball\" app:framePosition=\"20\" android:scaleX=\"1.5\" android:scaleY=\"1.5\" android:alpha=\"0.7\"/&gt; &lt;KeyAttribute app:motionTarget=\"@+id/loading_ball\" app:framePosition=\"35\" android:scaleX=\"1\" android:scaleY=\"1\" android:alpha=\"1\"/&gt; &lt;KeyAttribute app:motionTarget=\"@+id/loading_ball\" app:framePosition=\"50\" android:scaleX=\"1.5\" android:scaleY=\"1.5\" android:alpha=\"0.7\"/&gt; &lt;KeyAttribute app:motionTarget=\"@+id/loading_ball\" app:framePosition=\"65\" android:scaleX=\"1\" android:scaleY=\"1\" android:alpha=\"1\"/&gt; &lt;KeyAttribute app:motionTarget=\"@+id/loading_ball\" app:framePosition=\"80\" android:scaleX=\"1.5\" android:scaleY=\"1.5\" android:alpha=\"0.7\"/&gt; &lt;KeyAttribute app:motionTarget=\"@+id/loading_ball\" app:framePosition=\"95\" android:scaleX=\"1\" android:scaleY=\"1\" android:alpha=\"1\" /&gt; &lt;/KeyFrameSet&gt; &lt;OnClick app:targetId=\"@+id/loading_ball\" app:clickAction=\"toggle\"/&gt; &lt;/Transition&gt; &lt;ConstraintSet android:id=\"@+id/start\"&gt; &lt;Constraint android:id=\"@id/loading_ball\" android:layout_width=\"32dp\" android:layout_height=\"32dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintHorizontal_bias=\"0.15\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.5\"/&gt; &lt;/ConstraintSet&gt; &lt;ConstraintSet android:id=\"@+id/end\"&gt; &lt;Constraint android:id=\"@+id/loading_ball\" android:layout_width=\"32dp\" android:layout_height=\"32dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintHorizontal_bias=\"0.85\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.5\" /&gt; &lt;/ConstraintSet&gt;&lt;/MotionScene&gt; 最终代码如上所示，是不是很 easy？这里我们在途经路线中添加一些特定的 keyAttribute ，并改变它们的属性状态，这里变化的属性只涉及到 scaleX、scaleY 和 alpha 。 考虑到 KeyAttribute 中提供的属性有限，所以，CustomAttribute 横空出世，它支持任意自定义的属性，常见的有 TextView 的 textColor、background 或者是 ImageView 的 src 、tint 等。当然还不止这些，我们平时自定义 View 中提供的自定义属性同样支持哦。就像 GitHub 上的一个 ShapeOfView 的开源项目，可以提供给我们自定义控件形状的功能，那么结合了 MotionLayout 中的 CustomAttribute，我们就可以达到下面这种平滑转换的效果： 举个简单的例子，上面的小球加载动画我们希望它能够在运动过程中颜色也随之变化，然而 中并没有提供相关属性，这里我们就可以借助于 来实现啦。改动部分代码如下所示： 1234567891011121314151617181920212223242526272829303132333435......&lt;ConstraintSet android:id=\"@+id/start\"&gt; &lt;Constraint android:id=\"@id/loading_ball\" android:layout_width=\"32dp\" android:layout_height=\"32dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintHorizontal_bias=\"0.15\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.5\"&gt; &lt;CustomAttribute app:attributeName=\"colorFilter\" app:customColorValue=\"@android:color/holo_blue_light\"/&gt; &lt;/Constraint&gt;&lt;/ConstraintSet&gt;&lt;ConstraintSet android:id=\"@+id/end\"&gt; &lt;Constraint android:id=\"@+id/loading_ball\" android:layout_width=\"32dp\" android:layout_height=\"32dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintHorizontal_bias=\"0.85\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.5\"&gt; &lt;CustomAttribute app:attributeName=\"colorFilter\" app:customColorValue=\"@color/colorAccent\"/&gt; &lt;/Constraint&gt;&lt;/ConstraintSet&gt; 我们设置了 colorFilter 属性，作用相当于 tint，重新运行后，可以看到如下效果： 需要我们注意的是，这里的自定义属性的 attributeName 对应的值并不一定是在 xml 布局文件中控件对应的属性名称，而是在对应控件中拥有 setter 设置的属性名称。怎么理解呢？其实归根结底 CustomAttribute 内部还是利用的反射，从下面的部分源码中就能够察觉到： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public void applyCustomAttributes(ConstraintLayout constraintLayout) { int count = constraintLayout.getChildCount(); for(int i = 0; i &lt; count; ++i) { View view = constraintLayout.getChildAt(i); int id = view.getId(); if (!this.mConstraints.containsKey(id)) { Log.v(\"ConstraintSet\", \"id unknown \" + Debug.getName(view)); } else { if (this.mForceId &amp;&amp; id == -1) { throw new RuntimeException(\"All children of ConstraintLayout must have ids to use ConstraintSet\"); } if (this.mConstraints.containsKey(id)) { ConstraintSet.Constraint constraint = (ConstraintSet.Constraint)this.mConstraints.get(id); ConstraintAttribute.setAttributes(view, constraint.mCustomConstraints); } } } }...... public static void setAttributes(View view, HashMap&lt;String, ConstraintAttribute&gt; map) { Class&lt;? extends View&gt; viewClass = view.getClass(); Iterator var3 = map.keySet().iterator(); while(var3.hasNext()) { String name = (String)var3.next(); ConstraintAttribute constraintAttribute = (ConstraintAttribute)map.get(name); String methodName = \"set\" + name; try { Method method; switch(constraintAttribute.mType) { case COLOR_TYPE: method = viewClass.getMethod(methodName, Integer.TYPE); method.invoke(view, constraintAttribute.mColorValue); break; case COLOR_DRAWABLE_TYPE: method = viewClass.getMethod(methodName, Drawable.class); ColorDrawable drawable = new ColorDrawable(); drawable.setColor(constraintAttribute.mColorValue); method.invoke(view, drawable); break; case INT_TYPE: method = viewClass.getMethod(methodName, Integer.TYPE); method.invoke(view, constraintAttribute.mIntegerValue); break; case FLOAT_TYPE: method = viewClass.getMethod(methodName, Float.TYPE); method.invoke(view, constraintAttribute.mFloatValue); break; case STRING_TYPE: method = viewClass.getMethod(methodName, CharSequence.class); method.invoke(view, constraintAttribute.mStringValue); break; case BOOLEAN_TYPE: method = viewClass.getMethod(methodName, Boolean.TYPE); method.invoke(view, constraintAttribute.mBooleanValue); break; case DIMENSION_TYPE: method = viewClass.getMethod(methodName, Float.TYPE); method.invoke(view, constraintAttribute.mFloatValue); } } catch (NoSuchMethodException var9) { Log.e(\"TransitionLayout\", var9.getMessage()); Log.e(\"TransitionLayout\", \" Custom Attribute \\\"\" + name + \"\\\" not found on \" + viewClass.getName()); Log.e(\"TransitionLayout\", viewClass.getName() + \" must have a method \" + methodName); } catch (IllegalAccessException var10) { Log.e(\"TransitionLayout\", \" Custom Attribute \\\"\" + name + \"\\\" not found on \" + viewClass.getName()); var10.printStackTrace(); } catch (InvocationTargetException var11) { Log.e(\"TransitionLayout\", \" Custom Attribute \\\"\" + name + \"\\\" not found on \" + viewClass.getName()); var11.printStackTrace(); } } } 首先在 MotionLayout 中，如果是自定义属性，那么会执行 ConstraintSet 类中的 applyCustomAttributes 方法，接着会调用 ConstraintAttribute 类中的 setAttributes 方法，就如上代码中所写的那样，它会根据属性名称组装成对应的 set 方法，然后通过反射调用。是不是有种恍然大悟的感觉？话说，这样的机制是不是好像哪里见到过？没错，正是属性动画。 KeyCycle什么是 KeyCycle 呢？下面是来自 Gal Maoz 的总结： A KeyCycle is a highly-detailed, custom-made interpolator for a specific view, whereas the interpolator is influencing the entire scene, with a large focus on repetitive actions (hence the cycle in the name). 简单来说，KeyCycle 是针对特定视图的非常详细的定制化插值器。它比较适合我们常说的波形或周期运动场景，比如实现控件的抖动动画或者周期性的循环动画。 如上图所示，KeyCycle 主要由以上几个属性组成，前两个相信大家都比较熟悉了，这里不必多说，另外 view properties 正如之前的 KeyAttribute 结构图中所描述的那样，代表View的各种属性，如 rotation、translation、alpha 等等。 这里主要介绍另外三个比较重要且具有特色的属性： wavePeriod：这个表示在当前场景位置下需要执行动画的波（周期）的数量。这样说可能不太容易理解，别急，我们待会举个例子说明。 waveOffset：表示当前控件需要变化的属性的偏移量，即 view properties 所对应的初始值或者基准值。例如，如果我们在动画执行的某个位置设置了 scaleX 为 0.3，而设置了 waveOffset 值为 1，那么，动画执行到该位置，控件的实际宽度会变为 1 + 0.3 = 1.3，也就是会扩大为 1.3 倍，而不是缩小为之前的 0.3 倍。 waveShape：这个属性比较好理解，即波的形状，常见的值有：sin、cos、sawtooth 等，更多可参考官网API：https://developer.android.com/reference/androidx/constraintlayout/motion/widget/MotionLayout#keycycle 下面举个简单的例子帮助理解，以下面这个效果为例： 对应的 KeyFrameSet 代码如下所示： 1234567891011121314151617181920212223&lt;KeyFrameSet&gt; &lt;KeyCycle motion:framePosition=\"0\" motion:target=\"@+id/button\" motion:wavePeriod=\"0\" motion:waveOffset=\"1\" motion:waveShape=\"sin\" android:scaleX=\"0.3\"/&gt; &lt;KeyCycle motion:framePosition=\"18\" motion:target=\"@+id/button\" motion:wavePeriod=\"0\" motion:waveOffset=\"1\" motion:waveShape=\"sin\" android:scaleX=\"0.3\"/&gt; &lt;KeyCycle motion:framePosition=\"100\" motion:target=\"@+id/button\" motion:wavePeriod=\"3\" motion:waveOffset=\"1\" motion:waveShape=\"sin\" android:scaleX=\"0\"/&gt;&lt;/KeyFrameSet&gt; 根据动画效果结合代码可以知道，我们这个放大的Q弹的效果只是改变了 scaleX 这个属性，并且让它“摇摆了”大概三个来回（周期），恰好 wavePeriod 属性值为 3。也许动画不太方便察觉，这样，我们借助于 Google 提供的专门用来查看 KeyCycle 波形变化的快捷工具来查看它波形变化过程： 如此一来，我们就很直观地看到上图中描绘的波形变化过程了，的确是三个周期没有错，并且是以正弦 sin 来变化的。 关于这款工具的使用，大家可以前往：https://github.com/googlearchive/android-ConstraintLayoutExamples/releases/download/1.0/CycleEditor.jar 上下载，然后通过执行 java -jar [xx/CycleEditor.jar] 即可看到可视化界面，然后将 KeyFrameSet 部分的代码 copy 到编辑栏，然后点击 File -&gt; parse xml 即可看到代码对应的波形走势。如下所示： 我们来看看下面这个效果： 这个Q弹的效果就是基于 KeyCycle 实现的，我们来看看它的场景实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;MotionScene xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;Transition app:constraintSetStart=\"@+id/start\" app:constraintSetEnd=\"@+id/end\" app:motionInterpolator=\"easeInOut\" app:duration=\"5200\"&gt; &lt;KeyFrameSet&gt; &lt;KeyCycle app:motionTarget=\"@+id/image\" app:framePosition=\"10\" android:rotationY=\"22\" app:wavePeriod=\"2\" app:waveShape=\"sin\" app:waveOffset=\"1\"/&gt; &lt;KeyCycle app:motionTarget=\"@+id/image\" app:framePosition=\"30\" android:rotationX=\"15\" app:wavePeriod=\"1\" app:waveShape=\"sin\" app:waveOffset=\"0\"/&gt; &lt;KeyCycle app:motionTarget=\"@+id/image\" app:framePosition=\"65\" android:rotationY=\"14\" app:wavePeriod=\"1\" app:waveShape=\"sin\" app:waveOffset=\"0\"/&gt; &lt;KeyCycle app:motionTarget=\"@+id/image\" app:framePosition=\"92\" android:rotationY=\"0\" android:rotationX=\"2\" app:wavePeriod=\"0\" app:waveShape=\"sin\" app:waveOffset=\"0\"/&gt; &lt;/KeyFrameSet&gt; &lt;OnClick app:targetId=\"@+id/image\" app:clickAction=\"toggle\"/&gt; &lt;/Transition&gt; &lt;ConstraintSet android:id=\"@+id/start\"&gt; &lt;Constraint android:id=\"@+id/image\" android:layout_width=\"120dp\" android:layout_height=\"120dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintHorizontal_bias=\"0.76\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.45\"/&gt; &lt;/ConstraintSet&gt; &lt;ConstraintSet android:id=\"@+id/end\"&gt; &lt;Constraint android:id=\"@+id/image\" android:layout_width=\"120dp\" android:layout_height=\"120dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintHorizontal_bias=\"0.76\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.45\"/&gt; &lt;/ConstraintSet&gt;&lt;/MotionScene&gt; 我们在动画路径上添加一些关键帧，并稍微改变控件的旋转角度，配合 keyCycle 就能达到上面的弹性动画，大家可以自己动手尝试体验一下。 MotionLayout 的联动性很多时候，我们的控件并不只是单一的个体，而是需要与其他控件产生“交互上的关联”，常见地，Android 的Material design components 全家桶中提供了一套“优雅灵动”的组件，相信大家都体验过了，那么，我们的 MotionLayout 可以与它们碰撞出怎样的火花呢？ 一切从“头”开始Material design 组件库中提供了一个 AppBarLayout 组件，我们经常使用它来配合 CoordinatorLayout 控件实现一些简单的交互动作，例如头部导航栏的伸缩效果，各位应该或多或少都用到过，这里不再介绍。下面我们就从 AppBarLayout 开始，看看如何实现与 MotionLayout 的联动。首先，我们先来看下面这个简单的效果： 我们知道，通过 CoordinatorLayout 和 AppBarLayout 也可以实现类似的交互效果，但显然 MotionLayout 会更加灵活多变。其实上面的动画效果很简单，只是在 AppBarLayout 高度变化过程中改变背景色、标题的位置和大小即可，对应的 MotionScene 文件代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;MotionScene xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:motion=\"http://schemas.android.com/tools\"&gt; &lt;ConstraintSet android:id=\"@+id/start\"&gt; &lt;Constraint android:id=\"@+id/background\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" motion:layout_constraintBottom_toBottomOf=\"parent\"&gt; &lt;CustomAttribute app:attributeName=\"backgroundColor\" app:customColorValue=\"@color/blue_magic\"/&gt; &lt;/Constraint&gt; &lt;Constraint android:id=\"@+id/tipText\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:scaleY=\"1.6\" android:scaleX=\"1.6\" android:alpha=\"1.0\" android:layout_marginStart=\"62dp\" android:layout_marginTop=\"12dp\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"/&gt; &lt;/ConstraintSet&gt; &lt;ConstraintSet android:id=\"@+id/end\"&gt; &lt;Constraint android:id=\"@id/background\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" motion:layout_constraintBottom_toBottomOf=\"parent\"&gt; &lt;CustomAttribute app:attributeName=\"backgroundColor\" app:customColorValue=\"@color/bgColor_dark\"/&gt; &lt;/Constraint&gt; &lt;Constraint android:id=\"@id/tipText\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginEnd=\"20dp\" android:layout_marginBottom=\"12dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\"/&gt; &lt;/ConstraintSet&gt; &lt;Transition app:constraintSetStart=\"@id/start\" app:constraintSetEnd=\"@id/end\" app:duration=\"4000\"&gt; &lt;KeyFrameSet&gt; &lt;KeyPosition app:framePosition=\"60\" app:motionTarget=\"@id/tipText\" app:keyPositionType=\"parentRelative\" app:percentY=\"0.7\"/&gt; &lt;/KeyFrameSet&gt; &lt;/Transition&gt;&lt;/MotionScene&gt; 结合以上效果图，我们很容易理解上面的场景实现代码，那么，我们再来看下布局文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"false\" android:background=\"@android:color/white\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;com.google.android.material.appbar.AppBarLayout android:id=\"@+id/appBarLayout\" android:layout_width=\"match_parent\" android:layout_height=\"260dp\" android:theme=\"@style/AppTheme.AppBarOverlay\"&gt; &lt;com.moos.constraint.widget.MotionToolBar android:id=\"@+id/motionLayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:motionDebug=\"NO_DEBUG\" app:layoutDescription=\"@xml/motion_scene_simple_appbar\" android:minHeight=\"52dp\" app:layout_scrollFlags=\"scroll|enterAlways|snap|exitUntilCollapsed\"&gt; &lt;View android:id=\"@+id/background\" android:layout_width=\"match_parent\" android:layout_height=\"300dp\" android:background=\"@color/blue_magic\" /&gt; &lt;TextView android:id=\"@+id/tipText\" android:text=\"Time flies fast\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textSize=\"20sp\" android:textColor=\"@color/white\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"/&gt; &lt;/com.moos.constraint.widget.MotionToolBar&gt; &lt;/com.google.android.material.appbar.AppBarLayout&gt; &lt;androidx.core.widget.NestedScrollView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"com.google.android.material.appbar.AppBarLayout$ScrollingViewBehavior\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textColor=\"@color/content_text_color\" android:lineSpacingExtra=\"8dp\" android:padding=\"12dp\" android:text=\"@string/long_text_en\"/&gt; &lt;/androidx.core.widget.NestedScrollView&gt;&lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; 观察上面布局文件，其实代码与传统 CoordinatorLayout &amp; AppBarLayout 交互的代码大同小异，只不过我们在 AppBarLayout 内部添加了一个 MotionToolBar 控件，这其实是个 MotionLayout，只不过内部根据 AppBarLayout 伸缩的高度动态改变动画进度而已，我们来看下具体实现： 123456789101112131415class MotionToolBar @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : MotionLayout(context, attrs, defStyleAttr), AppBarLayout.OnOffsetChangedListener { override fun onOffsetChanged(appBarLayout: AppBarLayout?, verticalOffset: Int) { Log.e(\"MotionToolBar\", \"onOffsetChanged: -----&gt;$verticalOffset, scroll range--&gt; ${appBarLayout?.totalScrollRange}\") val seekPosition = -verticalOffset / (appBarLayout?.totalScrollRange!!.toFloat()/5*3) progress = seekPosition } override fun onAttachedToWindow() { super.onAttachedToWindow() (parent as? AppBarLayout)?.addOnOffsetChangedListener(this) }} 代码量很少，通过在 onOffsetChanged 方法中监听 AppBarLayout 的伸缩高度，并经过换算后得到当前的进度值传递给 progress，该字段就对应着 MotionLayout 的 setProgress 方法，如此一来就能够动态的改变其动画进度了。 理解了上述代码，就不难实现下面的效果了： 具体代码就不贴了，文末会附上 GitHub 仓库地址，所有效果实现代码都能够在里面找到。 Lottie 与 MotionLayout 的双剑合璧Lottie 想必大家都了解过，它是一个动画工具，能够将 UI 的设计动画效果转为 Json 格式的数据文件，然后各端都提供了相应的库来解析并执行动画文件，很多时候需要花费大量时间去借助于代码实现的复杂动画，如今不费吹灰之力就搞定了，很大程度上解放了我们的双手。 那么，Lottie 与 MotionLayout 一起能够碰撞出怎样的火花呢？我们以下面的一个简单效果为例： 其实简单来说，MotionLayout 能够将自身的动画过程与 Lottie 同步，就像图中的安卓机器人动画就是 MotionLayout 实现的，而下面的卡通人物眼神游离的动画则是 Lottie 动画，从图中可以看到，通过手势滑动 ViewPager 两个动画一直保持着“同步运动”。下面我们来看看如何实现的，首先是布局文件，比较简单： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/motionView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@android:color/white\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;com.moos.constraint.widget.ViewpagerHeader android:id=\"@+id/header\" android:layout_width=\"match_parent\" android:layout_height=\"300dp\" app:layoutDescription=\"@xml/motion_with_view_pager\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:motionProgress=\"0\"&gt; &lt;com.airbnb.lottie.LottieAnimationView android:id=\"@+id/lottieView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:lottie_rawRes=\"@raw/face\"/&gt; &lt;ImageView android:id=\"@+id/ic_robot\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@drawable/ic_launcher_foreground\"/&gt; &lt;/com.moos.constraint.widget.ViewpagerHeader&gt; &lt;com.google.android.material.tabs.TabLayout android:id=\"@+id/tabLayout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:tabSelectedTextColor=\"@color/colorAccent\" app:tabTextColor=\"@color/content_text_color\" app:layout_constraintTop_toBottomOf=\"@+id/header\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\"&gt; &lt;/com.google.android.material.tabs.TabLayout&gt; &lt;androidx.viewpager.widget.ViewPager android:id=\"@+id/viewPager\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" app:layout_constraintTop_toBottomOf=\"@+id/tabLayout\" app:layout_constraintBottom_toBottomOf=\"parent\"&gt; &lt;/androidx.viewpager.widget.ViewPager&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 至于这个 ViewPagerHeader 相信大家也猜到了，其实也是个 MotionLayout : 12345678910111213141516class ViewpagerHeader @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : MotionLayout(context, attrs, defStyleAttr), androidx.viewpager.widget.ViewPager.OnPageChangeListener { override fun onPageScrollStateChanged(state: Int) { } override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) { val animateProgress = (position.toFloat() + positionOffset)/3 Log.e(\"LottieMotionActivity\", \"viewpager scroll progress is: $animateProgress\") progress = animateProgress } override fun onPageSelected(position: Int) { }} 只不过它内部实现了 ViewPager 的 onPageChangeListener，以监听页面的滑动状态，然后计算出此时 MotionLayout 的动画进度，这里由于 json 动画文件存在问题，所以只截取了一部分动画过程来执行。说了这么多，它的 MotionScene 是什么样的呢？其实很 easy： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;MotionScene xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:motion=\"http://schemas.android.com/apk/res-auto\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;Transition motion:constraintSetStart=\"@+id/start\" motion:constraintSetEnd=\"@+id/end\"&gt; &lt;/Transition&gt; &lt;ConstraintSet android:id=\"@+id/start\"&gt; &lt;Constraint android:id=\"@id/lottieView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" motion:progress=\"0\"/&gt; &lt;Constraint android:id=\"@id/ic_robot\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"20dp\" motion:layout_constraintTop_toTopOf=\"parent\" motion:layout_constraintStart_toStartOf=\"parent\"&gt; &lt;CustomAttribute app:attributeName=\"colorFilter\" app:customColorValue=\"@android:color/holo_blue_light\"/&gt; &lt;/Constraint&gt; &lt;/ConstraintSet&gt; &lt;ConstraintSet android:id=\"@+id/end\"&gt; &lt;Constraint android:id=\"@id/lottieView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" motion:progress=\"1\"/&gt; &lt;Constraint android:id=\"@id/ic_robot\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginEnd=\"20dp\" motion:layout_constraintTop_toTopOf=\"parent\" motion:layout_constraintEnd_toEndOf=\"parent\"&gt; &lt;CustomAttribute app:attributeName=\"colorFilter\" app:customColorValue=\"@color/colorAccent\"/&gt; &lt;/Constraint&gt; &lt;/ConstraintSet&gt;&lt;/MotionScene&gt; 唯一需要值得注意的是：这里我们分别在 MotionLayout 的起始位置和终止位置设置了 motion:progress 属性为 0 和 1，由于 LottieAnimationView 内部拥有 setProgress 方法，这样做的目的就是将 Lottie 的动画过程与 MotionLayout 进行绑定，我们只需要改变这个属性，就能够间接控制 Lottie 动画啦😁。 最后，我们只需要在 Activity 中设置如下代码就可以成功执行啦： 123456val adapter = ViewPagerAdapter(supportFragmentManager)adapter.addPage(\"Now\", R.layout.holder_layout)adapter.addPage(\"Discover\", R.layout.holder_layout)viewPager.adapter = adaptertabLayout.setupWithViewPager(viewPager)viewPager.addOnPageChangeListener(header as androidx.viewpager.widget.ViewPager.OnPageChangeListener) 当然，MotionLayout 还能和很多组件进行联动，篇幅有限就不一一介绍啦，到这里，我们本篇文章内容也差不多该告一段落了，关于 MotionLayout 系列文章的所有示例代码都能够在 GitHub 仓库中找到： https://github.com/Moosphan/MotionLayoutSamples 后续如此一来，MotionLayout 系列已经完成两篇文章了，剩下的内容应该还需要一篇文章来容纳，后续可能还会额外提供一篇实战系列文章。下一篇文章主要介绍 KeyFrameSet 家族最后一个成员以及 MotionLayout 多状态场景的使用，同时，也会介绍如何实现与 RecyclerView “强强联合”。最后，Google 在 Android studio 4.2 终于推出了 Motion Editor 工具，下篇文章也会通过一个小实战项目来介绍其用法，拭目以待。 笔者说最近这两篇文章都尽量做到每个重要知识点都提供一个实战的小示例，力求做到加深理解，文中很多内容都参考自 Nicolas Roard 对于 MotionLayout 的系列教程和 Android 官方文档，并加入自己的理解。从去年编撰第一篇文章时来看，国内对于 MotionLayout 的系列文章非常少，写文章的目的其实很简单，让自己消化新知识的同时，也能够让更多国人知道、认识和尝试使用 MotionLayout 这个全新的动画组件。 由于个人技术能力和表述能力有限，很多内容可能并没有讲解全面和透彻，如果有什么建议或者问题，欢迎留言区探讨，一起进步🍺。","link":"/2020/08/12/MotionLayout%EF%BC%9A%E5%B8%A6%E4%BD%A0%E8%BF%9B%E5%85%A5%E5%8A%A8%E7%94%BB%E6%96%B0%E4%B8%96%E7%95%8C/"},{"title":"是时候让 Android Tools 属性拯救你了","text":"日常开发过程中，我们都会遇到这样一种场景：我们写出的 UI 效果在对接数据之前需要提前进行预览，进而调整 UI 细节和排版问题。我们一般的做法是什么样的？如果存在像 TextView 或者 ImageView 这种基础控件，你是不是还在通过诸如 android:text=&quot;xxx&quot; 和 android:src=&quot;@drawable/xxx&quot; 的方式来测试和预览UI效果？当然你肯定也会遇到这些“脏数据”给你带来的困扰：测试的时候某些地方出现了本不该出现的数据，事后可能一拍脑门才发现，原来是布局中控件预览数据没有清除导致的。 如果是 RecyclerView，在后台接口尚能测试的情况下，你是否又要自己生成“假数据”并手写 Adapter 呢？这时候你不禁会问：有没有一种方法，既能够做到布局时预览数据方便排版，又能够在对接真实数据运行后动态替换和移除这些无关数据呢？ 铛铛铛铛！Android 的 Tools attributes 应运而生。老规矩，我们先来看一个效果： What？你在耍我吗？这么简单的列表拿出来干嘛？哈哈，客观不要着急。这个并不难实现，倘若我说这里并没有写一行 Java 或者 Kotlin 代码就实现了此效果，而只是在布局页面预览，你敢信吗？上图只是冰山一角，下面这张图才是全貌： 下面会带大家一步步实现上述功能，首先，让我们从头说起。 认识 Tools attributesTools attributes 即以 tools 开始的命名空间，举个我们最常见到的例子： 12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;/android.support.constraint.ConstraintLayout&gt; 大家肯定平时都会见到 tools:context=&quot;.XXXActivity 这个系统默认为我们生成的配置。一般来说，只有根视图才能使用这个属性，它指定了当前布局默认是与哪个 Activity 相关联，使得布局能够获取到绑定 Activity 的一些信息，比如 Theme 等等，而且当你在布局中给子 View 添加 onClick 事件时，相应的方法代码会插入到这个 Activity 中。Android studio 支持很多在 XML 文件中以 tools 为命名空间的属性，当构建 App 时这些属性会被擦除，对 APK 的大小和运行时行为没有任何影响，这也就是我们文章最初想要的结果。 细说 Tools attributes在具体介绍 Tools attributes 之前，我们需要先了解如何引入 Tools 的命名空间并使用，很简单，只需要在 XML 布局文件的根元素中添加即可： 12&lt;RootTag xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" &gt; 这些工具属性大概可以分为以下三类： Error handling attributes即错误和警告处理属性。这类属性常被用来规避被 lint 检查出的一些错误提示以及警告。下面让我们看一些常见的例子： tools:ignore 主要用来忽略一些 lint 产生的警告信息，并支持一些属性，例如： 1234&lt;resources xmlns:tools=\"http://schemas.android.com/tools\"&gt; &lt;string name=\"app_name\"&gt;ConstraintSample&lt;/string&gt; &lt;string name=\"header_image_string\" tools:ignore=\"MissingTranslation\"&gt;header image&lt;/string&gt;&lt;/resources&gt; 这个对于 Android studio 升级到 3.0 以上的小伙伴来说应该是很常见了，如果我们项目中涉及到国际化支持，那么编译器就会提示我们为每一种语言做适配，不能“厚此薄彼”，如果我们某些 string 只需要支持一种语言，只需要像上面那样添加 tools:ignore=&quot;MissingTranslation 即可。相似的例子还可以在使用 ImageView 的时候看到： 12345&lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@drawable/ic_person_off\" tools:ignore=\"contentDescription\" /&gt; tools:targetApi 这个属性的功能和 Java 代码中的注解 @TargetApi 是一样的：它指定了当前控件或元素支持的 API 级别，属性值可以是 API Code 名或者 API 常数值，它支持一切属性。如：我们都知道，*android:elevation* 属性是在 API 21 版本以上才支持的，所以我们可以通过以下代码规避 lint 的警告： 12345&lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:elevation=\"4dp\" tools:targetApi=\"lollipop\"/&gt; tools:locale 这个属性主要用在 &lt;resource&gt; 标签内，用来指定当前资源中默认为哪种语言和区域，进而规避语言拼写的检测，比如你可以指定 values/strings.xml 文件的默认语言是西班牙语而不是英语： 12&lt;resources xmlns:tools=\"http://schemas.android.com/tools\" tools:locale=\"es\"&gt; Resource shrinking attributes即资源压缩属性。关于此类属性的用法我们已经在之前的一篇文章带你领略Android混淆的魅力一文中做过详细讲解，下面再简单说明一下。 我们可以通过 tools:shrinkMode 和 tools:keep 属性来分别指定资源压缩的模式和需要保留的不被压缩的资源 ，还可以通过 tools:discard 属性来指定需要保留的资源，与 keep 功能类似： 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources xmlns:tools=\"http://schemas.android.com/tools\" tools:shrinkMode=\"strict\" tools:keep=\"@layout/activity_video*,@layout/dialog_update_v2\" tools:discard=\"@layout/unused_layout,@drawable/unused_selector\" /&gt; 下面就到本篇文章的重头戏了，注意，前方高能来袭！ Design-time View Attributes这就是我们先前效果图中的重要功臣了，即：布局设计时的控件属性。这类属性主要作用于 View 控件，如上文所说的 tools:context 就是“成员”之一，下面我们来介绍其他重要成员。 在此之前，我们需要先揭开 tools 命名空间的另一层神秘面纱：*tools:*** 可以替换任何以 *android:*** 为前缀的属性，并为其设置样例数据（sample data）。当然，正如我们前面所说，tools 属性只能在布局编辑期间有效，App真正运行后就毫无意义了，所以，我们就可以像下面这样来在运行前预览布局效果： 上图对应的布局文件为： Card_item_layout.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:android=\"http://schemas.android.com/apk/res/android\" android:background=\"@android:color/white\" android:clickable=\"true\" android:focusable=\"true\" android:foreground=\"?attr/selectableItemBackground\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"2dp\" android:layout_marginEnd=\"2dp\" tools:targetApi=\"m\" tools:ignore=\"UnusedAttribute\"&gt; &lt;ImageView android:id=\"@+id/card_item_avatar\" android:layout_width=\"38dp\" android:layout_height=\"38dp\" app:layout_constraintStart_toStartOf=\"parent\" android:layout_marginStart=\"16dp\" android:layout_marginTop=\"16dp\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\" android:layout_marginBottom=\"16dp\" app:layout_constraintVertical_bias=\"0.0\" tools:ignore=\"ContentDescription\" tools:srcCompat=\"@drawable/user_other\"/&gt; &lt;TextView android:id=\"@+id/card_item_username\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"16dp\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/card_item_title\" app:layout_constraintEnd_toEndOf=\"@+id/card_item_title\" app:layout_constraintHorizontal_bias=\"0.0\" android:textSize=\"12sp\" android:textColor=\"@color/username_text_color\" android:layout_marginEnd=\"16dp\" android:paddingEnd=\"16dp\" tools:text=\"水月沐风\" /&gt; &lt;TextView android:id=\"@+id/card_item_title\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textSize=\"16sp\" android:textColor=\"@color/title_text_color\" app:layout_constraintStart_toEndOf=\"@+id/card_item_avatar\" android:layout_marginStart=\"12dp\" app:layout_constraintTop_toBottomOf=\"@+id/card_item_username\" android:layout_marginTop=\"8dp\" android:maxLines=\"1\" tools:text=\"今天上海的夜色真美！\"/&gt; &lt;TextView android:id=\"@+id/card_item_content\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" app:layout_constraintStart_toStartOf=\"parent\" android:layout_marginTop=\"24dp\" app:layout_constraintTop_toBottomOf=\"@+id/card_item_avatar\" app:layout_constraintBottom_toBottomOf=\"parent\" android:layout_marginBottom=\"16dp\" app:layout_constraintVertical_bias=\"1.0\" android:maxLines=\"3\" android:ellipsize=\"end\" android:textColor=\"@color/content_text_color\" android:textStyle=\"normal\" app:layout_constraintEnd_toEndOf=\"@+id/card_item_bottom_border\" android:layout_marginEnd=\"16dp\" android:layout_marginStart=\"16dp\" app:layout_constraintHorizontal_bias=\"0.0\" tools:text=\"人生若只如初见，何事秋风悲画扇...\"/&gt; &lt;ImageView android:id=\"@+id/card_item_poster\" android:layout_width=\"0dp\" android:layout_height=\"200dp\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@+id/card_item_content\" app:layout_constraintEnd_toEndOf=\"parent\" android:layout_marginEnd=\"16dp\" android:scaleType=\"centerCrop\" android:layout_marginTop=\"8dp\" android:layout_marginStart=\"16dp\" app:layout_constraintBottom_toBottomOf=\"parent\" android:layout_marginBottom=\"16dp\" app:layout_constraintVertical_bias=\"0.0\" tools:ignore=\"ContentDescription\" android:visibility=\"visible\" tools:src=\"@drawable/shanghai_night\"/&gt; &lt;View android:id=\"@+id/card_item_bottom_border\" android:layout_width=\"0dp\" android:layout_height=\"2dp\" app:layout_constraintTop_toBottomOf=\"@+id/card_item_poster\" android:background=\"#ffededfe\" app:layout_constraintEnd_toEndOf=\"parent\" android:layout_marginTop=\"16dp\" app:layout_constraintStart_toStartOf=\"parent\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:id=\"@+id/card_item_date\" android:layout_marginTop=\"16dp\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" android:layout_marginEnd=\"16dp\" android:textColor=\"@color/date_text_color\" android:textSize=\"12sp\" tools:text=\"2019-08-10\"/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 通过上面代码我们可以发现：通过 对 TextView 使用 tools:text 属性代替 android:text 就可以实现文本具体效果的预览，然而这项设置并不会对我们 App 实际运行效果产生影响。同理，通过将 tools:src 作用于 ImageView 也可以达到预览图片的效果。此外。我们还可以对其他以 android: 为前缀的属性进行预览而不影响实际运行的效果，例如：上面布局代码中的底部分割线 &lt;View&gt;，我们想将其在 App 实际运行的时候隐藏掉，但我们还是需要知道它的预览效果和所占高度： 123456789101112&lt;View android:id=\"@+id/card_item_bottom_border\" android:layout_width=\"0dp\" android:layout_height=\"2dp\" android:visibility=\"gone\" tools:visibility=\"visible\" tools:layout_height=\"8dp\" app:layout_constraintTop_toBottomOf=\"@+id/card_item_poster\" android:background=\"#ffededfe\" app:layout_constraintEnd_toEndOf=\"parent\" android:layout_marginTop=\"16dp\" app:layout_constraintStart_toStartOf=\"parent\"/&gt; 如上所示，通过 tools:visibility 和 tools:layout_height 就可以仅在布局预览情况下改变 View 的状态和高度。虽然上述情况比较少用，但是希望大家也能够知道，*tools:* 可以替代所有 android: 修饰的属性。 下面再列举一些其他会常用到的属性。 tools:layout 这个属性只能用于 fragment 控件中，如果我们的 activity 布局文件中声明了 &lt;fragment&gt; 控件，我们就可以通过 tools:layout=”@layout/fragment_main” 来在当前 activity 布局中预览 fragment 中的布局效果。 tools:showIn 这个属性就比较好玩了，它可以指定其他布局文件像 &lt;include&gt; 组件一样在当前布局文件中使用和预览 &lt;include&gt; 控件的实际效果。例如，我们 card_item_layout.xml 作为 showIn 的对象给 show_in_layout.xml 布局使用，然后我就可以看到 show_in_layout.xml 中如下效果： tools:menu 这个属性可以给当前布局预览器的 Toolbar 添加多个菜单项，但仅限于布局文件的根节点元素。如： 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:menu=\"menu1,menu2\" /&gt; tools:maxValue | tools:minValue 这两个属性仅用于 *&lt;NumberPicker&gt;*，可以在预览时指定其最大值和最小值： 12345678&lt;NumberPicker xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/numberPicker\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" tools:minValue=\"0\" tools:maxValue=\"10\" /&gt; tools:listitem | tools:listheader | tools:listfooter | tools:listCount 下面来讲一下列表相关组件的 tools 属性。上面四个属性仅用于 &lt;AdapterView&gt; 及其子类（如：ListView 和 RecyclerView）。然而，它们内部仍有一些使用限制：*tools:listCount* 仅用于 RecyclerView；*tools:listheader* 和 tools:listfooter 仅限于 ListView；至于 tools:listitem 属性二者皆可用。之前的效果图就是借助于此属性： activity_main.xml： 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\" android:background=\"#ffEBEBEF\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:background=\"?attr/colorPrimary\" android:theme=\"?attr/actionBarTheme\" android:minHeight=\"?attr/actionBarSize\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" android:elevation=\"1dp\" app:title=\"@string/app_name\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintHorizontal_bias=\"0.0\"/&gt; &lt;android.support.v7.widget.RecyclerView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\" android:scrollbars=\"vertical\" app:layout_constraintTop_toBottomOf=\"@+id/toolbar\" app:layout_constraintHorizontal_bias=\"0.0\" app:layout_constraintVertical_bias=\"0.0\" tools:listitem=\"@layout/card_item_layout\"/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; sample data即 样本数据 功能，可以通过 @tools:sample 来使用该属性，也属于 design-time view attributes。但它并非只是一个属性那么简单，更应该算是一个“工具利器”，所以会将其单独拿出来详细介绍。这个工具是本年度 Google 大会上 Android 开发团队特别介绍的一个新推属性。它有什么用呢？用处大了！先前的布局预览使用的数据都是我们直接在布局控件中注明或者在 strings.xml 文件中给出的，这一就会产生一些脏数据，不利于我们后期的处理。而有了 sample data，我们就可以对布局预览器中的 “样本数据”进行集中保存和管理了。 一、sample data 的使用Android studio 已为我们提供了以下样本数据，我可以直接拿来使用： Attribute value Description of placeholder data @tools:sample/full_names Full names that are randomly generated from the combination of@tools:sample/first_names and @tools:sample/last_names. @tools:sample/first_names Common first names. @tools:sample/last_names Common last names. @tools:sample/cities Names of cities from across the world. @tools:sample/us_zipcodes Randomly generated US zipcodes. @tools:sample/us_phones Randomly generated phone numbers with the following format: (800) 555-xxxx. @tools:sample/lorem Placeholder text that is derived from Latin. @tools:sample/date/day_of_week Randomized dates and times for the specified format. @tools:sample/date/ddmmyy @tools:sample/date/mmddyy @tools:sample/date/hhmm @tools:sample/date/hhmmss @tools:sample/avatars Vector drawables that you can use as profile avatars. @tools:sample/backgrounds/scenic Images that you can use as backgrounds. 上述表格中不仅有常用文本数据和日期等数据，还提供了一些图片样本数据，那么该如何使用呢？很简单，只需要切换到布局预览界面，并拖动一个 ImageView 到面板上，然后 Android studio 就会弹出如下界面： 然后选择 avatars 或者 background/scenic 数据源就可以了。当然你也可以通过 xml 代码形式来设置： 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:background=\"@android:color/white\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ImageView android:layout_width=\"36dp\" android:layout_height=\"36dp\" android:id=\"@+id/imageView\" android:layout_marginTop=\"16dp\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" android:layout_marginStart=\"16dp\" tools:srcCompat=\"@tools:sample/avatars\"/&gt; &lt;TextView android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:id=\"@+id/textView\" app:layout_constraintStart_toEndOf=\"@+id/imageView\" android:layout_marginStart=\"8dp\" app:layout_constraintEnd_toEndOf=\"parent\" android:layout_marginEnd=\"16dp\" app:layout_constraintTop_toTopOf=\"parent\" tools:text=\"@tools:sample/lorem/random\" tools:maxLines=\"8\" android:ellipsize=\"end\" android:textSize=\"14sp\" android:textColor=\"@color/title_color\" android:layout_marginTop=\"16dp\" app:layout_constraintHorizontal_bias=\"0.0\"/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 同样地，TextView 也可以通过 @tools:sample/lorem/random 来添加样本数据，如此一来，效果如下： 哈哈，还不错吧😄。那么问题来了，如果我们想要用自己的样本数据源呢？ 二、自定义 sample data如果我们想要是用自己定制化的样例数据，该如何做呢？其实很简单，只需要在 app 目录下创建 sample data directory 就可以了： 接下来，我们就可以在里面定制我们自己的数据了，在刚建好的 sampledata 目录下新建一个 txt 格式的数据文件，如 users，然后在里面创建如下数据： 如此这般，同理创建我们的其他数据： titles、descriptions，然后在上述 card_item_layout.xml 布局文件中替换并使用自己的数据源： 1234567891011121314&lt;TextView android:id=\"@+id/card_item_username\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"16dp\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/card_item_title\" app:layout_constraintEnd_toEndOf=\"@+id/card_item_title\" app:layout_constraintHorizontal_bias=\"0.0\" android:textSize=\"12sp\" android:textColor=\"#8989ae\" android:layout_marginEnd=\"16dp\" android:paddingEnd=\"16dp\" tools:text=\"@sample/users\" /&gt; 这里仅以其中一个 TextView 举例说明，其他同理。 什么？你以为到这里就讲完了？哈哈，少年，看你骨骼惊奇，再教你一招来上天入地：通过自定义 Json 格式的 数据来为控件绑定数据： 打完收工👋，还是上面的例子，来看看如何通过 json 数据来绑定： 1234567891011121314&lt;TextView android:id=\"@+id/card_item_username\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"16dp\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/card_item_title\" app:layout_constraintEnd_toEndOf=\"@+id/card_item_title\" app:layout_constraintHorizontal_bias=\"0.0\" android:textSize=\"12sp\" android:textColor=\"#8989ae\" android:layout_marginEnd=\"16dp\" android:paddingEnd=\"16dp\" tools:text=\"@sample/sample.json/data/username\" /&gt; 以上操作的时候 Android studio 都会自动提示 sampledata 路径下的数据文件，Json 格式亦会提示到具体字段。 最后从 Google Android 官方的进一步动向来看，后续Android更新过程中，布局编辑器将更加强大。从 Tools attributes 到 ConstraintLayout1.1 再到即将到来的 ConstraintLayout2.0 中的 MotionLayout，我们可以预见：Android 将在 UI 渲染和动画实现方面进一步解放我们的双手。后续我将继续为大家带来系列文章，敬请期待🌈。","link":"/2019/08/11/android-tools-attribute/"},{"title":"带你领略 ConstraintLayout 1.1 的新功能","text":"原文地址：Introducing Constraint Layout 1.1 原文作者：Sean McQuillan 约束布局（ConstraintLayout）通过使用 Android Studio 中的可视化编辑器来为您生成绝大多数的 UI，进而达到简化 Android 中创建复杂布局的目的。它通常被我们描述为更加强大的 RelativeLayout。通过使用约束布局，您可以定义一些复杂的布局而不需要创建复杂的视图层级。 约束布局最近发布了 1.1 稳定版本，并迅速获得大量好评。全面的优化改进可以让多数布局的运行速度比以前更快，屏障和群组等新功能使现实生活的设计变得简单！ Android Gradle123dependencies { compile 'com.android.support.constraint:constraint-layout:1.1.0'} 如果您想要在项目中使用新特性，需要添加 ConstraintLayout 1.1 版本作为依赖。 1.1 版本中的新特性百分比在约束布局 1.0 版本中，需要使用两条引导线才能让视图根据百分比来占据屏幕。而在约束布局 1.1 版本中，通过允许您轻松地将任何视图限制为百分比宽度或高度，一切将变得很简单。 使用百分比指定按钮的宽度，以便在保持设计效果的同时适应可用空间。 所有视图都支持 layout_constraintWidth_percent 和 layout_constraintHeight_percent 属性。这些将导致约束被固定在可用空间指定百分比位置。 因此，使用几行 XML 代码就可以使 Button 或 TextView 展开并以百分比填充屏幕。 1234&lt;Button android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; app:layout_constraintWidth_percent=&quot;0.7&quot; /&gt; 链条通过链条功能来放置多个元素可以让你配置它们该如何填充可用空间。在 1.1 版本中，我们已经修复了链条的一些问题，并使它们能够处理更多的视图。您可以通过在两边添加约束来生成一个链条。例如在下面这个动画中，每个视图之间都有一个约束。 通过 spread，spread_inside 和 packed，链条能够让您配置如何布置多个相关的视图。 app:layout_constraintVertical_chainStyle 属性可以作用于链条中的任何视图。 您可以设置它的值为 spread，spread_inside 或者 packed。 spread：均匀分配链中的所有视图 spread_inside：将第一个元素和最后一个元素放置在边缘上，并均匀分布其余元素 packed：将元素包裹在链条的中心 屏障如果您有几个视图会在运行时更改大小，则可以使用屏障功能来约束元素。您可以将屏障放置于几个元素的开始，顶部，末尾或底部。您可以将其视为制作虚拟组的一种方式 ，因为它不会将此组添加到视图层次结构中。 在布置国际化字符串或显示用户生成的无法预测大小的内容时，屏障非常有用。 屏障允许您通过几个视图来创建一个约束。 屏障将始终将自己置于虚拟群组之外，并且您可以使用它来限制其他视图。在上面这个例子中，右视图被限制为始终处于最大文本视图的末尾。 群组有时您需要一次显示或隐藏多个元素。为了支持这个，约束布局增加了群组功能。 一个群组并没有增加视图的层级——这实际上只是一种标记视图的方式。在下面的示例中，我们将标记 profile_name 和 profile_image 以供 id 配置文件引用。 当您有多个需要显示或陈列在一起的元素时，这将很有用。 123&lt;android.support.constraint.Group android:id=&quot;@+id/profile&quot; app:constraint_referenced_ids=&quot;profile_name,profile_image&quot; /&gt; 当定义名为 profile 的群组后，您可以为该群组设置可见性，并将其应用于 profile_name 和 profile_image。 123profile.visibility = GONEprofile.visibility = VISIBLE 圆形约束在约束布局中，大多数约束由屏幕尺寸指定——水平和垂直。在约束布局 1.1 版本中，有一个新的类型约束 constraintCircle，它允许您指定沿着一个圆形进行约束。您不必提供水平和垂直边距，而是指定圆的角度和半径。这对于像径向菜单这样的角度偏移的视图将非常有用！ 您可以通过指定要偏移的半径和角度来创建径向菜单。 创建圆形约束时，请注意，角度从顶部开始并顺时针进行。在这个例子中，你将按如下方式指定中间的 fab： 12345&lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/middle_expanded_fab&quot; app:layout_constraintCircle=&quot;@+id/fab&quot; app:layout_constraintCircleRadius=&quot;50dp&quot; app:layout_constraintCircleAngle=&quot;315&quot; /&gt; 约束集与动画您可以将 ConstraintLayout 随同 ConstraintSet (约束集)一起使用来一次实现多个元素的动画效果。 一个 ConstraintSet 仅持有一个 ConstraintLayout 的约束。你可以在代码中创建一个ConstraintSet，或者从一个布局文件中加载它。然后，您可以将 ConstraintSet 应用于 ConstraintLayout，更新所有约束以匹配 ConstraintSet 中的约束。 要使其具有动画效果，请使用 support library 中的 TransitionManager.beginDelayedTransition() 方法。此功能将使您的 ConstraintSet 中的所有布局的更新都通过动画来呈现。 这是一个更深入地涵盖了这个话题的视频： YouTube 视频链接：https://youtu.be/OHcfs6rStRo 新的优化约束布局 1.1 版本中添加了几个新的优化点，可加快您的布局速度。这些优化点作为一个单独的通道运行，并尝试减少布局视图所需的约束数量。 总的来说，它们是通过在布局中寻找常量并简化它们来运作的。 有一个名为 layout_optimizationLevel 的新标签，用于配置优化级别。它可以设置为以下内容： barriers：找出屏障所在，并用简单的约束取代它们 direct：优化那些直接连接到固定元素的元素，例如屏幕边缘或引导线，并继续优化直接连接到它们的任何元素。 standard：这是包含 barriers 和 direct 的默认优化级别。 dimensions：目前处于实验阶段，并且可能会在某些布局上出现问题——它会通过计算维度来优化布局传递。 chains：目前正在实验阶段，并计算出如何布置固定尺寸的元素链。 如果你想尝试试验性的优化上述中的 dimensions 和 chains，你可以在 ConstraintLayout 中通过如下代码来启用它们： 12&lt;android.support.constraint.ConstraintLayout app:layout_optimizationLevel=&quot;standard|dimensions|chains&quot; 喜欢这篇文章？不如给 Sean McQuillan 一点鼓励。 了解更多 使用约束布局构建响应式 UI | Android Developers 约束布局 | Android Developers 使用约束布局来设计你的 Android 视图 想要了解有关约束布局 1.1 版本的更多信息，请查看文档和代码实验室！","link":"/2018/05/20/constraintlayout/"},{"title":"Flutter 中“倒计时”的那些事儿","text":"好久不见了，文章有一段时间没有更新了，最近一直在沉迷工作无法自拨😂。上周，应公司号召以及上次Google大会中Flutter宣讲的感染，计划将公司新项目采用Flutter技术实现。大概花了几天熟悉了一下Flutter基础语法和结构组成，便着手开始项目的搭建和基础模块功能开发，毕竟只有通过实战才能加快新技术的熟悉和“消化”。 说到验证码功能，我们通常的做法可能是借助于计时器来实现，抱着几乎肯定的态度赶紧去查了一下 Flutter 官网有没有相关的计时器组件。果不其然，官方的确为我们提供了一个 Timer 组件来实现倒计时，我们来看看官方对于它的描述： A count-down timer that can be configured to fire once or repeatedly. 即它是一个支持一次或者多次周期性触发的计时器。首先，让我们来熟悉这两种场景下的基本用法。 单次触发这种情况下的一般场景是作为延时器来使用，我们并不会接收到倒计时的进度，只会在倒计时结束后收到回调提醒。例如，我们来看下 Flutter 官方提供的示例代码： 1234567891011const timeout = const Duration(seconds: 3);const ms = const Duration(milliseconds: 1);startTimeout([int milliseconds]) { var duration = milliseconds == null ? timeout : ms * milliseconds; return new Timer(duration, handleTimeout);}...void handleTimeout() { // callback function ...} 从上面代码可以看到，通过 new Timer(Duration duration, void callback()) 方式创建的定时器会提供一个 callback 回调方法来处理计时结束后的操作。这显然不符合我们验证码功能中实时显示进度的需求，让我们来看看 Timer 如何重复性触发回调。 周期性触发周期性触发计时回调的场景就很普遍了，只要是涉及到定时相关的操作可能都离不开它：我们既需要被告知计时什么时候结束，也需要实时地监测计时的进度。这正符合了我们最初想要的验证码功能这个需求。dart-async 包 同样为我们提供了 Timer.periodic 构造方法来创建一个可以重复回调的计时器： 123456Timer.periodic( Duration duration, void callback( Timer timer )) 此外，官方是这样描述 callback 参数的： The callback is invoked repeatedly with duration intervals until canceled with the cancel function. 大概意思是：callback 回调方法会伴随时间推移而被多次调用（调用周期为 duration），直到调用 Timer.cancel 方法。值得注意的是，周期性回调的计时器并不会“结束计时”，或者说它并不会自动结束计时任务，所以我们需要手动去统计时间并及时取消计时任务。具体如何操作呢？说了这么多，下面让我们进入本文正题：验证码倒计时实现吧😂。其实，该功能的实现代码很简单，这里就直接贴代码了： 12345678910111213141516171819202122232425262728Timer _countDownTimer; int _currentTime = 60; bool get _isTimeCountingDown =&gt; _currentTime != 60;void _startTimeCountDown() { if (_countDownTimer != null) { timer.cancel(); timer = null; } _countDownTimer = Timer.periodic(Duration(seconds: 1), (timer) { if (timer.tick == 60) { _currentTime = 60; _countDownTimer.cancel(); _countDownTimer = null; } else { _currentTime--; } setState(() { }); }); }@override void dispose() { _countDownTimer?.cancel(); _countDownTimer = null; super.dispose(); } 我们可以通过 Timer.tick 来获取当前计时（递增）的进度，同时借助于 _currentTime 来标记计时的进度值，其他的逻辑代码应该就比较好理解了。 什么？你以为到这里就完了？哈哈，当然不会，假如倒计时功能需要在我们项目里有很多不同的使用情景，那么就该对倒计时这个功能进行封装了，况且，通过 setState 方式来实时展示倒计时进度而去刷新整个视图树着实不太友好。 倒计时封装目前，Flutter 状态管理方案呈现“百家争鸣”之态，个人还是比较喜欢 Provider 来管理状态。下面就用 Provider 来将倒计时功能封装为一个组件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import 'dart:async';import 'package:flutter/material.dart';/// 计时器组件class CountDownTimeModel extends ChangeNotifier { final int timeMax; final int interval; int _time; Timer _timer; int get currentTime =&gt; _time; bool get isFinish =&gt; _time == timeMax; CountDownTimeModel(this.timeMax, this.interval) { _time = timeMax; } void startCountDown() { if (_timer != null) { _timer.cancel(); _timer = null; } _timer = Timer.periodic(Duration(seconds: interval), (timer) { if (timer.tick == timeMax) { _time = timeMax; timer.cancel(); timer = null; } else { _time--; } notifyListeners(); }); } void cancel() { if (_timer != null) { _timer.cancel(); _timer = null; } } @override void dispose() { _timer.cancel(); _timer = null; super.dispose(); }} 具体如何使用呢？熟悉 Provider 用法的小伙伴应该就不用多说了，这边为了演示方便，就以下面这个效果为例： 点击“获取验证码”按钮开始 60 秒倒计时服务，结束倒计时过程中按钮需要处于不可点击状态，倒计时结束后恢复点击状态。具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104class _LoginPageState extends State&lt;TestPage&gt; { @override Widget build(BuildContext context) { final logo = Hero( tag: 'hero', child: CircleAvatar( backgroundColor: Colors.transparent, radius: 48.0, child: Image.asset(ImageAssets.holder_logo), ), ); final email = TextFormField( keyboardType: TextInputType.emailAddress, autofocus: false, initialValue: 'alucard@gmail.com', decoration: InputDecoration( hintText: 'Email', contentPadding: EdgeInsets.fromLTRB(20.0, 10.0, 20.0, 10.0), border: OutlineInputBorder(borderRadius: BorderRadius.circular(32.0)), ), ); final password = TextFormField( autofocus: false, initialValue: 'some password', obscureText: true, decoration: InputDecoration( hintText: 'Password', contentPadding: EdgeInsets.fromLTRB(20.0, 10.0, 20.0, 10.0), border: OutlineInputBorder(borderRadius: BorderRadius.circular(32.0)), ), ); final loginButton = Padding( padding: EdgeInsets.symmetric(vertical: 16.0), child: RaisedButton( shape: RoundedRectangleBorder( borderRadius: BorderRadius.circular(24), ), onPressed: () { }, padding: EdgeInsets.all(12), color: Colors.lightBlueAccent, child: Text('Log In', style: TextStyle(color: Colors.white)), ), ); final forgotLabel = FlatButton( child: Text( 'Forgot password?', style: TextStyle(color: Colors.black54), ), onPressed: () {}, ); return Scaffold( backgroundColor: Colors.white, body: Center( child: ListView( shrinkWrap: true, padding: EdgeInsets.only(left: 24.0, right: 24.0), children: &lt;Widget&gt;[ logo, SizedBox(height: 48.0), email, SizedBox(height: 8.0), ScreenUtils.verticalSpace(2), Stack( children: &lt;Widget&gt;[ password, PartialConsumeComponent&lt;CountDownTimeModel&gt;( model: CountDownTimeModel(60, 1), builder: (context, model, _) =&gt; Positioned( right: 10, bottom: 1, top: 1, child: FlatButton( disabledColor: Colors.grey.withOpacity(0.36), color: Colors.white70.withOpacity(0.7), onPressed: !model.isFinish ? null : () { model.startCountDown(); }, child: Text( model.isFinish ? '获取验证码' : model.currentTime.toString()+'秒后重新获取', style: TextStyle(color: model.isFinish ? Colors.lightBlueAccent : Colors.white), ) ), ), ), ], ), SizedBox(height: 24.0), loginButton, forgotLabel ], ), ), ); }} 这里，我们通过在 CountDownTimeModel 中定义的 isFinish 字段来判断倒计时是否正在进行，进而处理按钮的各种状态（如颜色、点击状态、文字内容等）。此处为了方便对当前页面状态进行管理，我单独封装了一个公用的消费者组件： 12345678910111213141516171819202122232425262728293031class PartialConsumeComponent&lt;T extends ChangeNotifier&gt; extends StatefulWidget { final T model; final Widget child; final ValueWidgetBuilder&lt;T&gt; builder; PartialConsumeComponent({ Key key, @required this.model, @required this.builder, this.child }) : super(key: key); @override _PartialConsumeComponentState&lt;T&gt; createState() =&gt; _PartialConsumeComponentState&lt;T&gt;();}class _PartialConsumeComponentState&lt;T extends ChangeNotifier&gt; extends State&lt;PartialConsumeComponent&lt;T&gt;&gt; { @override Widget build(BuildContext context) { return ChangeNotifierProvider&lt;T&gt;.value( value: widget.model, child: Consumer&lt;T&gt;( builder: widget.builder, child: widget.child, ), ); }} 最后本人刚接触 Flutter 两周左右，有些地方可能会为了开发进度而忽略一些细节，如有不严谨或者疏漏之处欢迎指正。此外，后续我将为大家带来更多 Android 和 Flutter 方面文章，请期待。 参考 Flutter 官方文档 Provider Flutter | 状态管理指南篇—Provider","link":"/2020/02/18/flutter-timer/"},{"title":"当 Kotlin 中的监听器包含多个方法时，如何让它 “巧夺天工”？","text":"原文地址：Listeners with several functions in Kotlin. How to make them shine? 原文作者：Antonio Leiva 译文出自：掘金翻译计划 本文永久链接：https://github.com/xitu/gold-miner/blob/master/TODO1/listeners-several-functions-kotlin.md 译者：Moosphon 校对者：Qiuk17, zx-Zhu 当 Kotlin 中的监听器包含多个方法时，如何让它 “巧夺天工”？ 我经常遇到的一个问题是在使用 Kotlin 时如何简化具有多个方法的监听器的交互。对于具有只具有一个方法的监听器（或任何接口）很简单：Kotlin 会自动让您用 lambda 替换它。但对于具有多个方法的监听器来说，情况并非如此。 因此，在本文中，我想向您展示处理问题的不同方法，您甚至可以在途中学习一些新的 Kotlin 技巧！ 问题所在当我们处理监听器时，我们知道 OnclickListener 作用于视图，归功于 Kotlin 对 Java 库的优化，我们可以将以下代码： 12345view.setOnClickListener(object : View.OnClickListener { override fun onClick(v: View?) { toast(&quot;View clicked!&quot;) }}) 转化为这样： 1view.setOnClickListener { toast(&quot;View clicked!&quot;) } 问题在于，当我们习惯它时，我们希望它能够无处不在。然而当接口存在多个方法时，这种做法将不再适用。 例如，如果我们想为视图动画设置一个监听器，我们最终得到以下“漂亮”的代码： 12345678910111213141516171819view.animate() .alpha(0f) .setListener(object : Animator.AnimatorListener { override fun onAnimationStart(animation: Animator?) { toast(&quot;Animation Start&quot;) } override fun onAnimationRepeat(animation: Animator?) { toast(&quot;Animation Repeat&quot;) } override fun onAnimationEnd(animation: Animator?) { toast(&quot;Animation End&quot;) } override fun onAnimationCancel(animation: Animator?) { toast(&quot;Animation Cancel&quot;) } }) 你可能会反驳说 Android framework 已经为它提供了一个解决方案：适配器。对于几乎任何具有多个方法的接口，它们都提供了一个抽象类，将所有方法实现为空。在上述例子中，您可以这样： 1234567view.animate() .alpha(0f) .setListener(object : AnimatorListenerAdapter() { override fun onAnimationEnd(animation: Animator?) { toast(&quot;Animation End&quot;) } }) 好的，是改善了一些，但这存在几个问题： 适配器是类，这意味着如果我们想要一个类作为此适配器的实现，它不能扩展其他任何东西。 我们把一个本可以用 lambda 清晰表达的事物，变成了一个具有一个方法的匿名对象。 我们有什么选择？ Kotlin 中的接口：它们可以包含代码还记得我们谈到 Kotlin 中的接口吗？ 它们内部可以包含代码，因此，您能够声明可以实现而不是继承适配器（以防您现在将其用于 Android 开发中，您可以使用 Java 8 和接口中的默认方法执行相同的操作）： 123456interface MyAnimatorListenerAdapter : Animator.AnimatorListener { override fun onAnimationStart(animation: Animator) = Unit override fun onAnimationRepeat(animation: Animator) = Unit override fun onAnimationCancel(animation: Animator) = Unit override fun onAnimationEnd(animation: Animator) = Unit} 有了这个，默认情况下所有方法都不会执行任何操作，这意味着一个类可以实现此接口并仅声明它所需的方法： 123456class MainActivity : AppCompatActivity(), MyAnimatorListenerAdapter { ... override fun onAnimationEnd(animation: Animator) { toast(&quot;Animation End&quot;) }} 之后，您可以将它作为监听器的参数： 123view.animate() .alpha(0f) .setListener(this) 这个方案解决了开始时提出的一个问题，但是我们仍然要显式地声明它。如果我想使用 lambda 表达式呢？ 此外，虽然这可能会不时地使用继承，但在大多数情况下，您仍将使用匿名对象，这与使用 framework 适配器并无不同。 但是，这是一个有趣的想法：如果你需要为具有多个方法的监听器定义一种适配器，那么最好使用接口而不是抽象类。继承 FTW 的构成。 一般情况下的扩展功能让我们转向更加简洁的解决方案。可能会碰到这种情况（如上所述）：大多数时候你只需要相同的功能，而对另一个功能则不太感兴趣。对于 AnimatorListener，最常用的一个方法通常是 onAnimationEnd。那么为什么不创建一个涵盖这种情况的扩展方法呢？ 123view.animate() .alpha(0f) .onAnimationEnd { toast(&quot;Animation End&quot;) } 真棒！扩展函数应用于 ViewPropertyAnimator，这是 animate()、alpha 和所有其他动画方法返回的内容。 1234567inline fun ViewPropertyAnimator.onAnimationEnd(crossinline continuation: (Animator) -&gt; Unit) { setListener(object : AnimatorListenerAdapter() { override fun onAnimationEnd(animation: Animator) { continuation(animation) } })} 我之前已经谈过 内联，但如果你还有一些疑问，我建议你看一下官方的文档。 如您所见，该函数只接收在动画结束时调用的 lambda。这个扩展函数为我们完成了创建适配器并调用 setListener 这种不友好的工作。 这样就好多了！我们可以在监听器中为每个方法创建一个扩展方法。但在这种特殊情况下，我们遇到了动画只接受一个监听器的问题。因此我们一次只能使用一个。 在任何情况下，对于大多数重复的情况（像上面那样），它并不会损害到像如上提到的 Animator 本身的方法。这是更简单的解决方案，非常易于阅读和理解。 使用命名参数和默认值但是你和我喜欢 Kotlin 的原因之一是它有很多令人惊奇的功能来简化我们的代码！所以你可以想象我们还有一些选择的余地。接下来我们将使用命名参数：这允许我们定义 lambda 表达式并明确说明它们的用途，这将极大地提高代码的可读性。 我们会有类似于上面的功能，但涵盖所有方法的情况： 123456789101112131415161718192021222324inline fun ViewPropertyAnimator.setListener( crossinline animationStart: (Animator) -&gt; Unit, crossinline animationRepeat: (Animator) -&gt; Unit, crossinline animationCancel: (Animator) -&gt; Unit, crossinline animationEnd: (Animator) -&gt; Unit) { setListener(object : AnimatorListenerAdapter() { override fun onAnimationStart(animation: Animator) { animationStart(animation) } override fun onAnimationRepeat(animation: Animator) { animationRepeat(animation) } override fun onAnimationCancel(animation: Animator) { animationCancel(animation) } override fun onAnimationEnd(animation: Animator) { animationEnd(animation) } })} 方法本身不是很好，但通常是伴随扩展方法的情况。他们隐藏了 framework 不好的部分，所以有人必须做艰苦的工作。现在您可以像这样使用它： 12345678view.animate() .alpha(0f) .setListener( animationStart = { toast(&quot;Animation start&quot;) }, animationRepeat = { toast(&quot;Animation repeat&quot;) }, animationCancel = { toast(&quot;Animation cancel&quot;) }, animationEnd = { toast(&quot;Animation end&quot;) } ) 感谢命名参数，让我们可以很清楚这里发生了什么。 你需要确保没有命名参数的时候就不要使用它，否则它会变得有点乱： 12345678view.animate() .alpha(0f) .setListener( { toast(&quot;Animation start&quot;) }, { toast(&quot;Animation repeat&quot;) }, { toast(&quot;Animation cancel&quot;) }, { toast(&quot;Animation end&quot;) } ) 无论如何，这个解决方案仍然迫使我们实现所有方法。但它很容易解决：只需使用参数的默认值。空的 lambda 表达式将上面的代码演变成： 12345678inline fun ViewPropertyAnimator.setListener( crossinline animationStart: (Animator) -&gt; Unit = {}, crossinline animationRepeat: (Animator) -&gt; Unit = {}, crossinline animationCancel: (Animator) -&gt; Unit = {}, crossinline animationEnd: (Animator) -&gt; Unit = {}) { ...} 现在你可以这样做： 12345view.animate() .alpha(0f) .setListener( animationEnd = { toast(&quot;Animation end&quot;) } ) 还不错，对吧？虽然比之前的做法要稍微复杂一点，但却更加灵活了。 杀手锏操作：DSL到目前为止，我一直在解释简单的解决方案，诚实地说可能涵盖大多数情况。但如果你想发疯，你甚至可以创建一个让事情变得更加明确的小型 DSL。 这个想法 来自 Anko 如何实现一些侦听器，它是创建一个实现了一组接收 lambda 表达式的方法帮助器。这个 lambda 将在接口的相应实现中被调用。我想首先向您展示结果，然后解释使其实现的代码： 12345678910view.animate() .alpha(0f) .setListener { onAnimationStart { toast(&quot;Animation start&quot;) } onAnimationEnd { toast(&quot;Animation End&quot;) } } 看到了吗？ 这里使用了一个小型的 DSL 来定义动画监听器，我们只需调用我们需要的功能即可。对于简单的行为，这些方法可以是单行的： 123456view.animate() .alpha(0f) .setListener { onAnimationStart { toast(&quot;Start&quot;) } onAnimationEnd { toast(&quot;End&quot;) } } 这相比于之前的解决方案有两个优点： 它更加简洁：您在这里保存了一些特性，但老实说，仅仅因为这个还不值得努力。 它更加明确：它迫使开发人员说出他们所重写的功能。在前一个选择中，由开发人员设置命名参数。这里没有选择，只能调用该方法。 所以它本质上是一个不太容易出错的解决方案。 现在来实现它。首先，您仍需要一个扩展方法： 12345fun ViewPropertyAnimator.setListener(init: AnimListenerHelper.() -&gt; Unit) { val listener = AnimListenerHelper() listener.init() this.setListener(listener)} 这个方法只获取一个带有接收器的 lambda 表达式，它应用于一个名为 AnimListenerHelper 的新类。它创建了这个类的一个实例，使它调用 lambda 表达式，并将实例设置为监听器，因为它正在实现相应的接口。让我们看看如何实现 AnimeListenerHelper： 123class AnimListenerHelper : Animator.AnimatorListener { ...} 然后对于每个方法，它需要： 保存 lambda 表达式的属性 DSL 方法，它接收在调用原始接口的方法时执行的 lambda 表达式 在原有接口基础上重写方法 123456789private var animationStart: AnimListener? = nullfun onAnimationStart(onAnimationStart: AnimListener) { animationStart = onAnimationStart}override fun onAnimationStart(animation: Animator) { animationStart?.invoke(animation)} 这里我使用的是 AnimListener 的一个 类型别名： 1private typealias AnimListener = (Animator) -&gt; Unit 这里是完整的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950fun ViewPropertyAnimator.setListener(init: AnimListenerHelper.() -&gt; Unit) { val listener = AnimListenerHelper() listener.init() this.setListener(listener)}private typealias AnimListener = (Animator) -&gt; Unitclass AnimListenerHelper : Animator.AnimatorListener { private var animationStart: AnimListener? = null fun onAnimationStart(onAnimationStart: AnimListener) { animationStart = onAnimationStart } override fun onAnimationStart(animation: Animator) { animationStart?.invoke(animation) } private var animationRepeat: AnimListener? = null fun onAnimationRepeat(onAnimationRepeat: AnimListener) { animationRepeat = onAnimationRepeat } override fun onAnimationRepeat(animation: Animator) { animationRepeat?.invoke(animation) } private var animationCancel: AnimListener? = null fun onAnimationCancel(onAnimationCancel: AnimListener) { animationCancel = onAnimationCancel } override fun onAnimationCancel(animation: Animator) { animationCancel?.invoke(animation) } private var animationEnd: AnimListener? = null fun onAnimationEnd(onAnimationEnd: AnimListener) { animationEnd = onAnimationEnd } override fun onAnimationEnd(animation: Animator) { animationEnd?.invoke(animation) }} 最终的代码看起来很棒，但代价是做了很多工作。 我该使用哪种方案？像往常一样，这要看情况。如果您不在代码中经常使用它，我会说哪种方案都不要使用。在这些情况下要根据实际情况而定，如果你要编写一次监听器，只需使用一个实现接口的匿名对象，并继续编写重要的代码。 如果您发现需要使用更多次监听器，请使用其中一种解决方案进行重构。我通常会选择只使用我们感兴趣的功能进行简单的扩展。如果您需要多个监听器，请评估两种最新替代方案中的哪一种更适合您。像往常一样，这取决于你将要如何广泛地使用它。 希望这篇文章能够在您下一次处于这种情况下时帮助到您。如果您以不同方式解决此问题，请在评论中告诉我们！ 感谢您的阅读 🙂 如果发现译文存在错误或其他需要改进的地方，欢迎到 掘金翻译计划 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 本文永久链接 即为本文在 GitHub 上的 MarkDown 链接。","link":"/2018/12/22/kotlin-functions/"},{"title":"Flutter 开发小结 | Tips","text":"接触 Flutter 已经有一阵子了，期间记录了很多开发小问题，苦于忙碌没时间整理，最近项目进度步上正轨，借此机会抽出点时间来统一记录这些问题，并分享项目开发中的一点心得以及多平台打包的一些注意事项，希望能对大家有所帮助😁。 UI 组件使用官方为我们提供了大量原生效果的组件，如以 Android 中常见的 Material Design 系列组件和 iOS 系统中让设计师们“欲罢不能”的 Cupertino 系列组件。从我这一个月左右对于 Flutter UI 组件的使用情况来看，不得不感慨一句：“真香”。由于本人之前是做 Android 开发的，所以对于 Android 方面的一些“诟病”深有体会。例如，设计师经常让我们还原设计稿中的阴影效果，一般需要设置阴影颜色、x/y偏移量和模糊度等，然而 Android 原生并没有提供支持所有这些属性的一款组件，所以只能我们自己通过自定义控件去实现，现在还有多少人依然通过 CardView 来“鱼目混珠”呢？然而，在 Flutter 中就无需担心这种问题，通过类似前端中常用的盒子组件—— Container 就可以轻松实现。 当然，Flutter 虽然很强大，但 UI 组件也不是万能的，跨平台之路注定漫长而布满荆棘，偶尔也会伴随着一些小问题。 TextField 软键盘弹起后组件溢出的问题 由于页面不支持滚动，一旦使用 TextField，软键盘弹起后很容易会覆盖一些UI组件，如果不以为意，那么下面这个问题就会成为“家常便饭”： 1A RenderFlex overflowed by xx pixels on the bottom. 常用的解决方案就是通过嵌套一层 SingleChildScrollView 来规避，当软键盘弹起时，下方的组件会被软键盘自动顶上去。 HintText 不居中问题 这个问题很多人应该都遇到过，当我们在项目中设置中文 Locale 后，在 TextField 的 InputDecoration 中设置 hintText 时，会发现提示文本向下偏移几个像素，这应该属于 Flutter 的bug。如何解决这个问题呢？很简单，只需要设置 textBaseine 属性，如下代码所示： 1234567891011121314TextFormField( decoration: InputDecoration( prefixIcon: Icon( Icons.lock_outline ), hintText: S.of(context).loginPasswordHint, ), style: TextStyle( /// handle hint text offset problem. textBaseline: TextBaseline.alphabetic ), keyboardType: TextInputType.number, onSaved: (password) {},) 具体可参考：https://github.com/flutter/flutter/issues/40118 焦点问题 输入框的焦点问题主要体现在两点： 前往另一个页面返回后自动弹出了软键盘（即自动获取了焦点） iOS手机上切换至数字键盘后无法关闭软键盘 这两个问题其实都可以借助 FocusNode 来解决，先来看下面一段代码： 12345678FocusNode _writingFocusNode = FocusNode();... void _clearTextFieldFocus() { if (_writingFocusNode.hasFocus) { _writingFocusNode.unfocus(); } } 上述代码创建了一个 FocusNode 对象，并声明了移除焦点的方法，相信大家不难判断出。此外，我们需要给 TextField 的 focusNode 属性传入我们创建的 _writingFocusNode。问题一中，我们可以在页面跳转前先移除焦点，这样，从二级页面返回后输入框就不会自动弹出软键盘。问题二中，我们可以在用户点击空白区域后自动移除焦点（关闭软键盘），以下代码供参考： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Widget _buildInputArea() =&gt; Stack( children: &lt;Widget&gt;[ // 通过空白区域的点击事件来关闭软键盘 GestureDetector( onTap: () { _clearTextFieldFocus(); }, child: Container( /// 此处注意设置背景颜色，否则默认透明色可能会穿透，无法响应点击事件 color: AppTheme.surfaceColor, width: MediaQuery.of(context).size.width, height: MediaQuery.of(context).size.height, ), ), Column( children: &lt;Widget&gt;[ ScreenUtils.verticalSpace(32), // account input edit text Padding( padding: EdgeInsets.only(bottom: AutoSize.covert.dpToDp(12)), child: TextField( controller: _accountTextController, decoration: InputDecoration( prefixIcon: Padding( padding: EdgeInsets.all(AutoSize.covert.dpToDp(12)), child: ImageIcon(AssetImage(ImageAssets.ic_login_user_input)), ), hintText: S.of(context).loginAccountHint, ), keyboardType: TextInputType.number, ), ), // password input edit text Padding( padding: EdgeInsets.only(bottom: AutoSize.covert.dpToDp(12)), child: ValueListenableBuilder( valueListenable: obscureTextModel, builder: (context, value, child) =&gt; TextField( controller: _passwordTextController, obscureText: value, decoration: InputDecoration( prefixIcon: Padding( padding: EdgeInsets.all(AutoSize.covert.dpToDp(12)), child: ImageIcon(AssetImage(ImageAssets.ic_login_pwd_input)), ), suffixIcon: IconButton( icon: Icon(value ? Icons.visibility_off : Icons.visibility, size: AutoSize.covert.dpToDp(20)), onPressed: () { obscureTextModel.value = !value; } ), hintText: S.of(context).loginPasswordHint, ), keyboardType: TextInputType.text, ), ), ), ], ), ], ); Container 盒子模型特点 对于接触过前端的人来说，应该都领略过“盒子模型”的强大了，所以，Container 的强大之处相信也不用我多说了：它几乎是一个万能的“容器”，既能设置 margin、padding、aligment，又可以装饰它的背景 docoration 属性，例如阴影效果、渐变色、圆角效果等等。 设置背景色问题 Container虽好，但也需要在使用时注意一些问题，例如，它的源码注释中就说到：我们可以通过 color 和 decoration 来设置盒子背景，但两者却不能同时存在，如果我们既希望保留背景色，又想使用装饰器 (decoration)，我们可以直接设置 BoxDecoration 的 color 属性。 SafeAreaAndroid中存在状态栏、底部导航栏，而 iOS 中也存在状态栏和”底部导航条”，所以如果我们页面中的边界部分需要固定显示一些小组件，那么我们最好能够在最外层嵌套一层 SafeArea 组件，即让UI组件处于“安全区域”，不至于引起适配问题。 123456Material( color: AppTheme.surfaceColor, child: SafeArea( child: Container(), ),) 列表组件Flutter中常见的列表组件有 ListView、GridView、PageView 等，一个完整的应用肯定也离不开这些组件。我们在使用时，需要留意以下几点： Vertical viewport was given unbounded height 问题 作为初学者，我们在初期应该都碰到过这个问题：Vertical/Horizontal viewport was given unbounded height，这是由于我们没有给列表组件指定高度或者宽度而引起的，一般出现场景是在 Column 中，我们可以给列表组件包裹一层盒子或者被 Expanded 包裹，让其尽可能占据最大空间： 1234567891011Column( children:[ ..., Expanded( child: GridView.builder( .... ) ) ) ]) physics 属性 做过原生开发的都知道，在 Android 中，支持滚动的组件滑到顶或者滑到底后自带 colorPrimary 色调的水波纹效果，至于iOS，则是越界回弹效果。你拿着 Android 中的默认效果去给设计师看，“亲果党”的他们肯定不干了，硬是让你改成 iOS 的回弹效果。所幸，Flutter 早就考虑到了这一点，支持滑动的组件中都提供了 physics 属性，只需要将其设置为 BouncingScrollPhysics 就能完美实现回弹效果。同时，physics 还有其他属性，这里不再一一介绍，大家可以去查看相关文档和源码，这里提一下 NeverScrollableScrollPhysics，即禁止滑动。这个有什么用呢？其实还是挺有用的，比如嵌套的两个滑动组件中就可以将其中一个的 physics 属性设置为 NeverScrollableScrollPhysics，这样可以简单快速解决滑动冲突。此外，有些特殊场景我们可能不希望用户可以滑动，而是通过按钮点击来控制列表滑动，这时候，设置该属性就再好不过啦。 自定义弹窗Flutter 为我们提供了一些内置的定制弹窗，这里不再一一说明了。如何自定义弹窗？其实很简单，只需要明白：弹窗即页面。以下面的效果为例： 相信对于大家来说，上面的UI页面实现起来并不困难，那我们离 Dialog 效果仅剩一步之遥了：点击空白区域关闭。其实，在上面的某段代码中我已经贴了关键代码，细心的小伙伴应该也察觉到了，没错，我们可以通过 Stack 组件包裹半透明蒙层（如Container）和分享功能组件，我们只需为半透明蒙层增加点击事件即可： 123456789101112131415161718Stack( children: &lt;Widget&gt;[ // 通过空白区域的点击事件来关闭弹窗 GestureDetector( onTap: () { //关闭弹窗 Navigator.maybePop(context); }, child: Container( color: AppTheme.dialogBackgroundColor, width: MediaQuery.of(context).size.width, height: MediaQuery.of(context).size.height, ), ), Container( child: ... ) ) 哈哈，是不是有种恍然大悟的感觉，如此一来，弹窗对于我们来说不就是写一个页面那么简单了吗😄。 InkWellInkWell 在 Android 中比较常见，俗称“水波纹”效果，属于按钮的一种，它支持设置波纹颜色、圆角等属性。我们偶尔可能会遇到水波纹失效的问题，这一般是因为我们在 InkWell 内部的 child 中设置了背景，从而导致水波纹效果被遮盖。如何解决这个问题？其实很简单，只需要在 InkWell 外层套上 Material 并设置 color 即可: 123456789101112Material( color: Colors.white, child: InkWell( borderRadius: AppTheme.buttonRadius, // 圆角 splashColor: AppTheme.splashColor, // 波纹颜色 highlightColor: Colors.transparent, // 点击状态 onTap: () {}, // 点击事件 child: Container( ... ), ),) 或者，我们也可以借助于之前实现自定义 Dialog 的思路，使用 Stack 包裹需要点击的区域，并将 InkWell 放在上层： 12345678910111213Stack( children: &lt;Widget&gt;[ Image(), Material( color: Colors.transparent, child: InkWell( splashColor: AppTheme.splashColor, onTap: () {}, ), ) ) ], ) IconButton和上面 InkWell 一样，IconButton 同样可能有类似点击效果问题，与上面解决方法大同小异： 123456789101112Material( type: MaterialType.circle, color: Colors.transparent, clipBehavior: Clip.antiAlias, child: IconButton( onPressed: () =&gt; Share.share(S.of(context).commonWhoAppShareIconButtonDescription), icon: Icon( Icons.share, size: 22, ) ),), Theme 相关Android中的 Theme 相信大家也不陌生了，它能够定制化我们某类组件的风格 ，能够大幅度减少重复代码和工作量。Flutter 中也提供了 Theme 来让我们配置和复用全局组件的样式。正常来说，我们应用的高保真设计图中的一类组件一般风格相似，如： 上图两个页面的按钮样式应该是一样的，所以我们可以抽离成 Theme，其他组件同理。可做如下配置(仅供参考)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class AppTheme { AppTheme._(); /// common colors used in theme, text, background or borders static const Color primaryColor = Color(0xFF92C9AA); static const Color secondaryColor = Color(0x96A3E4C5); static const Color colorAccent = Color(0xFFE5F378); static const Color textPrimaryColor = Color(0xFF2A2A2A); static const Color textSecondaryColor = Color(0xFF383838); static const Color textHintColor = Color(0xFFB3B3B3); static const Color borderColor = Color(0xFFE8E8E8); static const Color surfaceColor = Color(0xFFF9F9F9); static const double underlineBorderWidth = 0.6; static TextTheme textTheme = TextTheme( headline: headline, title: title, body1: body1, body2: body2, caption: small ); // large title static const headline = TextStyle( fontWeight: FontWeight.bold, fontSize: 30, letterSpacing: 0.27, color: textPrimaryColor ); // normal title static const title = TextStyle( fontSize: 18, letterSpacing: 0.18, color: textPrimaryColor ); // normal text body1 static TextStyle body1 = TextStyle( fontSize: 16, letterSpacing: 0.48, color: textPrimaryColor ); // normal text body2 static TextStyle body2 = TextStyle( fontSize: 14, letterSpacing: 0.25, color: textSecondaryColor ); static TextStyle small = TextStyle( fontSize: 12, color: textHintColor ); // input field border decoration style static const inputDecorationTheme = InputDecorationTheme( hintStyle: TextStyle(fontSize: 14), focusedBorder: UnderlineInputBorder( borderSide: BorderSide(width: underlineBorderWidth, color: primaryColor) ), border: UnderlineInputBorder( borderSide: BorderSide(width: underlineBorderWidth, color: borderColor) ), enabledBorder: UnderlineInputBorder( borderSide: BorderSide(width: underlineBorderWidth, color: borderColor) ), disabledBorder: UnderlineInputBorder( borderSide: BorderSide(width: underlineBorderWidth, color: borderColor) ), );} 那么，我们可以在入口程序将这套 Theme 规则应用到全局： 1234567891011121314MaterialApp( title: 'xxx', // 全局主题配置 theme: ThemeData( textTheme: AppTheme.textTheme, primaryColor: AppTheme.primaryColor, canvasColor: AppTheme.surfaceColor, scaffoldBackgroundColor: AppTheme.surfaceColor, inputDecorationTheme: AppTheme.inputDecorationTheme, appBarTheme: AppTheme.appBarTheme, //... ), home: xxxPage() ) 以上仅列举了部分常见UI组件的使用技巧和问题，如有其他问题欢迎留言探讨。 功能需求实现除了 Flutter 中的一些 UI 组件的的使用以外，应用自然还需要涉及到很多具体的业务功能需求，常见的有第三方登录、分享、地图、Lottie 动画接入、第三方字体下载和加载等等。这个时候就需要我们灵活变通了，在保证项目进度顺利进行的前提下有选择性地去借助一些插件和工具，或者前往 Flutter 的 Github Issue 社区去寻找答案了，这里也选择几个常用需求简单说一下。 当前设备的系统语言很多时候我们需要根据当前系统使用的语言去动态选择加载的内容，举个例子，我们经常需要根据当前语言去加载中文或者英文版的用户隐私条款，我们可以借助 Localizations 去获取当前使用语言的 languageCode，进而比对和处理： 1234/// 判断当前语言类型_navigateToUrl(Localizations.localeOf(context).languageCode == 'zh' ? Api.PRIVACY_POLICY_ZH_CN : Api.PRIVACY_POLICY_EN); 第三方登录/分享这部分当初考虑自己写插件来对接原生的分享sdk，但考虑到时间成本就暂时搁置了，找到几个不错的插件来实现了该部分功能： fluwx 该插件应该是在微信社会化分享、支付等方面功能集成度比较高的插件了，是由 OpenFlutter 社区负责维护的，目前没发现有什么问题。具体配置的细节就不再说明了，它的文档很详细，具体可参考：https://github.com/OpenFlutter/fluwx 另外，他们组织中还有其他很多优秀的 Flutter 相关项目，大家也可以去学习一下。 flutter fake toolkit 这个是一系列插件，包括了微信、微博、QQ、支付宝等众多平台，让人佩服作者的产出率。目前使用起来也没发现什么大问题，也希望作者能够多邀请几个小伙伴来维护，提升更新的频率。这里附上其中几个常用的插件： QQ插件：https://github.com/v7lin/fake_tencent 微博插件：https://github.com/v7lin/fake_weibo 支付宝：https://github.com/v7lin/fake_alipay Lottie动画相信大家对 Airbnb 公司推出的这个动画工具已经有所耳闻了，Lottie 支持多平台，使用同一个JSON 动画文件，可在不同平台实现相同的动画效果。现在复杂动画很多时候都借助于它，能够有效减少开发成本和保持动画的高还原度。同样，Flutter 中也有一些封装了 Lottie 动画的插件，让我们可以在 Flutter 上也可以感受到它的魅力。 这里，我个人使用的插件是 flutter_lottie 插件，还算稳定，支持动画属性和进度操作，唯一遗憾就是有段时间没更新了😂，后续考虑到 iOS 方面的兼容性可能会自己写一个插件。在 pubspec.yaml 中依赖操作如下： 123# Use Lottie animation in Flutter. # @link: https://pub.dev/packages/flutter_lottie flutter_lottie: 0.2.0 具体使用技巧可参考它的example：https://github.com/CameronStuartSmith/flutter_lottie 这里附上控制动画进度的部分代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788int _currentIndex = 0; LottieController _lottieController; PageController _pageController = PageController(); // the key frames of animation final ANIMATION_PROGRESS = [ 0.0, 0.2083, 0.594, 0.8333, 1 ]; // the duration of each animation sections final ANIMATION_TIMES = [ 2300, 4500, 3500 ]; // animation progress controller Animation&lt;double&gt; animation; AnimationController _animationController; @override void initState() { super.initState(); _animationController = new AnimationController( duration: Duration(milliseconds: ANIMATION_TIMES[_currentIndex]), vsync: this); final Animation curve = new CurvedAnimation(parent: _animationController, curve: Curves.linear); animation = new Tween(begin: 0.0, end: 1.0).animate(curve); animation.addListener(() { _applyAnimation(animation.value); }); }// 布局代码....... Positioned( bottom: 0, child: Container( width: MediaQuery.of(context).size.width, // 此处为了将动画组件居下放置 height: AutoSize.covert.dpToDp(667), child: LottieView.fromFile( filePath: 'assets/anims/user_guide_anim.json', autoPlay: false, loop: true, reverse: true, onViewCreated: (controller) { _lottieController = controller; Future.delayed(Duration(milliseconds: 1), () { _animationController.forward(); }); }, ), ), ),// description page view Container( width: MediaQuery.of(context).size.width, height: MediaQuery.of(context).size.height, margin: EdgeInsets.only(bottom: 60), child: PageView( physics: BouncingScrollPhysics(), controller: _pageController, onPageChanged: (index) { setState(() { _currentIndex = index; _animationController.duration = Duration(milliseconds: ANIMATION_TIMES[index]); }); Future.delayed(Duration(microseconds: 600), () { _animationController.forward(from: 0); }); }, children: _buildPageGroup(), ), ),...... void _applyAnimation(double value) { var startProgress = ANIMATION_PROGRESS[_currentIndex]; var endProgress = ANIMATION_PROGRESS[_currentIndex + 1]; var progress = startProgress + (endProgress - startProgress) * value; _lottieController.setAnimationProgress(progress); } 简单解释一下上述代码逻辑，我们这里主要借助于 Lottie 来实现用户引导页的切换动画，引导页分为三个画面，所以需要我们记录和保存动画的关键帧和每段画面的执行时间。至于动画的控制执行权交由上层的 PageView 来滑动实现，每次滑动通过 AnimationController 和 setState((){}) 来控制和刷新每段动画的执行时间和执行刻度。具体demo效果如下所示： 外部字体下载和加载如果接触过文字编辑功能开发的小伙伴应该都知道，我们一般会提供几十种字体供用户使用，当然，我们不可能在项目打包时就放入这么多字体包，这样显而会严重增加安装包大小。我们一般的做法是：当用户第一次点击想使用某个字体时，我们会先将其下载到手机本地存储，然后加载字体，后续当用户再次选择该字体，那么直接从本地加载即可。那么问题来了，Flutter 目前的示例中仅为我们提供了从本地 Asset 目录下加载字体的方式，显然想要实现上述需求，需要我们自己寻求出路。 幸运的是，上帝为我们关上了一扇门，也为我们打开了一扇窗，Flutter 中为我们提供了一个 FontLoader 工具，它有一个 addFont 方法，支持将 ByteData 格式数据转化为字体包并加载到应用字体资源库： 123456789101112131415161718192021222324252627282930313233343536 /// Registers a font asset to be loaded by this font loader. /// /// The [bytes] argument specifies the actual font asset bytes. Currently, /// only TrueType (TTF) fonts are supported. void addFont(Future&lt;ByteData&gt; bytes) { if (_loaded) throw StateError('FontLoader is already loaded'); _fontFutures.add(bytes.then( (ByteData data) =&gt; Uint8List.view(data.buffer, data.offsetInBytes, data.lengthInBytes) )); }... /// Loads this font loader's font [family] and all of its associated assets /// into the Flutter engine, making the font available to the current /// application. /// /// This method should only be called once per font loader. Attempts to /// load fonts from the same loader more than once will cause a [StateError] /// to be thrown. /// /// The returned future will complete with an error if any of the font asset /// futures yield an error. Future&lt;void&gt; load() async { if (_loaded) throw StateError('FontLoader is already loaded'); _loaded = true; final Iterable&lt;Future&lt;void&gt;&gt; loadFutures = _fontFutures.map( (Future&lt;Uint8List&gt; f) =&gt; f.then&lt;void&gt;( (Uint8List list) =&gt; loadFont(list, family) ) ); return Future.wait(loadFutures.toList()); } 如此一来，那我们解决思路也就“手到擒来”了：只需要将字体下载到本地并以文件形式存储，在使用时将字体文件再转为 ByteData 数据格式供 FontLoader 加载即可。这里附上简化后的部分关键代码： 1234567891011121314151617181920/// 加载外部的字体Future loadFontFile(LetterFont font) async { // load font file var fontLoader = FontLoader(font.fontName); fontLoader.addFont(await fetchFont(font)); await fontLoader.load(); }/// 从网络下载字体资源Future&lt;ByteData&gt; fetchFont(LetterFont font) async { final response = await https.get( font.fontUrl); if (response.statusCode == 200) { // 这里也可以做保存到本地的逻辑处理 return ByteData.view(response.bodyBytes.buffer); } else { // If that call was not successful, throw an error. throw Exception('Failed to load font'); } } 打包上架相关打包方面也有一部分细节需要注意一下，这里谈一下 Android 和 iOS 开发环境配置和打包差异以及列举部分常见问题，其他问题因人而异，也因版本而异，就不单独拿出来讲了。 Android方面 开发工具 Android studio3.6稳定版 代码编译环境 Kotlin + AndroidX 目前Flutter创建项目默认勾选两个选项 版本号配置 在 android/app/build.gradle 中配置 flutterVersionCode 和 flutterVersionName。 注意：如果在 pubspec.yaml 中配置了version，那么 Flutter 具体打包的版本会实际根据 pubspec.yaml 的 version 来构建。 网络配置 目前 Android 官方不建议采用http请求格式，推荐使用 https，所以，如果项目中使用到了http格式请求，那么需要添加网络配置。首先在 android/app/src/main/res 路径下创建名为 xml 的文件夹：然后创建名为 network_security_config 的 xml 文件，接着将如下代码复制进去： 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=\"true\"/&gt;&lt;/network-security-config&gt; 然后在 AndroidManifest.xml 文件中设置 networkSecurityConfig 属性即可： 12345678910 &lt;application android:name=\"io.flutter.app.FlutterApplication\" android:label=\"Timeory\" android:icon=\"@mipmap/ic_launcher\" tools:replace=\"android:name\" android:usesCleartextTraffic=\"true\" android:networkSecurityConfig=\"@xml/network_security_config\" tools:ignore=\"GoogleAppIndexingWarning\"&gt; ......&lt;/application&gt; 权限配置 一般我们项目中都会用到权限申请，并且很多 flutter 插件中也会要求我们去自己配置权限，我们可能需要在 AndroidManifest.xml 文件中添加如下常用权限（只是样例）： 12345678&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/&gt; &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\"/&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt; &lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt; 当然这些还是不够的，Android6.0及以上，我们还需要在代码中动态申请权限，Flutter中有很多优秀的权限申请插件，iOS 上面一般没问题，Android由于碎片化比较严重，可能会在不同机型上出现各种奇怪问题，比如，红米部分机型借助于 permission_hanlder 插件申请定位权限可能会失败的问题，这里需要注意一下，留个心眼。 Logo 配置 Logo 需要在 android/app/src/main/res 中添加和配置，一般只需要准备 hdpi、mdpi、xhdpi、xxhdpi、xxxhdpi格式即可。另外，Android8.0 及以上需要适配圆角logo，否则在部分高版本机型上会显示 Android 默认的机器人logo。 具体可以参考该文章：https://blog.csdn.net/guolin_blog/article/details/79417483 打包 一般情况下我们通过 flutter build apk 来打包，生成的安装在 build/app/outputs/apk/release 目录下，这样打出来的包一般比较大，因为它包含了 arm64-v8a、armeabi-v7a 和 x86_64 三种cpu架构的包。大家可以根据需要有选择性的针对特定机型的cpu架构打包，执行如下命令即可： 1flutter build apk --target-platform android-arm,android-arm64,android-x64 --split-per-abi 执行完毕后就会在 release 目录下生成三种格式的apk包。 另外，大家可以选择一些apk体积优化的方案，具体可参考： https://my.oschina.net/u/1464083/blog/2395914 https://www.jianshu.com/p/555c948e5195 iOS 方面由于本人之前做 Android 开发，没有接触过 iOS，所以打包到 iOS 平台还是遇到不少问题。 开发工具： Xcode11.3.1 稳定版 (打包环境) + Visual Studio Code 1.42.1 (编码环境) 代码编译环境：Swift + Objective-C (目前创建Flutter项目默认勾选为swift，由于项目启动时Flutter尚未更新该配置，所以项目中部分插件采用的是oc)，希望后面逐步替换为主流的swift。 版本号配置： 只需要在Xcode中 Runner -&gt; targets -&gt; General -&gt; Identity 配置即可。 网络配置 iOS 中，官方同样约束我们使用 https 请求，如果我们需要暂时使用http格式请求来测试，可以做如下配置： 在 Runner -&gt; targets -&gt; General -&gt; Info 中添加 App Transport Security Settings 属性，并在此属性标签内添加 Allow Arbitrary Loads 子属性，并将值设置为 YES 即可。 Logo配置 iOS 中的 logo 配置只需要找到如下入口： 点击 ➡️ 即可进入 logo 资源目录，默认的为 Flutter 的官方 logo，我们只需要根据具体 logo 尺寸去替换资源即可。 国际化语言配置 项目中如果支持国际化语言，Android 中无需额外配置，iOS 中需要在 Info.plist 中添加 Localized resource can be mixed 属性，并设置值为 YES 即可，否则APP运行后可能会出现实际展示的是英文的情况。 打包相关 Xcode打包时切记要使用稳定版，不要使用 beta 版本，否则可能会出现下面的问题： 以上就是本人对近期 Flutter 开发过程的一点简单总结，如果能够帮助到您那将再好不过😄。刚接触 Flutter 不久，相关阐述可能不够严谨或存在理解错误，如您发现，还请指出，感谢您的阅读。","link":"/2020/04/19/flutter-tips/"},{"title":"MotionLayout:)打开动画新世界大门","text":"最初接触到 MotionLayout 是在国外知名博客的 Android 专栏上。第一眼见到 MotionLayout 时无疑是兴奋的，在经过使用和熟悉了这个布局组件之后，我就想将这份喜悦传递给国内开发者，从此“拳打”设计，“脚踢”产品😁。当然，由于关于 MotionLayout 的外文专栏相关介绍已足够详细，所以本文仅对其进行总结和简单应用。老规矩，正文开始前先上一张图： 简介由于本文的受众需要有一点 ConstraintLayout 的用法基础，如果你对它并不熟悉，可以先去花几分钟看一下本人之前的译文：带你领略 ConstraintLayout 1.1 的新功能。回到正题，什么是 MotionLayout ？很多人可能会对这个名词比较陌生，但如果说到它的前身 — ConstraintLayout*，大家应该就多少有些了解了。MotionLayout* 其实是 Google 在去年开发者大会上新推的布局组件。我们先来看看 **Android 官方对于它的定义： MotionLayout is a layout type that helps you manage motion and widget animation in your app. MotionLayout is a subclass of ConstraintLayout and builds upon its rich layout capabilities. 简单翻译过来就是：MotionLayout 是一个能够帮助我们在 app 中管理手势和控件动画的布局组件。它是 ConstraintLayout 的子类并且基于它自身丰富的布局功能来进行构建。 当然，你也可以按照字面意思将它简单理解为“运动布局”。为什么这么说呢？通过上图来对比传统的布局组件（如：FrameLayout、LinearLayout 等），我们不难发现：MotionLayout 是布局组件中的一个“里程碑”，由此开始就告别了 XML 文件中只能”静态“操作 UI 的历史。通过 MotionLayout，我们就能更加轻易处理其内部子 View 的手势操作和”运动”效果了。正如 Nicolas Roard 所说的那样： 你可以在 MotionLayout 功能方面将其看作是属性动画、TransitionManager 和 CoordinatorLayout 的结合体。 MotionLayout 基础首先，我们需要从 MotionLayout 的一些基本属性和用法讲起，这样对于我们后面的实际操作将会很有帮助。 引入 MotionLayout 库123dependencies { implementation 'com.android.support.constraint:constraint-layout:2.0.0-beta2'} 目前，MotionLayout 仍处于 beta 版本，虽然官方之前说过 MotionLayout 的动画辅助工具将会在 beta 版本推出，但目前还没有出现，不出意外应该是在下一个版本了。到时候应该就可以像 ConstraintLayout 那样直接通过布局编辑器来进行部分预览和参数操作了。 在布局文件中使用 MotionLayout想要使用 MotionLayout，只需要在布局文件中作如下声明即可： 123456789&lt;android.support.constraint.motion.MotionLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layoutDescription=\"@xml/scene1\"&gt;&lt;/android.support.constraint.motion.MotionLayout&gt; 由于 MotionLayout 作为 ConstraintLayout 的子类，那么就自然而然地可以像 ConstraintLayout 那样使用去“约束”子视图了，不过这可就有点“大材小用了”，MotionLayout 的用处可远不止这些。我们先来看看 MotionLayout 的构成： 由上图可知，MotionLayout 可分为 &lt;View&gt; 和 &lt;Helper&gt; 两个部分。*&lt;View&gt;* 部分可简单理解为一个 ConstraintLayout，至于 &lt;Helper&gt; 其实就是我们的“动画层”了。MotionLayout 为我们提供了 layoutDescription 属性，我们需要为它传入一个 MotionScene 包裹的 XML 文件，想要实现动画交互，就必须通过这个“媒介”来连接。 MotionScene：传说中的“百宝袋”什么是 MotionScene？结合上图 MotionScene 主要由三部分组成：**StateSet、ConstraintSet** 和 **Transition**。为了让大家快速理解和使用 MotionScene，本文将重点讲解 ConstarintSet 和 Transition，至于 StateSet 状态管理将会在后续文章中为大家介绍具体用法和场景。同时，为了帮助大家理解，此处将开始结合一些具体小实例来帮助大家快速理解和使用它。 首先，我们从实现下面这个简单的效果讲起： GIF 画质有点渣，见谅，但从上图我们可以发现这是一个简单的平移动画，通过点击自身（篮球）来触发，让我们来通过 MotionLayout 的方式来实现它。首先来看下布局文件： 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.motion.MotionLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layoutDescription=\"@xml/step1\" tools:context=\".practice.MotionSampleActivity\"&gt; &lt;ImageView android:id=\"@+id/ball\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@drawable/ic_basketball\"/&gt;&lt;/android.support.constraint.motion.MotionLayout&gt; 布局文件很简单，只不过你可能会注意到，我们对 ImageView 并没有添加任何约束，原因在于：我们会在 MotionScene 中声明 ConstraintSet，里面将包含该 ImageView 的“运动”起始点和终点的约束信息。当然你也可以在布局文件中对其加以约束，但 MotionScene 中对于控件约束的优先级会高于布局文件中的设定。这里我们通过 layoutDescription 来为 MotionLayout 设置它的 MotionScene 为 step1，接下来就让我们一睹 MotionScene 的芳容： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!--describe the animation for activity_motion_sample_step1.xml--&gt;&lt;MotionScene xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;!-- A transition describes an animation via start and end state --&gt; &lt;Transition app:constraintSetStart=\"@id/start\" app:constraintSetEnd=\"@id/end\" app:duration=\"2200\"&gt; &lt;OnClick app:targetId=\"@id/ball\" app:clickAction=\"toggle\" /&gt; &lt;/Transition&gt; &lt;!-- Constraints to apply at the start of the animation --&gt; &lt;ConstraintSet android:id=\"@+id/start\"&gt; &lt;Constraint android:id=\"@+id/ball\" android:layout_width=\"48dp\" android:layout_height=\"48dp\" android:layout_marginStart=\"12dp\" android:layout_marginTop=\"12dp\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"/&gt; &lt;/ConstraintSet&gt; &lt;!-- Constraints to apply at the end of the animation --&gt; &lt;ConstraintSet android:id=\"@+id/end\"&gt; &lt;Constraint android:id=\"@+id/ball\" android:layout_width=\"48dp\" android:layout_height=\"48dp\" android:layout_marginEnd=\"12dp\" android:layout_marginBottom=\"12dp\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\"/&gt; &lt;/ConstraintSet&gt;&lt;/MotionScene&gt; 首先，可以发现我们定义了两个 &lt;ConstraintSet&gt;*，分别描述了这个🏀 ImageView 的动画起始位置以及结束位置的约束信息（仅包含少量必要信息，如：width、height、margin以及位置属性等）。显而易见，篮球的起始位置为屏幕左上角，结束位置为屏幕右下角，那么问题来了，如何让它动起来呢？这就要依靠我们的 *&lt;Transition&gt; 元素了。事实上，我们都知道，动画都是有开始位置和结束位置的，而 MotionLayout 正是利用这一客观事实，将首尾位置和动画过程分离，两个点位置和距离虽然是固定的，但是它们之间的 Path 是无限的，可以是“一马平川”，也可以是”蜿蜒曲折”的。 回到上面这个例子，我们只需要为 Transition 设置起始位置和结束位置的 ConstraintSet 并设置动画时间即可，剩下的都交给 MotionLayout 自动去帮我们完成。当然你也可以通过 onClick 点击事件来触发动画，绑定目标控件的 id 以及通过 clickAction 属性来设置点击事件的类型，这里我们设置的是 toggle，即通过反复点击控件来切换动画的状态，其他还有很多属性可以参照官方文档去研究，比较简单，这里就不一一讲解它们的效果了。如此一来，运行一下就能看到上面的效果了。另外，为了方便测试，我们可以给 MotionLayout 加上调试属性：*app:motionDebug=&quot;SHOW_PATH&quot;*，然后就能轻易的查看其动画内部的运动轨迹： 什么？你说这个动画效果太基础？那好，我就来个简陋版的“百花齐放”效果吧，比如下面这样： 首先，让我们分析一下这个效果：仔细看我们可以发现，通过向上滑动蓝色的 Android 机器人，紫色和橙色的机器人会慢慢淡出并分别忘左上角和右上角移动。布局文件很简单，一把梭就OK了😂： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.motion.MotionLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:motionDebug=\"SHOW_PATH\" app:layoutDescription=\"@xml/step2\" tools:context=\".practice.MotionSampleActivity\"&gt; &lt;ImageView android:id=\"@+id/ic_android_blue\" android:layout_width=\"42dp\" android:layout_height=\"42dp\" android:src=\"@mipmap/android_icon_blue\"/&gt; &lt;ImageView android:id=\"@+id/ic_android_left\" android:layout_width=\"42dp\" android:layout_height=\"42dp\" android:src=\"@mipmap/android_icon_purple\"/&gt; &lt;ImageView android:id=\"@+id/ic_android_right\" android:layout_width=\"42dp\" android:layout_height=\"42dp\" android:src=\"@mipmap/android_icon_orange\"/&gt; &lt;TextView android:id=\"@+id/tipText\" android:text=\"Swipe the blue android icon up\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:layout_constraintEnd_toEndOf=\"parent\" android:layout_marginEnd=\"16dp\" android:layout_marginTop=\"16dp\" app:layout_constraintTop_toTopOf=\"parent\"/&gt;&lt;/android.support.constraint.motion.MotionLayout&gt; 下面我们来看下 step2 中的 MotionScene： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!--describe the animation for activity_motion_sample_step2.xml--&gt;&lt;!--animate by dragging target view--&gt;&lt;MotionScene xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;!--At the start, all three stars are centered at the bottom of the screen.--&gt; &lt;ConstraintSet android:id=\"@+id/start\"&gt; &lt;Constraint android:id=\"@+id/ic_android_blue\" android:layout_width=\"42dp\" android:layout_height=\"42dp\" android:layout_marginBottom=\"20dp\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\"/&gt; &lt;Constraint android:id=\"@+id/ic_android_left\" android:layout_width=\"42dp\" android:layout_height=\"42dp\" android:alpha=\"0.0\" android:layout_marginBottom=\"20dp\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\"/&gt; &lt;Constraint android:id=\"@+id/ic_android_right\" android:layout_width=\"42dp\" android:layout_height=\"42dp\" android:layout_marginBottom=\"20dp\" android:alpha=\"0.0\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\"/&gt; &lt;/ConstraintSet&gt; &lt;!--Define the end constraint to set use a chain to position all three stars together below @id/tipText.--&gt; &lt;ConstraintSet android:id=\"@+id/end\"&gt; &lt;Constraint android:id=\"@+id/ic_android_left\" android:layout_width=\"58dp\" android:layout_height=\"58dp\" android:layout_marginEnd=\"90dp\" android:alpha=\"1.0\" app:layout_constraintHorizontal_chainStyle=\"packed\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintEnd_toStartOf=\"@id/ic_android_blue\" app:layout_constraintTop_toBottomOf=\"@id/tipText\"/&gt; &lt;Constraint android:id=\"@+id/ic_android_blue\" android:layout_width=\"58dp\" android:layout_height=\"58dp\" app:layout_constraintEnd_toStartOf=\"@id/ic_android_right\" app:layout_constraintStart_toEndOf=\"@id/ic_android_left\" app:layout_constraintTop_toBottomOf=\"@id/tipText\"/&gt; &lt;Constraint android:id=\"@+id/ic_android_right\" android:layout_width=\"58dp\" android:layout_height=\"58dp\" android:layout_marginStart=\"90dp\" android:alpha=\"1.0\" app:layout_constraintStart_toEndOf=\"@id/ic_android_blue\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@id/tipText\"/&gt; &lt;/ConstraintSet&gt; &lt;!-- A transition describes an animation via start and end state --&gt; &lt;Transition app:constraintSetStart=\"@id/start\" app:constraintSetEnd=\"@id/end\"&gt; &lt;!-- MotionLayout will track swipes relative to this view --&gt; &lt;OnSwipe app:touchAnchorId=\"@id/ic_android_blue\"/&gt; &lt;/Transition&gt;&lt;/MotionScene&gt; 上面代码其实很好理解，之前我们定义了一个控件的 Constraint，现在只需要多加两个即可。由于三个 Android 机器人起点位置是一样的，而只有蓝色的显示，那么只要在开始位置将另外的两个机器人透明度设置为 0 即可，然后在结束位置将三个小机器人分开摆放，这里设计到 ConstraintLayout 的基础，就不多说了。接着将结束位置的左、右 Android 机器人透明度设置为 1，动画开始后，MotionLayout 会自动处理目标控件 alpha 属性的变化效果，让其看起来依旧丝滑。 另外，我们这里没有再通过 &lt;OnClick&gt; 来触发动画效果，类似的，我们使用了 &lt;OnSwipe&gt; 手势滑动来触发动画，只需要指定 touchAnchorId 为蓝色小机器人即可，怎么样，是不是有种“拍案惊奇”的感觉😁。此外，你可以通过指定 touchAnchorSide 和 dragDirection 等来指定自己想要的滑动手势和滑动方向，默认为向上滑动，手势滑动我们将在后面示例中穿插使用和讲解，这里不做具体介绍，忍不住的小伙伴可以去查看一下官方文档介绍。OK，就这样，我们上面的伪“百花齐放”效果就已经实现了，没什么难的对吧😄。 到这里，你可能会说：前面两个示例的动画轨迹一直是”直线”，如果想要某段动画过程的轨迹是”曲线”效果可以吗？当然没问题！Keyframes 关键帧帮你安排！ KeyFrameSet：让动画独树一帜如果我们想实现“独树一帜”的动画交互效果，那就离不开 KeyFrameSet 这个强大的属性。它可以改变我们动画过程中某个关键帧的位置以及状态信息。这样说可能不太好理解，我们先来看下面这个示例： 以大家的慧眼不难发现：风车的运动轨迹为曲线，并且旋转并放大至中间位置时会达到零界点，然后开始缩小。布局代码就不上了，很简单，里面唯一重要的就是我们需要实现的 MotionScene 效果 — step3.xml 了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!--describe the animation for activity_motion_sample_step3.xml--&gt;&lt;!--animate in the path way on a view--&gt;&lt;MotionScene xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;!-- Constraints to apply at the start of the animation --&gt; &lt;ConstraintSet android:id=\"@+id/start\"&gt; &lt;Constraint android:id=\"@id/windmill\" android:layout_width=\"40dp\" android:layout_height=\"40dp\" android:layout_marginStart=\"12dp\" android:layout_marginBottom=\"12dp\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\"/&gt; &lt;Constraint android:id=\"@id/tipText\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:alpha=\"0.0\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"@id/windmill\" app:layout_constraintTop_toTopOf=\"@id/windmill\"/&gt; &lt;/ConstraintSet&gt; &lt;!-- Constraints to apply at the end of the animation --&gt; &lt;ConstraintSet android:id=\"@+id/end\"&gt; &lt;!--this view end point should be at bottom of parent--&gt; &lt;Constraint android:id=\"@id/windmill\" android:layout_width=\"40dp\" android:layout_height=\"40dp\" android:layout_marginBottom=\"12dp\" android:layout_marginEnd=\"12dp\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\"/&gt; &lt;Constraint android:id=\"@+id/tipText\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"12dp\" android:alpha=\"1.0\" android:layout_marginEnd=\"72dp\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\"/&gt; &lt;/ConstraintSet&gt; &lt;!-- A transition describes an animation via start and end state --&gt; &lt;Transition app:constraintSetStart=\"@id/start\" app:constraintSetEnd=\"@id/end\"&gt; &lt;KeyFrameSet&gt; &lt;KeyPosition app:framePosition=\"50\" app:motionTarget=\"@id/windmill\" app:keyPositionType=\"parentRelative\" app:percentY=\"0.5\"/&gt; &lt;!--apply other animation attributes--&gt; &lt;!--前半段的动画效果：逆时针旋转一圈，同时放大一倍--&gt; &lt;KeyAttribute app:motionTarget=\"@id/windmill\" android:rotation=\"-360\" android:scaleX=\"2.0\" android:scaleY=\"2.0\" app:framePosition=\"50\"/&gt; &lt;!--后半段的动画效果：逆时针旋转一圈，同时变回原样--&gt; &lt;KeyAttribute app:motionTarget=\"@id/windmill\" android:rotation=\"-720\" app:framePosition=\"100\"/&gt; &lt;!--延迟动画——0-85过程中将透明度一直维持在0.0--&gt; &lt;KeyAttribute app:motionTarget=\"@id/tipText\" app:framePosition=\"85\" android:alpha=\"0.0\"/&gt; &lt;/KeyFrameSet&gt; &lt;OnSwipe app:touchAnchorId=\"@id/windmill\" app:touchAnchorSide=\"bottom\" app:dragDirection=\"dragRight\"/&gt; &lt;/Transition&gt;&lt;/MotionScene&gt; 从上述代码我们可以发现：KeyFrameSet 需要被包含在 Transition 里面，同时 KeyFrameSet 中定义了 &lt;KeyPosition&gt; 和 &lt;KeyAttribute&gt; 两种元素，它们主要用来设置动画某个位置的关键帧，进而为某段动画指定所期望的效果。顾名思义，KeyPosition 用于指定动画某个关键帧的位置信息，而 KeyAttribute 则用来描述动画某关键帧的属性配置（如：透明度、缩放、旋转等）。除此以外，KeyFrameSet 中还支持 &lt;KeyCycle&gt; 和 &lt;KeyTimeCycle&gt; 来让动画变得更加有趣和灵活，因篇幅有限，将在后续文章对二者进行讲解。 我们先来看下 KeyPosition 的构成： 从上图可见，keyPositionType 一共有三种，本文使用的是 parentRelative，即以整个 MotionLayout 的布局为坐标系，左上角为坐标原点，即参考 View 的坐标系即可，而另外两种将在后续文章统一讲解和应用，它们的区别在于坐标系选取的参考点不同而已。我们通过 framePosition 属性来指定关键帧所在的位置，取值范围为 0 - 100，本示例中设置的 50 即为动画中点位置。另外，可以通过指定 percentX 和 percentY 来设置该关键帧位置的偏移量，它们取值一般为 0 — 1，当然也可以设置为负数或者大于一，比如，本示例中如果没有设置偏移量，那么动画的轨迹无疑是一条平行于 x 轴的直线，但通过设置 app:percentY=&quot;0.5&quot;，那么风车就会在动画中点位置向 y 轴方向偏移一半的高度，即下图的效果（开始 debug 模式）： 可能会有人问了：为什么轨迹不是三角形，而是曲线呢？哈哈，这个问题问得好！因为 MotionLayout 会自动地将关键帧位置尽量衔接的圆滑，让动画执行起来不那么僵硬。其他代码应该就比较好理解了，可以参照文档理解。 了解完 KeyFrameSet 的用法，那么我们就很轻易的实现下面这个效果啦： 代码就不贴了，MotionLayout 系列代码都会上传至 GitHub 上，感兴趣的小伙伴可以去看一下。不知不觉已经讲了这么多，但发现还有很多内容没有涉及到或是讲清楚，由于篇幅有限，就只能放在后面几期来为大家介绍啦😄。如果大家觉得对本文有什么问题或者建议，欢迎评论区留言，知无不言，言无不尽。 本文全部代码：https://github.com/Moosphan/ConstraintSample 后续文章将继续跟进相关进阶用法，该仓库也将持续更新，敬请期待~ 参考和感谢： Introduction to MotionLayout (part I) Introduction to MotionLayout (part II) Introduction to MotionLayout (part III) Defining motion paths in MotionLayout MotionLayout development 最后 本文的出发点是希望仅仅为大家提供一个“钥匙孔”的角色，通过这个“孔”，大家可以依稀看见门里“宝藏”的余光，想要打开门寻得宝藏，就需要大家”事必躬亲”，拿到“钥匙”来打开这扇门了😄。当然，大家也可以继续关注我的后续之作，来发现更多 MotionLayout 的宝藏。","link":"/2019/10/19/motionlayout-part1/"},{"title":"Android中的 MVP：如何使 Presenter 层系统化？","text":"原文地址：MVP for Android: how to organize the presentation layer 原文作者：Antonio Leiva MVP（Model View Presenter）模式是著名的 MVC（Model View Controller）的衍生物，并且是 Android 应用程序中管理表示层的最流行的模式之一。 这篇文章首次发表于 2014 年 4 月，从那以后就一直备受欢迎。所以我决定更新它来解决人们心中的大部分疑虑，并将代码转换为 Kotlin 语言形式。 自那时起，架构模式发生了重大变化，例如带有架构组件的 MVVM，但 MVP 仍然有效并且是一个值得考虑的选择。 什么是 MVP 模式？MVP 模式将 Presenter 层从逻辑中分离出来，这样一来，就把所有关于 UI 如何工作与我们在屏幕上如何表示它分离了开来。理想情况下，MVP 模式将实现相同的逻辑可能具有完全不同且可交替的界面。 要明确的第一件事是 MVP 本身不是一个架构，它只负责表示层。这是一个有争议的说法，所以我想更深入地解释一下。 你可能会发现 MVP 被定义为架构模式，因为它可以成为你的应用程序架构的一部分。但你不应当这样认为，因为去掉 MVP 之后，你的架构依旧是完整的。MVP 仅仅塑造表示层，但如果你需要灵活且可扩展的应用程序，那么其余层仍需要良好的体系架构。 完整架构体系的一个示例可以是 Clean Architecture，但还有许多其他选择。 在任何情况下，在你从未使用 MVP 的架构中去使用它总是件好事。 为什么要使用 MVP？在 Android 开发中，我们遇到一个严峻的问题：Activity 高度耦合了用户界面和数据存取机制。我们可以找到像 CursorAdapter 这样的极端例子，它将作为视图层一部分的 Adapter 和 属于数据访问层级的 Cursor 混合到了一起。 为了能够轻松地扩展和维护一个应用，我们需要使用可以相互分离的体系架构。如果我们不再从数据库获取数据，而是从 web 服务器获取，那么我接下来该怎么办呢？我们可能就要重新编写整个视图层了。 MVP 使视图独立于我们的数据源而存在。我们需要将应用程序划分为至少三个不同的层次，以便我们可以独立地测试它们。通过 MVP，我们可以将大部分有关业务逻辑的处理从 Activity 中移除，以便我们可以在不使用 Instrumentation Test 的情况下对其进行测试。 如何实现 Android 当中的 MVP？好吧，这就是它开始产生分歧的地方。MVP 有很多变种，每个人都可以根据自己的需求和自己感觉更加舒适的方式来调整模式。这主要取决于我们委托给 Presenter 的任务数量。 到底是该由 View 层来负责启用或禁用一个进度条，还是该由 Presenter 来负责呢？又该由谁来决定 Action Bar 应该做出什么行为呢？这就是艰难决定的开始。我将展示我通常情况下是如何处理这种情况的，但我希望这篇文章更是一个适合讨论的地方，而不是严格的约束 MVP 该如何应用，因为根本没有“标准”的方式来实现它。 对于本文，我已经实现了一个非常简单的示例，你可以在我的 Github 找到 一个登录页面和主页面。为了简单起见，本文中的代码是使用 Kotlin 实现的，但你也可以在仓库中查看使用 Java 8 编写的代码。 Model 层在具有完整分层体系结构的应用程序中，这里的 Model 仅仅是通往领域层或业务逻辑层的大门。如果我们使用 鲍勃大叔的 clean architecture 架构，这里的 Model 可能是一个实现了一个用例的 Interactor（交互器）。但就本文而言，将 Model 看做是一个给 View 层显示数据的提供者就足够了。 如果你检查代码，你将看到我创建了两个带有人为延迟操作的 Interactor 来模拟对服务器的请求情况。其中一个 Interactor 的结构： 123456789101112131415class LoginInteractor { ... fun login(username: String, password: String, listener: OnLoginFinishedListener) { // Mock login. I'm creating a handler to delay the answer a couple of seconds postDelayed(2000) { when { username.isEmpty() -&gt; listener.onUsernameError() password.isEmpty() -&gt; listener.onPasswordError() else -&gt; listener.onSuccess() } } }} 这是一个简单的方法，它接收用户名和密码，并进行一些验证操作。 View 层View 层通常是由一个 Activity（也可以是一个 Fragment，一个 View，这取决于 App 的结构），它包含了一个对 Presenter 的引用。理想情况下，Presenter 是通过依赖注入的方式提供的（比如 Dagger），但如果你没有使用这类工具，也可以直接创建一个 Presenter 对象。View 需要做的唯一一件事就是：当有用户操作发生时（比如一个按钮被点击了），就调用 Presenter 中的相应方法。 由于 View 必须与 Presenter 层无关，因此它就需要实现一个接口。下面是示例中使用到的接口： 1234567interface LoginView { fun showProgress() fun hideProgress() fun setUsernameError() fun setPasswordError() fun navigateToHome()} 接口中有一些有效的方法来显示或隐藏进度条，显示错误信息，跳转到下一个页面等等。正如上面所提到的，有很多方式去实现这些功能，但我更喜欢罗列出最简单直观的方法。 然后，Activity 可以实现这些方法。这里我向你展示了一些用法，以便你对其用法有所了解： 123456789101112131415class LoginActivity : AppCompatActivity(), LoginView { ... override fun showProgress() { progress.visibility = View.VISIBLE } override fun hideProgress() { progress.visibility = View.GONE } override fun setUsernameError() { username.error = getString(R.string.username_error) }} 但是如果你还记得，我还告诉过你，View 层使用 Presenter 来通知用户交互操作。下面就是它的用法： 123456789101112131415161718192021class LoginActivity : AppCompatActivity(), LoginView { private val presenter = LoginPresenter(this, LoginInteractor()) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_login) button.setOnClickListener { validateCredentials() } } private fun validateCredentials() { presenter.validateCredentials(username.text.toString(), password.text.toString()) } override fun onDestroy() { presenter.onDestroy() super.onDestroy() } ...} Presenter 被定义为 Activity 的属性，当点击按钮时，它会调用 validateCredentials()方法，该方法将会通知 Presenter。 onDestroy() 方法亦是如此。我们稍后将会看到为什么在这种情况下需要通知 Presenter。 Presenter 层Presenter 充当着 View 层和 Model 层的中间人。它从 Model 层获取收据并将格式化后数据返回给 View 层。 此外，与典型的 MVC 模式不同的是，Presenter 决定了当你在与 View 层交互时会做何响应。因此，它将为用户每个可执行的操作提供一种方法。我们在 View 层中看到了它，这里是代码实现： 123456789class LoginPresenter(var loginView: LoginView?, val loginInteractor: LoginInteractor) : LoginInteractor.OnLoginFinishedListener { fun validateCredentials(username: String, password: String) { loginView?.showProgress() loginInteractor.login(username, password, this) } ...} MVP 模式存在一些风险，常常被我们忽略的最重要的问题是 Presenter 永远依附在 View 上面。并且 View 层一般为 Activity，这就意味着： 我们可能会由于长时间的运行的任务而导致 Activity 的泄漏 我们可能会在 Activity 已经被销毁的情况下去更新视图 首先，倘若你能够保证能够在合理的时间内完成你的后台任务，我将不会过于担心。将你的 Activity 泄漏 5-10 秒会让你的 App 变得很糟糕，并且解决方案通常很复杂。 第二点反而更让人担心。想象一下，你花费 10 秒钟时间向服务器发送一个请求，但用户却在 5 秒钟后关闭了 Activity。当回调方法正在被调用并且 UI 被更新时，App 将会崩溃，因为 Activity 正在销毁中。 为了解决这个问题，我们可以在 Activity 中调用 onDestroy() 方法并清除 View： 123fun onDestroy() { loginView = null} 这样我们就可以避免在任务结束时间与活动销毁时间不一致的情况下调用 Activity 了。 总结在 Android 中将用户界面层与逻辑层分离并不简单，但 MVP 模式可以更加轻易地防止我们的 Activity 最终沦为高度耦合的、包含了成百上千行代码的类。在大型应用开发过程中，将代码管理好是很有必要的。否则，对代码的维护和扩展都会变得很困难。 如今，还有其他的代替方案比如 MVVM，我将会创作新的文章来对 MVVM 和 MVP 做比较，并帮助开发者迁移。所以请继续关注我的博客！ 请记住 这个仓库，你可以在这查看 MVP 在 Kotlin 和 Java 中的代码示例。 如果你想要了解更多关于 Kotlin 方面的内容，可以查看我的 Kotlin for Android Developers 这本书 中的 sample 应用，或者观看 在线课程。 如果发现译文存在错误或其他需要改进的地方，欢迎到 掘金翻译计划 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 本文永久链接 即为本文在 GitHub 上的 MarkDown 链接。","link":"/2018/12/24/mvp-presenter/"},{"title":"Android项目中调起手机地图导航","text":"现在,移动应用中集成地图已经成为一种趋势。导航 - 作为地图中不可或缺的一项功能,被很多移动应用所青睐,然而,导航方式选择上,为了减少不必要的资源和apk容量,一般应用都选择通过调用第三方的地图应用来实现导航功能。在介绍之前,先看一下最终效果:本文主要提供几种常用的调起三方地图应用的导航平台,以高德,百度,腾讯,谷歌地图为例。 地图平台 Uri文档 高德地图 http://lbs.amap.com/api/uri-api/guide/travel/route 百度地图 http://lbsyun.baidu.com/index.php?title=uri/api/android 谷歌地图 https://developers.google.com/maps/documentation/android-api/intents 腾讯地图 http://lbs.qq.com/uri_v1/guide-route.html 各大地图服务商基本都提供了Uri,方便其他应用调用(除了腾讯),uri网址如上所示. 基本看了以上的文档就会使用了,下面就提供几个平台的基本写法吧: 高德地图导航: 高德地图较为特殊,其他地图平台都可以选择传入地址或者经纬度作为参数,而高德要求必须有经纬度。没办法,那就先撸个地理编码的轮子吧,方便我们将地址信息转化为准确的经纬度坐标,具体看下面代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * by moos on 2017/09/18 * func:调用高德地图的地理编码接口,返回经纬度坐标 * @param address */ private void translateAddressToLocation(String address){ OkHttpUtils .get() .url(GEOCODE_HTTP_URL + &quot;address=&quot;+address+&quot;&amp;key=&quot;+SELF_AMAP_KEY) .build() .execute(new StringCallback() { @Override public void onError(Call call, Exception e, int id) { Log.e(&quot;地理编码失败=&quot;, e.getMessage()); //DialogUtils.dismissProgressDialog(); Toast.makeText(UnityScanActivity.this, getString(R.string.act_qr_code_fail), Toast.LENGTH_LONG).show(); } @Override public void onResponse(String response, int id) { Logger.e(&quot;地理编码结果 =&quot; + response); resultBean = JSONObject.parseObject(response, GeocodeResultBean.class); if (resultBean.getStatus().equals(&quot;1&quot;)) { locationList = resultBean.getGeocodes(); if(locationList!=null &amp;&amp; locationList.size()&gt;0){ //默认获取第一条 locationString = locationList.get(0).getLocation(); lon = locationString.substring(0,locationString.indexOf(&quot;,&quot;)); lat = locationString.substring(locationString.indexOf(&quot;,&quot;)+1,locationString.length()); Log.e(&quot;经纬度信息为===&quot;,lon+&quot;=======&quot;+lat); }else { Toast.makeText(UnityScanActivity.this, &quot;无相关信息&quot;, Toast.LENGTH_LONG).show(); } } else { Toast.makeText(UnityScanActivity.this, resultBean.getInfo(), Toast.LENGTH_LONG).show(); } } }); } &emsp;&emsp;这里我并没有采用高德包中的地理编码接口来实现,而是调用的其web接口。请原谅我的任性,最近接口调上瘾了😆,值得注意的是,url中需要传入key,这个要在高德官网自己创建web应用申请,不过很方便,不需要包名和sha1等。 下面看看如何调起手机中的高德地图吧: 123456789101112131415161718192021222324252627282930313233343536373839404142//调起导航的uri private final String BAIDU_MAP_NAVI_URI = &quot;baidumap://map/navi?query=&quot;; private final String GAODE_MAP_NAVI_URI = &quot;androidamap://navi?sourceApplication=&quot;; private final String GOOGLE_MAP_NAVI_URI = &quot;google.navigation:q=&quot;; //map app包名 private final String BAIDU_MAP_APP = &quot;com.baidu.BaiduMap&quot;; private final String GAODE_MAP_APP = &quot;com.autonavi.minimap&quot;; private final String GOOGLE_MAP_APP = &quot;com.google.android.apps.maps&quot;; private final String QQ_MAP_URL = &quot;http://apis.map.qq.com/uri/v1/routeplan?type=drive&amp;&quot;; //高德web服务的临时key(用于地理编码) private final String SELF_AMAP_KEY = &quot;your key&quot;; private final String GEOCODE_HTTP_URL = &quot;http://restapi.amap.com/v3/geocode/geo?&quot;; private GeocodeResultBean resultBean; private List&lt;GeocodeResultBean.GeocodeBean&gt; locationList; private String locationString; private String lon; private String lat;/** * by moos on 2017/09/18 * func:调起高德导航 * @param lat 纬度 * @param lon 经度 * @param dev 是否偏移(0:lat 和 lon 是已经加密后的,不需要国测加密; 1:需要国测加密) * @param style 导航方式(0 速度快; 1 费用少; 2 路程短; 3 不走高速；4 躲避拥堵；5 不走高速且避免收费；6 不走高速且躲避拥堵；7 躲避收费和拥堵；8 不走高速躲避收费和拥堵) */ private void goNaviByGaoDeMap(String lat,String lon,String dev,String style){ Intent intent = new Intent(); intent.setAction(Intent.ACTION_VIEW); intent.addCategory(Intent.CATEGORY_DEFAULT); //将功能Scheme以URI的方式传入data Uri uri = Uri.parse(GAODE_MAP_NAVI_URI + &quot;Test&quot; + &quot;&amp;lat=&quot; + lat + &quot;&amp;lon=&quot; + lon + &quot;&amp;dev=&quot; + dev + &quot;&amp;style=&quot; +style); intent.setData(uri); intent.setPackage(&quot;com.autonavi.minimap&quot;); startActivity(intent); } 注释比较详细了,就不做具体讲解了,可以参考官方提供的文档。 百度地图导航: 1234567891011/** * by moos on 2017/09/18 * func:调起百度导航 */ private void goNaviByBaiDuMap(String address){ Intent intent = new Intent(); intent.setData(Uri.parse(BAIDU_MAP_NAVI_URI + address)); startActivity(intent); } 谷歌地图导航: 12345678910111213/** * by moos on 2017/09/18 * func:调起谷歌导航 * @param lat * @param lon */ private void goNaviByGoogleMap(String lat,String lon,String address){ Uri uri = Uri.parse(GOOGLE_MAP_NAVI_URI+lat+&quot;,&quot;+lon +&quot;,&quot; + address); Intent mapIntent = new Intent(Intent.ACTION_VIEW, uri); mapIntent.setPackage(&quot;com.google.android.apps.maps&quot;); context.startActivity(mapIntent); } 腾讯地图导航:&emsp;&emsp;刚刚说过,腾讯地图目前还未支持其他应用以uri形式调起腾讯自家的地图功能,不过我们可以通过web 接口方式调用,具体代码如下,比较简单: 1234567891011121314/** * by moos on 2017/09/18 * func:通过网页形式调起腾讯地图 * @param startPoint * @param endPoint * @param policy 规划策略(0:快捷,1:无高速,2:距离短) * @param appName 当前应用的名称 */ private void goNaviByTencentMap(String startPoint,String endPoint,String policy,String appName){ Uri uri = Uri.parse(QQ_MAP_URL + &quot;from=&quot;+startPoint + &quot;&amp;to=&quot; +endPoint + &quot;&amp;policy=&quot;+policy + &quot;&amp;referer=&quot;+appName ); Intent intent = new Intent(Intent.ACTION_VIEW,uri); startActivity(intent); } 我们只需要在url中传入参数,然后访问该网址就可以,很简单吧😆。 其他:&emsp;&emsp;为了更好的用户体验,我们会加上一些提醒用户的交互,如:用户手机没有安装地图应用,可以弹窗让用户前往商店下载,来吧,一大波代码来袭: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * by moos on 2017/09/18 * func:接受导航请求,并发起导航 */ private void navigateForDestination(){ if(isApplicationInstall(GAODE_MAP_APP)){ //安装了高德map Log.e(&quot;Tminstore&quot;,&quot;已安装高德地图&quot;); translateAddressToLocation(&quot;东方明珠&quot;);//地理编码 goNaviByGaoDeMap(lat,lon,&quot;1&quot;,&quot;2&quot;); //goNaviByTencentMap(MyApplication.mapLocation.getAddress(),&quot;上海东方明珠&quot;,&quot;0&quot;,&quot;com.ucardstore.Activity&quot;); }else if(isApplicationInstall(BAIDU_MAP_APP)){ //安装了百度map Log.e(&quot;Tminstore&quot;,&quot;已安装百度地图&quot;); goNaviByBaiDuMap(&quot;上海东方明珠&quot;); }else if(isApplicationInstall(GOOGLE_MAP_APP)){ //安装了google map Log.e(&quot;Tminstore&quot;,&quot;已安装谷歌地图&quot;); goNaviByGoogleMap(&quot;&quot;,&quot;&quot;,&quot;上海东方明珠&quot;); }else { //默认安装高德app showInstallAppTip(); //使用腾讯网页地图(可选) //goNaviByTencentMap(MyApplication.mapLocation.getAddress(),&quot;上海东方明珠&quot;,&quot;0&quot;,&quot;com.ucardstore.Activity&quot;); } } ..... /** * by moos on 2017/09/18 * func:判断手机是否安装了该应用 * @param packageName * @return */ private boolean isApplicationInstall(String packageName){ return new File(&quot;/data/data/&quot; + packageName).exists(); } ...... /** * by moos on 2017/09/18 * func:安装地图app的提示 */ private void showInstallAppTip(){ TipDialog dialog = new TipDialog(this, new View.OnClickListener() { @Override public void onClick(View arg0) { switch (arg0.getId()) { case R.id.dialog_btn_sure: Intent intent ; Uri uri = Uri.parse(&quot;market://details?id=com.autonavi.minimap&quot;); intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); break; case R.id.dialog_btn_cancel: break; } } }); dialog.setMessage(getString(R.string.install_app_tip)); dialog.setBtnSure(getString(R.string.go_to_install)); dialog.setBtnCancel(getString(R.string.cancel)); dialog.show(); } 好了,这差不多就是全部代码了,至于弹窗TipDialog是我自定义的dialog,没什么难度,就不贴出来😝。","link":"/2017/09/19/amap-guide/"},{"title":"Android基于高德地图实现搜索框的自动输入提示功能","text":"最近公司项目中一直在搞地图开发,今天产品经理就给我布置了一些(无法想象)任务,其中一个就是实现地点搜索输入框的自动输入提示功能。拿到任务肯定想讨价还价一番,但是想到以前也写过,就不再负隅顽抗了。 以前在学校的时候实现过类似功能,是使用高德自带的InputtipsListener来实现的,想了解可以看看:文章传送点,这里就不详细介绍了。作为一名头脑发热的开发者,肯定不能安于现状,这里主要介绍其他两种方式 - poi实现和http请求接口实现,不管能不能成功,试了再说,撸起袖子就是干。先看看最终的效果: 做之前先分析一下功能需求,首先输入框中要添加内容清除的icon,当输入框有文字时,需要显示,为空时隐藏;接着,需要实现地址搜索功能并通过listview展示结果;最后需要实现展示搜索历史的功能。好的,那么下面我们来一步步实现。 其实,实现效果中的输入框并不难,只需要三个东西就够了:LinearLayout,EditText,ImageView。直接上代码吧,上了代码你就知道它到底有多简单了: 123456789101112131415161718192021222324252627282930313233&lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;36dp&quot; android:layout_weight=&quot;1&quot; android:layout_marginLeft=&quot;20dp&quot; android:background=&quot;@drawable/search_view_bg&quot; android:orientation=&quot;horizontal&quot; android:gravity=&quot;center_vertical&quot;&gt; &lt;EditText android:id=&quot;@+id/search_edit_text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;36dp&quot; android:hint=&quot;@string/input_cross_location&quot; android:textColorHint=&quot;#9B9B9B&quot; android:textSize=&quot;12sp&quot; android:maxLines=&quot;1&quot; android:layout_weight=&quot;1&quot; android:paddingBottom=&quot;10dp&quot; android:paddingTop=&quot;10dp&quot; android:paddingLeft=&quot;10dp&quot; android:background=&quot;@drawable/search_edit_bg&quot; android:drawableLeft=&quot;@mipmap/icon_edit_search&quot; android:drawablePadding=&quot;16dp&quot;/&gt; &lt;ImageView android:id=&quot;@+id/search_edit_delete&quot; android:layout_width=&quot;12dp&quot; android:layout_height=&quot;12dp&quot; android:layout_marginLeft=&quot;5dp&quot; android:layout_marginRight=&quot;8dp&quot; android:visibility=&quot;gone&quot; android:src=&quot;@mipmap/iocn_search_cancel&quot;/&gt; &lt;/LinearLayout&gt; 没错,这里为EditText父容器LinearLayout设置背景,然后EditText设置同样的背景,只不过需要将右边的圆角效果去掉,达到预期效果。也即是说,我们的输入框相当于是LinearLayout,里面包含了edittext和删除图标imageview,来看看drawable的代码吧: search_view_bg: 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_window_focused=&quot;false&quot;&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!--&lt;solid android:color=&quot;#F4F4F4&quot; /&gt;--&gt; &lt;corners android:radius=&quot;3dp&quot;/&gt; &lt;solid android:color=&quot;#F3F3F3&quot;/&gt; &lt;!--&lt;stroke android:color=&quot;#ffececec&quot; android:width=&quot;1dp&quot;/&gt;--&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:state_window_focused=&quot;true&quot;&gt; &lt;shape&gt; &lt;corners android:radius=&quot;3dp&quot;/&gt; &lt;!--&lt;stroke android:color=&quot;#ececec&quot; android:width=&quot;1dp&quot; /&gt;--&gt; &lt;solid android:color=&quot;#F3F3F3&quot;/&gt; &lt;!--&lt;solid android:color=&quot;#F4F4F4&quot; /&gt;--&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/selector&gt; search_edit_bg: 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_window_focused=&quot;false&quot;&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!--&lt;solid android:color=&quot;#F4F4F4&quot; /&gt;--&gt; &lt;corners android:topLeftRadius=&quot;3dp&quot; android:bottomLeftRadius=&quot;3dp&quot;/&gt; &lt;solid android:color=&quot;#F3F3F3&quot;/&gt; &lt;!--&lt;stroke android:color=&quot;#ffececec&quot; android:width=&quot;1dp&quot;/&gt;--&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:state_window_focused=&quot;true&quot;&gt; &lt;shape&gt; &lt;corners android:topLeftRadius=&quot;3dp&quot; android:bottomLeftRadius=&quot;3dp&quot;/&gt; &lt;!--&lt;stroke android:color=&quot;#ececec&quot; android:width=&quot;1dp&quot; /&gt;--&gt; &lt;solid android:color=&quot;#F3F3F3&quot;/&gt; &lt;!--&lt;solid android:color=&quot;#F4F4F4&quot; /&gt;--&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/selector&gt; ok,这就实现了最终的输入框UI,当然,你可以使用其他方式实现,比如自定义view,第三方开源等等,但我觉得这完全满足我们的需求,而且简单,不是吗?接下来,我们需要通过监听EditText的变化来实现搜索框中删除的变化,代码如下: 12345678910111213141516171819202122232425262728293031323334@Bind(R.id.search_edit_text)EditText inputText;@Bind(R.id.search_edit_delete)ImageView buttonDelete;......buttonDelete.setOnClickListener(this);inputText.addTextChangedListener(this); ......@Overridepublic void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {}@Overridepublic void onTextChanged(CharSequence charSequence, int i, int i1, int i2) { if(charSequence!=null){ buttonDelete.setVisibility(View.VISIBLE); }else { buttonDelete.setVisibility(View.GONE); }}@Overridepublic void afterTextChanged(Editable editable) {} 代码比较简单,就不解释了,不理解这个方法的可以谷歌一下,我们接着往下看。 用过高德地图api的开发者应该都知道里面有个常用的功能:POI搜索.高德提供了千万级别的 POI（Point of Interest，兴趣点）。在地图表达中，一个 POI 可代表一栋大厦、一家商铺、一处景点等等。通过POI搜索，完成找餐馆、找景点、找厕所等等的功能。如果我们的需求是获取周围兴趣点,那么搜索输入提示只要显示兴趣点就可以了。 下面我们来依次通过两种方法来实现快捷输入提示功能: POI搜索实现: 话不多说,直接上代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//方法一:使用poi搜索接口方法 private PoiResult poiResult; // poi返回的结果 private int currentPage = 0;// 当前页面，从0开始计数 private PoiSearch.Query query;// Poi查询条件类 private LatLonPoint latLonPoint; private PoiSearch poiSearch; private List&lt;PoiItem&gt; poiItems;// poi数据 private String keyWord; private CommonAdapter adapter; private final int ADDRESS_LOCATION_GET = 3242; private String POI_SEARCH_TYPE = &quot;汽车服务|汽车销售|&quot; + &quot;//汽车维修|摩托车服务|餐饮服务|购物服务|生活服务|体育休闲服务|医疗保健服务|&quot; + &quot;//住宿服务|风景名胜|商务住宅|政府机构及社会团体|科教文化服务|交通设施服务|&quot; + &quot;//金融保险服务|公司企业|道路附属设施|地名地址信息|公共设施&quot;; ...... /** * 开始进行poi搜索 */ protected void doSearchQuery() { latLonPoint = new LatLonPoint(MyApplication.mapLocation.getLatitude(), MyApplication.mapLocation.getLongitude());// 116.472995,39.993743 keyWord = inputText.getText().toString().trim(); currentPage = 0; //keyWord表示搜索字符串， //第二个参数表示POI搜索类型，二者选填其一，选用POI搜索类型时建议填写类型代码，码表可以参考下方（而非文字） //cityCode表示POI搜索区域，可以是城市编码也可以是城市名称，也可以传空字符串，空字符串代表全国在全国范围内进行搜索 query = new PoiSearch.Query(keyWord, POI_SEARCH_TYPE, &quot;&quot;); query.setPageSize(30);// 设置每页最多返回多少条poiItem query.setPageNum(currentPage);// 设置查第一页 if (latLonPoint != null) { poiSearch = new PoiSearch(this, query); poiSearch.setOnPoiSearchListener(this); poiSearch.setBound(new PoiSearch.SearchBound(latLonPoint, 3000, true));//设置搜索范围 poiSearch.searchPOIAsyn();// 异步搜索 } } ...... @Override public void onPoiSearched(PoiResult result, int code) { //DialogUtils.dismissProgressDialog(); if (code == AMapException.CODE_AMAP_SUCCESS) { if (result != null &amp;&amp; result.getQuery() != null) {// 搜索poi的结果 loge(&quot;搜索的code为====&quot;+code+&quot;, result数量==&quot;+result.getPois().size()); if (result.getQuery().equals(query)) {// 是否是同一次搜索 poiResult = result; loge(&quot;搜索的code为====&quot;+code+&quot;, result数量==&quot;+poiResult.getPois().size()); List&lt;SuggestionCity&gt; suggestionCities = poiResult.getSearchSuggestionCitys();// 当搜索不到poiitem数据时，会返回含有搜索关键字的城市信息 if (poiItems != null &amp;&amp; poiItems.size() &gt; 0) { poiItems.clear(); if (adapter != null) { adapter.notifyDataSetChanged(); } } poiItems = poiResult.getPois();// 取得第一页的poiitem数据，页数从数字0开始 //通过listview显示搜索结果的操作省略 ...... } } else { loge(&quot;没有搜索结果&quot;); toast(getString(R.string.search_no_result)); empty_view.setText(getString(R.string.search_no_result)); } } else { loge(&quot;搜索出现错误&quot;); toast(getString(R.string.search_error)); empty_view.setText(getString(R.string.search_error)); } } @Override public void onPoiItemSearched(PoiItem poiItem, int i) { } 注释都比较清楚,大家理解起来应该也不难,具体用法可以参考高德官方文档,可以直接在onTextChangeed()方法中判断是否有内容来调用doSearchQuery()方法即可。 通过实时访问http接口实现:除了以上方法实现,还可以用高德提供的web端API接口实现功能,详情见高德web服务开发文档。我们可以直接通过请求高德为我们提供的搜索url接口来访问并获取数据,输入提示API服务地址为：http://restapi.amap.com/v3/assistant/inputtips?需要我们填充相应的字段,如key,keyword等,具体介绍看官方文档就可以了,大波代码来袭: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136 //方法二:使用http请求返回搜索结果 private List&lt;POISearchResultBean.Tips&gt; tipsList; private POISearchResultBean resultBean; private String locationString; private String lon; private String lat; private final int SEARCH_OK = 3266; @Bind(R.id.search_result_listview) ListView resultListView; ....... private MapSerchActivity.MyWeakReferenceHandler handler = new MapSerchActivity.MyWeakReferenceHandler(this) { @Override public void handleMessage(Message msg, Activity weakReferenceActivity) { if (msg.what == ADDRESS_LOCATION_GET) { if (tipsList != null &amp;&amp; tipsList.size() &gt; 0) { if (adapter == null &amp;&amp; resultListView != null) { //wrong resultListView.setAdapter(adapter = new CommonAdapter&lt;POISearchResultBean.Tips&gt;(SearchAddressActivity.this, tipsList, R.layout.search_result_item) { @Override public void convert(ViewHolder helper, final POISearchResultBean.Tips item) { helper.setText(R.id.search_result_item_address_name, item.getName()); helper.setText(R.id.search_result_item_address_detail, item.getDistrict()+item.getAddress()); helper.getView(R.id.search_result_item_address_layout).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { loge(&quot;点击了item&quot;); toast(item.getName()); boolean hasData = hasData(item.getName()); if (!hasData) { insertData(item.getName()); //queryData(&quot;&quot;); } locationString = item.getLocation(); lon = locationString.substring(0,locationString.indexOf(&quot;,&quot;)); lat = locationString.substring(locationString.indexOf(&quot;,&quot;)+1,locationString.length()); loge(&quot;经纬度信息为===&quot;+lon+&quot;,&quot;+lat); Intent intent = new Intent(); intent.putExtra(&quot;location_lon&quot;,lon); intent.putExtra(&quot;location_lat&quot;,lat); setResult(SEARCH_OK, intent); finish(); } }); } }); } else { adapter = null; resultListView.setAdapter(adapter = new CommonAdapter&lt;POISearchResultBean.Tips&gt;(SearchAddressActivity.this, tipsList, R.layout.search_result_item) { @Override public void convert(ViewHolder helper, final POISearchResultBean.Tips item) { helper.setText(R.id.search_result_item_address_name, item.getName()); helper.setText(R.id.search_result_item_address_detail, item.getDistrict()+item.getAddress()); helper.getView(R.id.search_result_item_address_layout).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) {// loge(&quot;点击了item&quot;); loge(&quot;点击了item&quot;); toast(item.getName()); boolean hasData = hasData(item.getName()); if (!hasData) { insertData(item.getName()); //queryData(&quot;&quot;); } locationString = item.getLocation(); lon = locationString.substring(0,locationString.indexOf(&quot;,&quot;)); lat = locationString.substring(locationString.indexOf(&quot;,&quot;)+1,locationString.length()); loge(&quot;经纬度信息为===&quot;+lon+&quot;=====&quot;+lat); Intent intent = new Intent(); intent.putExtra(&quot;location_lon&quot;,lon); intent.putExtra(&quot;location_lat&quot;,lat); setResult(SEARCH_OK, intent); finish(); } }); } }); } } } } }; ....... /** * by moos on 2017/09/11 * func:http请求返回关键词搜索结果 * 请求路径范例:http://restapi.amap.com/v3/assistant/inputtips?key=您的key&amp;keywords=肯德基&amp;types=050301&amp;location=116.481488,39.990464&amp;city=北京&amp;datatype=all */ private void searchAddressByHttp(String keyWord){ //DialogUtils.createProgressDialog(SearchAddressActivity.this,&quot;Searching...&quot;); OkHttpUtils .get() .url(HttpAPI.AMAP_POI_SEARCH_URL + &quot;key=&quot;+Const.amap_poi_search_key+&quot;&amp;keywords=&quot;+keyWord) .build() .execute(new StringCallback() { @Override public void onError(Call call, Exception e, int id) { loge(&quot;获取http poi搜索结果失败=&quot; + e.getMessage()); //DialogUtils.dismissProgressDialog(); Toast.makeText(SearchAddressActivity.this, getString(R.string.act_qr_code_fail), Toast.LENGTH_LONG).show(); } @Override public void onResponse(String response, int id) { Logger.e(&quot;获取http poi搜索结果 =&quot; + response); resultBean = JSONObject.parseObject(response, POISearchResultBean.class); if (resultBean.getStatus()==1) { //处理和显示搜索数据列表 if (tipsList != null &amp;&amp; tipsList.size() &gt; 0) { tipsList.clear(); if (adapter != null) { adapter.notifyDataSetChanged(); } } tipsList = resultBean.getTips(); Message message = Message.obtain(handler); message.what = ADDRESS_LOCATION_GET; handler.sendMessage(message); } else { toast(&quot;搜索失败,请重新尝试&quot;); } } }); } 通过okhttp请求网络接口有很多大神封装好的工具库,这里我使用的鸿神的okHttpUtils,大家可以根据自己的需要来选择。同时,这里使用了CommonAdapter来作为listview的适配器,同样是鸿神的杰作,如果你对它不熟悉,建议去看一下这篇文章:打造listview万能适配器。其他的就没什么难点了,关键还是靠自己研究和练习一下了。 最后,让我们来看看如何实现展示搜索历史的功能吧。先分析一下需求:首先进入到搜索界面要展示搜索历史列表,然后可以点击列表下方的清空历史来清除数据,接着,当我们搜索地名并选中时,自动存入搜索历史。其实,说到底,就是两个小功能,数据存储和数据展示,下面依次来探讨如何实现。 搜索历史数据的存储: 一般地,我们会将搜索的历史数据保存在本地。常用的两种方式分别为数据库存储和sp(SharedPreference)存储,两种方式都可以实现我们的需求,这里我才用的是数据库,有时间的话大家可以试试sp存储方式。这里不研究数据库的基本用法比较简单,就一笔带过了,直接上代码: 首先是创建数据库: 123456789101112131415161718192021222324/** * Created by moos on 17/9/11. */public class SearchHistorySQLiteHelper extends SQLiteOpenHelper { private static String name = &quot;search.db&quot;; private static Integer version = 1; public SearchHistorySQLiteHelper(Context context) { super(context, name, null, version); } @Override public void onCreate(SQLiteDatabase sqLiteDatabase) { sqLiteDatabase.execSQL(&quot;create table history(id integer primary key autoincrement,name varchar(200))&quot;); } @Override public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) { }} 具体操作: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//历史搜索功能 private SearchHistorySQLiteHelper helper = new SearchHistorySQLiteHelper(this); private SQLiteDatabase db; private BaseAdapter baseAdapter; @Bind(R.id.search_history_listview) ListView search_history_listView; @Bind(R.id.search_history_view) LinearLayout search_history_view; ...... @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_search_address); ButterKnife.bind(this); initView(); } private void initView(){ buttonCancel.setOnClickListener(this); buttonDelete.setOnClickListener(this); inputText.addTextChangedListener(this); search_history_listView.setOnItemClickListener(new AdapterView.OnItemClickListener() { @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { loge(&quot;点击了第&quot;+position+&quot;个搜索历史item&quot;); TextView textView = (TextView) view.findViewById(R.id.search_history_item_address_name); String name = textView.getText().toString(); inputText.setText(name); Toast.makeText(SearchAddressActivity.this, name, Toast.LENGTH_SHORT).show(); } }); // 第一次进入查询所有的历史记录 queryData(&quot;&quot;); } ...... //采用本地数据库存储 /** * 插入数据 */ private void insertData(String tempName) { db = helper.getWritableDatabase(); db.execSQL(&quot;insert into history(name) values('&quot; + tempName + &quot;')&quot;); db.close(); } /** * 模糊查询数据 */ private void queryData(String tempName) { Cursor cursor = helper.getReadableDatabase().rawQuery( &quot;select id as _id,name from history where name like '%&quot; + tempName + &quot;%' order by id desc &quot;, null); // 创建adapter适配器对象 baseAdapter = new SimpleCursorAdapter(this, R.layout.search_history_item, cursor, new String[] { &quot;name&quot; }, new int[] { R.id.search_history_item_address_name }, CursorAdapter.FLAG_REGISTER_CONTENT_OBSERVER); //添加footerView View footerView = LayoutInflater.from(this).inflate(R.layout.delete_search_history_bt,null); search_history_listView.addFooterView(footerView,null,false); footerView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { deleteData(); toast(&quot;清除成功&quot;); } }); // 设置适配器 search_history_listView.setAdapter(baseAdapter); baseAdapter.notifyDataSetChanged(); if(baseAdapter.getCount()==0){ //无历史搜索记录 search_history_view.setVisibility(View.GONE); } } /** * 检查数据库中是否已经有该条记录 */ private boolean hasData(String tempName) { Cursor cursor = helper.getReadableDatabase().rawQuery( &quot;select id as _id,name from history where name =?&quot;, new String[]{tempName}); //判断是否有下一个 return cursor.moveToNext(); } /** * 清空数据 */ private void deleteData() { db = helper.getWritableDatabase(); db.execSQL(&quot;delete from history&quot;); db.close(); loge(&quot;搜索历史数据删除成功&quot;); queryData(&quot;&quot;); } 数据库的操作网上很多教程和文章,这里就不多加解释,主要说一下逻辑吧。首先,我们输入关键词搜索到相应的目标地点后,点击回调中,即插入一条该地名的数据。当然,为了防止重复,我们需要判断一下数据库中是否已经存在该数据。我们刚进入搜索界面的时候,需要查询数据库中所有的数据并展示。 搜索历史数据的展示和删除: 展示的话没什么太大的问题,一般采用listview展示并为item加上点击事件就OK了,主要是要设置好展示数据和刷新数据的逻辑。这里主要提一下如何实现下方”清除搜索历史”的友好展示以及逻辑。 如果有人问你如何快速实现listview下面的button依附效果,你会怎么回答?常见的回答一般有两种: 1.在listview下面放一个button,然后外面套一层ScrollerView 2.使用listview的addFooterView()给其添加底部布局 虽然两种方式很容易想到,但是对于我们这些新手来说,动手实现起来多少有些弯弯绕绕。比如第一种方式,我们需要考虑如何处理嵌套滑动的问题,至于第二种,无非是研究listview之footerview的用法,当然,抛开各自的难点,第二种方式无非更加优雅一些,所以,这里只讨论如何使用该方式实现。首先看一下footerview的布局: search_history_item: 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_horizontal&quot;&gt; &lt;TextView android:id=&quot;@+id/item_search_history_delete&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;15dp&quot; android:gravity=&quot;center&quot; android:text=&quot;清楚搜索历史&quot; android:textSize=&quot;12sp&quot; android:layout_marginBottom=&quot;15dp&quot; android:textColor=&quot;#828282&quot;/&gt;&lt;/LinearLayout&gt; listview添加footerview比较简单,只通过简单的两行代码: 123//添加footerViewView footerView = LayoutInflater.from(this).inflate(R.layout.delete_search_history_bt,null);search_history_listView.addFooterView(footerView,null,false); 便可以实现,但是footerview的点击事件如何获取呢?很多人说直接用onItenClickListener()呀,但是,大家可以通过log或者toast看看,点击footerview是否真的响应了。答案是 - 并没有。我们应该尽量避免在onITemClickListener回调方法中实现footerview点击事件,因为position并没有变化,上限依旧是原来的adapter.getCount()。我们可以先禁止footerview在item中的点击响应,即addFooterView()方法第三个参数设为false,然后给footerView单独设置点击事件: 1234567footerView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { deleteData(); toast(&quot;清除成功&quot;); } }); 到这里,我们就完整实现了地图的搜索功能了,虽然实现的方式比较简单,但还是学到一些东西的。后面有时间会将该部分功能做个demo单独分享出来。另外大家如果有什么问题和优化建议,欢迎留言反馈,不胜感激😆。 最后,请教一下大家mac如何录制gif呢,为什么我用licecap录制出来的是黑屏呢(⊙﹏⊙).","link":"/2017/09/24/amap-input-tips/"},{"title":"基于高德地图实现完全自定义Marker","text":"&emsp;&emsp;做地图社交类APP开发的都知道,一般情况下,为了整体的美观和用户体验度,我们需要定制化Marker的样式。本文中实现的方式都是基于高德地图的,百度地图也类似,大家可以照葫芦画瓢,废话不多说,先来看看最终效果: 实现思路:先来看看高德官方提供的设置Marker图标的方法: 我们可以看到setIcon()方法,里面的参数BitmapDescriptor就是我们最终需要的东西。那么到底该如何得到这个BitmapDescriptor对象呢,其实很简单,该对象可以通过BitmapDescriptorFactory工厂类获取,BitmapDescriptorFactory提供了以下方法来得到BitmapDescriptor对象: 12345678910111213141516171819202122232425262728293031323334353637383940/** * 1.通过资源id获取 */public static BitmapDescriptor fromResource(int var0) { ......}/** * 2.通过自定义的view获取 */ public static BitmapDescriptor fromView(View var0) { ...... }/** * 3.通过具体路径资源获取 */ public static BitmapDescriptor fromPath(String var0) { ......}/** * 4.通过具体Assets资源获取 */ public static BitmapDescriptor fromAsset(String var0) { ...... }/** * 5.通过具体文件获取 */public static BitmapDescriptor fromFile(String var0) { ......}/** * 6.通过bitmap获取 */ public static BitmapDescriptor fromBitmap(Bitmap var0) { ...... } 从以上官方提供的方法可以看到,得到BitmapDescriptor对象的方式有多种,我们可以根据自己需要自行选择。但是,为了应对频繁的需求变化,我们肯定要选择更为动态,灵活的方式来应付我们的需求变化,我们就可以选择fromView()和fromBitmap()两种方式来得到BitmapDescriptor对象了。这里选用fromBitmap()方式来得到BitmapDescriptor对象吧,因为采用fromView()方法获取后有个巨坑,这个后面再说。 &emsp;&emsp;如果我们要根据需求自定义Marker,当然是希望能够让它可大可小,可动可静了,那就非view莫属了。只要我们可以自定义view布局,然后转化成bitmap不就OK了吗,好,说干就干,我们以自定义Makrer样式并加载网络图片为例,开干! 定制化Marker布局,加载网络图片: 我们就以实现以下Marker的样式为例: 这个样式比较简单,只要一个CircleImageView外面套一个固定的容器就可以了,直接看布局代码: marker_bg.xml: 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;40dp&quot; android:layout_height=&quot;47dp&quot; android:layout_gravity=&quot;center&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;40dp&quot; android:layout_height=&quot;47dp&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_alignParentBottom=&quot;true&quot; android:background=&quot;@mipmap/act_map_business_bg&quot;&gt; &lt;de.hdodenhof.circleimageview.CircleImageView android:id=&quot;@+id/marker_item_icon&quot; android:layout_width=&quot;32dp&quot; android:layout_height=&quot;32dp&quot; android:src=&quot;@mipmap/userheadholder&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginTop=&quot;1dp&quot; /&gt; &lt;/RelativeLayout&gt;&lt;/RelativeLayout&gt; 下面看一下代码中如何使用: 123456789101112131415161718192021222324252627282930313233343536/** * by moos on 2017/11/13 * func:定制化marker的图标 * @return */ private void customizeMarkerIcon(String url, final OnMarkerIconLoadListener listener){ final View markerView = LayoutInflater.from(this).inflate(R.layout.marker_bg,null); final CircleImageView icon = (CircleImageView) markerView.findViewById(R.id.marker_item_icon); Glide.with(this) .load(url+&quot;!/format/webp&quot;) .asBitmap() .thumbnail(0.2f) .diskCacheStrategy(DiskCacheStrategy.NONE) .centerCrop() .into(new SimpleTarget&lt;Bitmap&gt;(){ @Override public void onResourceReady(Bitmap bitmap, GlideAnimation glideAnimation) { //待图片加载完毕后再设置bitmapDes icon.setImageBitmap(bitmap); bitmapDescriptor = BitmapDescriptorFactory.fromBitmap(convertViewToBitmap(markerView)); listener.markerIconLoadingFinished(markerView); } }); }....../** * by moos on 2017/11/15 * func:自定义监听接口,用来marker的icon加载完毕后回调添加marker属性 */ public interface OnMarkerIconLoadListener{ void markerIconLoadingFinished(View view); } 这部分代码也不是很难,我就简单讲讲思路。首先加载布局后,拿到里面的控件CircleImageView,并使用常用的Glide图片加载框架来加载网络图片。可能会有人问,为什么关闭Glide的缓存设置呢?关注到这点的人还是比较细心的,我们使用glide加载大量marker布局的时候,如果社会了缓存选项,那么就可能会出现相同图片只显示一张的状况,这个如果不信的话可以自行实验。&emsp;&emsp;下面来说说另一个问题,也就是刚刚我们为什么选择fromBitmap()而不是fromView()方法,因为之前用fromView()时发现添加的第一个marker并不会加载出图片,而只是显示默认的占位图。即使通过在Glide加载图片的回调方法onResourceReady()设置也依然无效,这个问题大家不信邪也可以试试看看,这就是最终为什么选择fromBitmap()方法的原因。这里还使用了自定义的接口来传入markerView,方便后面的二次开发,然后在回调方法markerIconLoadingFinished()方法中设置marker的图标。 将view转化为bitmap对象: 1234567891011121314151617/** * by mos on 2017.11.13 * func:view转bitmap */ public static Bitmap convertViewToBitmap(View view) { view.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED), View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)); view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight()); view.buildDrawingCache(); Bitmap bitmap = view.getDrawingCache(); return bitmap; } 网上相关方法很多,这里就不介绍了,有兴趣可以去百度一下。 批量添加自定义的Marker到地图上:先来看看代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * by moos on 2017/11/15 * func:添加marker到地图上显示 */ BitmapDescriptor bitmapDescriptor ; private void addMarker(final ImageNearBean.DataBean.ExhibitionListBean bean) { double lat; double lon; lat = bean.getLatitude(); lon = bean.getLongitude(); LatLng latLng = new LatLng(lat, lon, false); loge(&quot;添加maker前的类型为===&quot;+bean.getUserType()); String url = bean.getUserLogo(); final MarkerOptions markerOptions = new MarkerOptions(); markerOptions.setFlat(true); markerOptions.anchor(0.5f, 0.5f); markerOptions.position(new LatLng(lat, lon)); customizeMarkerIcon(url, bean.getTeamName(),new OnMarkerIconLoadListener() { @Override public void markerIconLoadingFinished(View view) { //bitmapDescriptor = BitmapDescriptorFactory.fromView(view); markerOptions.icon(bitmapDescriptor); Marker marker; marker = mAMap.addMarker(markerOptions); //marker.setObject(cluster); } }); } /** * by moos on 2017/11/15 * func:批量添加marker到地图上 */ private void addMarkersToMap(){ runOnUiThread(new Runnable() { @Override public void run() { for(int i = 0;i&lt;allBussinessBean.size();i++){ addMarker(allBussinessBean.get(i)); } } }); } 既然marker样式定制完毕,BitmapDescriptor也拿到了,那么下面就简单了,应该就不需要我多说了,只要注意一点,批量添加marker一般比较耗时,尽量放在子线程处理。 &emsp;&emsp;到这里,自定义marker就实现了,这应该可以适用于多数情况了,一路看下来,是不是也挺简单的,只要用心思考研究就好了,而且搞定后有很强的工作动力有木有!","link":"/2017/11/25/amap-marker-custom/"},{"title":"Android基于高德地图实现Marker聚合效果","text":"最近,项目有了新的需求,要求地图上的标签点实现聚合效果,单纯的marker已经无法满足大量数据展示的情况,聚合效果成为大势所趋。 目前,网上提供基于高德marker聚合的思路大致差不多,处于雏形阶段。高德官方也提供了关于聚合的解决方案,对于缓存和加载效率都做了一些处理,为我们后面的定制奠定了基础,本文就在高德官方提供的方案基础上做一些定制化。笔者经过思考后,还是觉得将篇幅分为上下两部分,前篇主要涉及聚合的基本使用以及针对定制过程中出现的坑进行填补(如多种聚合标签的冲突,聚合标签与普通标签的冲突问题等),下篇则讲述如何定制化marker并加载网络图片(为了方便描述,marker聚合在下文都称之为聚合标签)。看完两篇文章,大家还可以尝试将聚合和网络图片样式的marker结合起来,达到更加炫酷的效果。话不多说,先来看看最终的效果吧: 先来放一下官网提供的聚合点的demo:https://github.com/amap-demo/android-cluster-marker,如果只是实现一种聚合点,可以复制官方的demo代码,稍微改改就可以用了。如果你们产品有其他需求,比如多种聚合标签点,或者实现普通标签和聚合标签的混排使用,那么可以参考下本文提供的改进思路。 发现问题: 首先,我们发现高德官方提供的demo存在的问题: 当存在多种类型聚合标签点时,聚合点的点击事件冲突问题. 这个问题是什么意思呢?举个例子:当地图上我们先后初始化两种聚合标签点A和B的时候,不管点击A还是B类型的聚合点,都会只响应B类的点击事件,即先声明的聚合标签的点击事件会被后声明的聚合标签的点击事件”抢占”. 当地图上存在普通标签(Marker)和聚合标签(Cluster)时,同样会产生点击事件的冲突问题. 这个意思就是,点击聚合标签仍然会响应普通标签的点击事件. 分析问题: 这两个问题其实归根结底是一个问题,都是因为marker的点击事件被抢占,从官方的提供的ClusterOverlay类中代码我们就可以看出来: 1234567891011121314151617......amap.setOnCameraChangeListener(this);amap.setOnMarkerClickListener(this);...... //点击事件 @Override public boolean onMarkerClick(Marker arg0) { if (mClusterClickListener == null) { return true; } Cluster cluster= (Cluster) arg0.getObject(); if(cluster!=null){ mClusterClickListener.onClick(arg0,cluster.getClusterItems()); return true; } return false; } &emsp;&emsp;从以上代码我们可以看出来,聚合处理类ClusterOverlay实现了AMap.OnMarkerClickListener接口,而当我们使用两个或者两个以上样式的聚合标签时,我们就会发现明明是两种类型的聚合标签,但是却触发相同的点击事件。这样显然是不符合我们预期需求的,那么我们该如何让不同样式的聚合标签A,B,C…各司其职呢?你肯定会说,废话,不然你现在在讲啥!咳咳,请允许我静静~ 解决问题: &emsp;&emsp;显然,如果我们想让各种聚合标签互不干扰,需要集中管理它们的点击事件,即OnMarkerClickListener。假设我们写了两个不同的聚合标签类ClusterOverlayA和ClusterOverlayB,我们可以将两个类中OnMarkerClick()方法中的逻辑拿出来,单独封装成一个方法,然后放在我们Activity的onMarkerClick()中执行.这里我贴一下修改后的ClusterOverlay类,前方高能,一大波代码来袭: ClusterOverlay: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492/** * Created by yiyi.qi on 16/10/10. * 整体设计采用了两个线程,一个线程用于计算组织聚合数据,一个线程负责处理Marker相关操作 */public class ClusterOverlay { private AMap mAMap; private Context mContext; private List&lt;ClusterItem&gt; mClusterItems; private List&lt;Cluster&gt; mClusters; private int mClusterSize; private ClusterClickListener mClusterClickListener; private ClusterRender mClusterRender; private ClusterRenderB bClusterRender; private AMap.OnMarkerClickListener markerClickListener=new AMap.OnMarkerClickListener() { @Override public boolean onMarkerClick(Marker arg0) { if (mClusterClickListener == null) { return true; } Cluster cluster = (Cluster) arg0.getObject(); //将marker的位置移动到地图中心 LatLng latLng=new LatLng(arg0.getPosition().latitude,arg0.getPosition().longitude); mAMap.moveCamera(CameraUpdateFactory.changeLatLng(latLng)); if (cluster != null) { arg0.showInfoWindow(); Log.e(&quot;timeory&quot;, &quot;普通标签infowindow出现了吗? &quot; + arg0.isInfoWindowShown()+ &quot; &quot;+ arg0.isInfoWindowEnable(), null); mClusterClickListener.onClick(arg0, cluster.getClusterItems()); return true; } return false; } }; private List&lt;Marker&gt; mAddMarkers = new ArrayList&lt;Marker&gt;(); private double mClusterDistance; private LruCache&lt;Integer, BitmapDescriptor&gt; mLruCache; private HandlerThread mMarkerHandlerThread = new HandlerThread(&quot;addMarker&quot;); private HandlerThread mSignClusterThread = new HandlerThread(&quot;calculateCluster&quot;); private Handler mMarkerhandler; private Handler mSignClusterHandler; private float mPXInMeters; private boolean mIsCanceled = false; private MarkerOptions markerOptions; private Cluster mcluster; private LatLng latlng1; /** * 构造函数 * * @param amap * @param clusterSize 聚合范围的大小（指点像素单位距离内的点会聚合到一个点显示） * @param context */ public ClusterOverlay(AMap amap, int clusterSize, Context context) { this(amap, null, clusterSize, context); } /** * 构造函数,批量添加聚合元素时,调用此构造函数 * 默认最多会缓存80张图片作为聚合显示元素图片,根据自己显示需求和app使用内存情况,可以修改数量 * @param amap * @param clusterItems 聚合元素 * @param clusterSize * @param context */ public ClusterOverlay(AMap amap, List&lt;ClusterItem&gt; clusterItems, int clusterSize, Context context) { mLruCache = new LruCache&lt;Integer, BitmapDescriptor&gt;(80) { protected void entryRemoved(boolean evicted, Integer key, BitmapDescriptor oldValue, BitmapDescriptor newValue) { oldValue.getBitmap().recycle(); } }; if (clusterItems != null) { mClusterItems = clusterItems; } else { mClusterItems = new ArrayList&lt;ClusterItem&gt;(); } mContext = context; mClusters = new ArrayList&lt;Cluster&gt;(); this.mAMap = amap; mClusterSize = clusterSize; mPXInMeters = mAMap.getScalePerPixel(); mClusterDistance = mPXInMeters * mClusterSize; initThreadHandler(); assignClusters(); } /** * by moos on 2017/11/13 * function:聚合刷新,在activity的onCameraChangeFinish()方法中 */ public void updateClusters(){ mPXInMeters = mAMap.getScalePerPixel(); mClusterDistance = mPXInMeters * mClusterSize; assignClusters(); } /** * by moos on 2017/11/13 * func:通过activity中的onMarkerClick()响应聚合点的点击事件 * @param arg0 */ public void respondClusterClickEvent(Marker arg0){ Cluster cluster = (Cluster) arg0.getObject(); //将marker的位置移动到地图中心 LatLng latLng=new LatLng(arg0.getPosition().latitude,arg0.getPosition().longitude); mAMap.moveCamera(CameraUpdateFactory.changeLatLng(latLng)); if (cluster != null) { arg0.showInfoWindow(); Log.e(&quot;timeory&quot;, &quot;普通标签infowindow出现了吗? &quot; + arg0.isInfoWindowShown()+ &quot; &quot;+ arg0.isInfoWindowEnable(), null); mClusterClickListener.onClick(arg0, cluster.getClusterItems()); } } /** * 设置聚合点的点击事件 * * @param clusterClickListener */ public void setOnClusterClickListener(ClusterClickListener clusterClickListener) { mClusterClickListener = clusterClickListener; } /** * 添加一个聚合点 * * @param item */ public void addClusterItem(ClusterItem item) { Message message = Message.obtain(); message.what = SignClusterHandler.CALCULATE_SINGLE_CLUSTER; message.obj = item; mSignClusterHandler.sendMessage(message); } /** * 共外部调用的接口,设置聚合元素的渲染样式，不设置则默认为气泡加数字形式进行渲染 * * @param render */ public void setClusterRenderer(ClusterRender render) { mClusterRender = render; } /** * 设置聚合元素的渲染样式，不设置则默认为气泡加数字形式进行渲染 * * @param render */ public void setBClusterRenderer(ClusterRenderB render) { bClusterRender = render; } public void onDestroy() { mIsCanceled = true; mSignClusterHandler.removeCallbacksAndMessages(null); mMarkerhandler.removeCallbacksAndMessages(null); mSignClusterThread.quit(); mMarkerHandlerThread.quit(); for (Marker marker : mAddMarkers) { marker.remove(); } if(markerClickListener!=null){ markerClickListener = null; } mAddMarkers.clear(); mLruCache.evictAll(); } /** * 清除maker点击事件,防止抢占 */ public void cleanListener(){ if(markerClickListener!=null){ markerClickListener = null; } } //初始化Handler private void initThreadHandler() { mMarkerHandlerThread.start(); mSignClusterThread.start(); mMarkerhandler = new MarkerHandler(mMarkerHandlerThread.getLooper()); mSignClusterHandler = new SignClusterHandler(mSignClusterThread.getLooper()); } /** * 将聚合元素添加至地图上 */ private void addClusterToMap(List&lt;Cluster&gt; clusters) { ArrayList&lt;Marker&gt; removeMarkers = new ArrayList&lt;&gt;(); removeMarkers.addAll(mAddMarkers); AlphaAnimation alphaAnimation = new AlphaAnimation(1, 0); MyAnimationListener myAnimationListener = new MyAnimationListener(removeMarkers); for (Marker marker : removeMarkers) { marker.setAnimation(alphaAnimation); marker.setAnimationListener(myAnimationListener); marker.startAnimation(); } for (Cluster cluster : clusters) { addSingleClusterToMap(cluster); } } private AlphaAnimation mADDAnimation = new AlphaAnimation(0, 1); /** * 将单个聚合元素添加至地图显示 * * @param cluster */ private void addSingleClusterToMap(Cluster cluster) { latlng1 = cluster.getCenterLatLng(); markerOptions = new MarkerOptions(); markerOptions .anchor(0.5f, 0.5f) .icon(getBitmapDes(cluster.getClusterCount())) .position(latlng1); Marker marker = mAMap.addMarker(markerOptions); marker.setAnimation(mADDAnimation); marker.setObject(cluster); marker.startAnimation();// marker.setTitle(&quot;你好啊&quot;);// marker.setSnippet(&quot;真的不好&quot;); cluster.setMarker(marker); mcluster = cluster; mAddMarkers.add(marker); } public void newIcon() { markerOptions .anchor(0.5f, 0.5f) .icon(getBitmapDes(mcluster.getClusterCount())) .position(latlng1); } private void calculateClusters() { mIsCanceled = false; mClusters.clear(); //地图获取转换器, 获取可视区域, 获取可视区域的四个点形成的经纬度范围, 得到一个经纬度范围 LatLngBounds visibleBounds = mAMap.getProjection().getVisibleRegion().latLngBounds; for (ClusterItem clusterItem : mClusterItems) { if (mIsCanceled) { return; } LatLng latlng = clusterItem.getPosition();//聚合元素的地理位置 if (visibleBounds.contains(latlng)) {//如果这个范围包含这个聚合元素的地理位置 Cluster cluster = getCluster(latlng, mClusters);//根据这个位置和聚合物的集合, 获得一个聚合器 if (cluster != null) { cluster.addClusterItem(clusterItem);//往聚合器中添加聚合点 } else { cluster = new Cluster(latlng); mClusters.add(cluster); cluster.addClusterItem(clusterItem); } } } //复制一份数据，规避同步 List&lt;Cluster&gt; clusters = new ArrayList&lt;Cluster&gt;(); clusters.addAll(mClusters); Message message = Message.obtain(); message.what = MarkerHandler.ADD_CLUSTER_LIST; message.obj = clusters; if (mIsCanceled) { return; } mMarkerhandler.sendMessage(message); } /** * 对点进行聚合 */ private void assignClusters() { mIsCanceled = true; mSignClusterHandler.removeMessages(SignClusterHandler.CALCULATE_CLUSTER); mSignClusterHandler.sendEmptyMessage(SignClusterHandler.CALCULATE_CLUSTER); } /** * 在已有的聚合基础上，对添加的单个元素进行聚合 * * @param clusterItem */ private void calculateSingleCluster(ClusterItem clusterItem) { LatLngBounds visibleBounds = mAMap.getProjection().getVisibleRegion().latLngBounds; LatLng latlng = clusterItem.getPosition(); if (!visibleBounds.contains(latlng)) { return; } Cluster cluster = getCluster(latlng, mClusters); if (cluster != null) { cluster.addClusterItem(clusterItem); Message message = Message.obtain(); message.what = MarkerHandler.UPDATE_SINGLE_CLUSTER; message.obj = cluster; mMarkerhandler.removeMessages(MarkerHandler.UPDATE_SINGLE_CLUSTER); mMarkerhandler.sendMessageDelayed(message, 5); } else { cluster = new Cluster(latlng); mClusters.add(cluster); cluster.addClusterItem(clusterItem); Message message = Message.obtain(); message.what = MarkerHandler.ADD_SINGLE_CLUSTER; message.obj = cluster; mMarkerhandler.sendMessage(message); } } /** * 根据一个点获取是否可以依附的聚合点，没有则返回null * * @param latLng * @return */ private Cluster getCluster(LatLng latLng, List&lt;Cluster&gt; clusters) { for (Cluster cluster : clusters) { LatLng clusterCenterPoint = cluster.getCenterLatLng(); double distance = AMapUtils.calculateLineDistance(latLng, clusterCenterPoint); if (distance &lt; mClusterDistance) { return cluster; } } return null; } /** * 获取每个聚合点的绘制样式 */ private BitmapDescriptor getBitmapDes(int num) { //加载字体 Typeface typeFace = Typeface.createFromAsset(mContext.getAssets(), &quot;fonts/A-OTF-ShinGoPr6N-Ultra.otf&quot;); BitmapDescriptor bitmapDescriptor = mLruCache.get(num); if (bitmapDescriptor == null) { TextView textView = new TextView(mContext); // 应用字体 textView.setTypeface(typeFace); if (num &lt; 10) { String tile = String.valueOf(num); textView.setText(tile); }else if(num==1){ textView.setText(&quot;&quot;); }else { float zoom = mAMap.getCameraPosition().zoom; //loge(&quot;当前缩放级别是==&quot; + zoom); if (zoom == 19.0 || zoom == 20.0) { String tile = String.valueOf(num); textView.setText(tile); } } textView.setGravity(Gravity.CENTER); textView.setTextColor(Color.parseColor(&quot;#ffffff&quot;)); textView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 12); if (mClusterRender != null &amp;&amp; mClusterRender.getDrawAble(num) != null) { textView.setBackgroundDrawable(mClusterRender.getDrawAble(num)); //根据数量设置背景样式 } else { //textView.setBackgroundResource(R.mipmap.act_map_evelopetwo); //2017/09/25修改 换图标 textView.setBackgroundResource(R.mipmap.act_map_blue_icon_bg); } bitmapDescriptor = BitmapDescriptorFactory.fromView(textView); mLruCache.put(num, bitmapDescriptor); //把聚合点数量,样式键值对形式存入集合中 } return bitmapDescriptor; } /** * 更新已加入地图聚合点的样式 */ private void updateCluster(Cluster cluster) { Marker marker = cluster.getMarker(); marker.setIcon(getBitmapDes(cluster.getClusterCount())); }//-----------------------辅助内部类用--------------------------------------------- /** * marker渐变动画，动画结束后将Marker删除 */ class MyAnimationListener implements Animation.AnimationListener { private List&lt;Marker&gt; mRemoveMarkers; MyAnimationListener(List&lt;Marker&gt; removeMarkers) { mRemoveMarkers = removeMarkers; } @Override public void onAnimationStart() { } @Override public void onAnimationEnd() { for (Marker marker : mRemoveMarkers) { marker.remove(); } mRemoveMarkers.clear(); } } /** * 处理market添加，更新等操作 */ class MarkerHandler extends Handler { static final int ADD_CLUSTER_LIST = 0; static final int ADD_SINGLE_CLUSTER = 1; static final int UPDATE_SINGLE_CLUSTER = 2; MarkerHandler(Looper looper) { super(looper); } public void handleMessage(Message message) { switch (message.what) { case ADD_CLUSTER_LIST: List&lt;Cluster&gt; clusters = (List&lt;Cluster&gt;) message.obj; addClusterToMap(clusters); break; case ADD_SINGLE_CLUSTER: Cluster cluster = (Cluster) message.obj; addSingleClusterToMap(cluster); break; case UPDATE_SINGLE_CLUSTER: Cluster updateCluster = (Cluster) message.obj; updateCluster(updateCluster); break; } } } /** * 处理聚合点算法线程 */ class SignClusterHandler extends Handler { static final int CALCULATE_CLUSTER = 0; static final int CALCULATE_SINGLE_CLUSTER = 1; SignClusterHandler(Looper looper) { super(looper); } public void handleMessage(Message message) { switch (message.what) { case CALCULATE_CLUSTER: calculateClusters(); break; case CALCULATE_SINGLE_CLUSTER: ClusterItem item = (ClusterItem) message.obj; mClusterItems.add(item); Log.e(&quot;cluster_overlay&quot;, &quot;calculate single cluster&quot;); calculateSingleCluster(item); break; } } }} 以上代码大家可以根据自己具体需要修改,接下来是聚合标签类Cluster代码,几乎没改(滑稽): Cluster: 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Cluster { private LatLng mLatLng; private List&lt;ClusterItem&gt; mClusterItems; private Marker mMarker; public Cluster(LatLng latLng) { mLatLng = latLng; mClusterItems = new ArrayList&lt;ClusterItem&gt;(); } public Cluster(List&lt;ClusterItem&gt; clusterItems){ mClusterItems = new ArrayList&lt;&gt;() ; mClusterItems = clusterItems; } public void addClusterItem(ClusterItem clusterItem) { mClusterItems.add(clusterItem); } public int getClusterCount() { return mClusterItems.size(); } public LatLng getCenterLatLng() { return mLatLng; } public void setMarker(Marker marker) { mMarker = marker; } public Marker getMarker() { return mMarker; } public List&lt;ClusterItem&gt; getClusterItems() { return mClusterItems; }} 然后就是ClusterItem接口了,用来获取聚合标签的相关信息: ClusterItem: 1234567891011public interface ClusterItem { /** * 返回聚合元素的地理位置 * * @return */ LatLng getPosition(); String getUserType();} 有人可能会问:getUserType()方法干啥用的?客官,别急,先接着往下看,很快就知道它的用处了. 接着,就是我们的RegionItem类了,实现了ClusterItem接口: RegionItem: 12345678910111213141516171819202122public class RegionItem implements ClusterItem { private LatLng mLatLng; private String userType; public String getUserType() { return userType; } public RegionItem(LatLng latLng, String userType) { this.mLatLng=latLng; this.userType = userType; } @Override public LatLng getPosition() { // TODO Auto-generated method stub return mLatLng; }} 最后,就是要在Activity中根据需求添加我们的聚合标签了: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private ClusterOverlay mClusterOverlay;//普通用户聚合覆盖物的对象private BClusterOverlay bClusterOverlay;//企业用户聚合覆盖物的对象/** * by moos on 2017/11/15 * func:添加并显示聚合点,增加点击和绘制事件 */ private void addItems() { new Thread() { public void run() { List&lt;ClusterItem&gt; items = new ArrayList&lt;ClusterItem&gt;();//普通用户 List&lt;ClusterItem&gt; bItems = new ArrayList&lt;ClusterItem&gt;();//企业用户 //loge(&quot;附近的点有===&quot; + imageNearBean.getData().getExhibitionList().size()); for (int i = 0; i &lt; imageNearBean.getData().getExhibitionList().size(); i++) { double lat = imageNearBean.getData().getExhibitionList().get(i).getLatitude(); double lon = imageNearBean.getData().getExhibitionList().get(i).getLongitude(); if (imageNearBean.getData().getExhibitionList().get(i).getUserType() != null &amp;&amp; imageNearBean.getData().getExhibitionList().get(i).getUserType().equals(&quot;03&quot;)) {//是企业用户的数据 LatLng latLng = new LatLng(lat, lon, false); RegionItem regionItem = new RegionItem(latLng, imageNearBean.getData().getExhibitionList().get(i).getUserType());//添加元素 bItems.add(regionItem); allBussinessBean.add(imageNearBean.getData().getExhibitionList().get(i));//放入所有企业用户数据 }else { //是普通用户 LatLng latLng = new LatLng(lat, lon, false); RegionItem regionItem = new RegionItem(latLng, imageNearBean.getData().getExhibitionList().get(i).getOriginalId(), imageNearBean.getData().getExhibitionList().get(i).getUserType());//添加元素 items.add(regionItem); } } log.e(&quot;普通用户有==&quot; + items.size()); log.e(&quot;企业用户有==&quot; + bItems.size()); if ( items.size() &gt; 0) { if (mClusterOverlay == null) { //覆盖物的集合, mClusterOverlay = new ClusterOverlay(mAMap, items, dp2px(getApplicationContext(), clusterRadius), getApplicationContext()); //地图对象,集合,聚合范围,上下文传到指定方法实现 } else { mClusterOverlay.onDestroy(); //销毁之前的覆盖物集合 mClusterOverlay = null; mClusterOverlay = new ClusterOverlay(mAMap, items, dp2px(getApplicationContext(), clusterRadius), getApplicationContext()); } //渲染和聚合点点击事件监听 mClusterOverlay.setClusterRenderer(MapActivity.this); //getdrawable 方法实现 mClusterOverlay.setOnClusterClickListener(MapActivity.this); //onclick方法实现 } if ( bItems.size() &gt; 0) { //商家用户数据 loge(&quot;设置企业标签点击事件&quot;); if (bClusterOverlay == null) { //覆盖物的集合 bClusterOverlay = new BClusterOverlay(mAMap, bItems, dp2px(getApplicationContext(), clusterRadius), getApplicationContext()); } else { bClusterOverlay.onDestroy(); bClusterOverlay = null; bClusterOverlay = new BClusterOverlay(mAMap, bItems, dp2px(getApplicationContext(), clusterRadius), getApplicationContext()); } //渲染和聚合点点击事件监听 bClusterOverlay.setClusterRenderer(this); bClusterOverlay.setOnClusterClickListener(MapActivity.this); //onBclick 方法实现 } runOnUiThread(new Runnable() { @Override public void run() { addMarkersToMap();//添加普通marker到地图 } }); } }.start(); } 这里大家可能看得很烦,没错,看得很烦就对了😆!因为这一部分完全没必要看…只是为了筛选后台不同的用户数据而已。记得之前我提到的ClusterItem类中getUserType()方法以及实现这个接口的类RegionItem中定义的userType变量吗?它的作用就是用来区分不同的聚合标签,以上代码的03代表商家用户,其余类型默认普通用户。 最后,就是我们的重头戏了,集中处理多种聚合标签的点击事件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748mAMap.setOnCameraChangeListener(new AMap.OnCameraChangeListener() { @Override public void onCameraChange(CameraPosition cameraPosition) { //LatLng latLng = cameraPosition.target; } @Override public void onCameraChangeFinish(CameraPosition cameraPosition) { mClusterOverlay.updateClusters();//刷新 bClusterOverlay.updateClusters(); } }); mAMap.setOnMarkerClickListener(new AMap.OnMarkerClickListener() { @Override public boolean onMarkerClick(Marker marker) { //mClusterOverlay.cleanListener(); Cluster cluster = (Cluster) marker.getObject(); if(cluster!=null &amp;&amp; cluster.getClusterCount()&gt;0){ if(cluster.getClusterItems().get(0).getUserType().equals(&quot;03&quot;)){ loge(&quot;是普通用户聚合标签&quot;); mClusterOverlay.respondClusterClickEvent(marker);//响应聚合点的点击事件 }else { loge(&quot;是商家用户聚合标签&quot;); bClusterOverlay.respondClusterClickEvent(marker);//响应聚合点的点击事件 } } return true; } }); ...... //聚合标签的点击事件 @Override public void onClick(Marker marker, List&lt;ClusterItem&gt; clusterItems) { loge(&quot;点击了普通用户&quot;); } @Override public void onBClick(Marker marker, List&lt;ClusterItem&gt; clusterItems) { loge(&quot;点击了商家用户&quot;); } 代码有点多,具体业务逻辑代码就不贴了,估计看了也会比较的烦,大家只需要看onMarkerClick()方法中的逻辑就OK了。一般情况下,我们需要点击不同的marker后,获取该marker应该对应的数据,那么该如何获取呢?为了快点结束战斗,这里我就不卖关子了,高德marker类中有一方法getObject(),官方是这样描述的: 看到这,很多人一定豁然开朗,没错!还有个对应的方法marker.setObject(Object obj)。在ClusterOverlay中,我们可以找到如下代码: 123456789101112131415161718192021/** * 将单个聚合元素添加至地图显示 * * @param cluster */ private void addSingleClusterToMap(Cluster cluster) { latlng1 = cluster.getCenterLatLng(); markerOptions = new MarkerOptions(); markerOptions .anchor(0.5f, 0.5f) .icon(getBitmapDes(cluster.getClusterCount())) .position(latlng1); Marker marker = mAMap.addMarker(markerOptions); marker.setAnimation(mADDAnimation); marker.setObject(cluster); marker.startAnimation(); cluster.setMarker(marker); mcluster = cluster; mAddMarkers.add(marker); } 看看上面这块代码,我们的确发现了marker.setObject(cluster)方法,cluster里面有什么?有ClusterItem呀!看到这,我们就发现,前面的getUsertype()方法不是正好派上用场了嘛!添加聚合标签的时候,我们给每个marker贴上了”名牌”,当我们点击聚合标签的时候,拿到附加的信息并找到这个名牌(userType),这样不就可以轻而易举”撕掉名牌”了吗!😆 &emsp;&emsp;这样我们就解决多种聚合标签点击冲突的问题了,至于如何解决聚合标签与普通Marker点击事件冲突,其实大同小异,这里就不献丑了,相信对于大家来说没什么问题。下一篇文章将为大家提供marker加载网络图片的完美解决方案,请拭目以待! &emsp;&emsp;最后,大家有任何问题或者建议,欢迎留言或者加群讨论,谢谢. 代码地址：https://github.com/Moosphan/AMapMarker-master","link":"/2017/11/20/amap-marker-lot/"},{"title":"Android实现社交应用中的评论和回复功能","text":"本文已授权微信公众号hongyangAndroid(张鸿洋)独家发布. 在Android的日常开发中，评论与回复功能是我们经常遇到的需求之一，其中评论与回复列表的展示一般在功能模块中占比较大。对于需求改动和迭代较频繁的公司来说，如何快速开发一个二级界面来适应我们的功能需求无疑优先级更高一些。首先我们来看看其他社交类app的评论与回复列表如何展示的： Twitter不用说了，全球知名社交平台，上亿用户量，他们的评论回复都只展示一级数据(评论数据)，其他更多内容（回复内容），是需要页面跳转去查看，知乎也类似。第一张图是我们设计给我找的，他说要按照这个风格来，尽量将评论和回复内容在一个页面展示。好吧，没办法，毕竟我们做前端的，UI要看设计脸色，数据要看后台脸色😂。看到设计图，我们脑海肯定第一时间联想一下解决方案：用recyclerview？listview？不对，分析一下它的层级发现，评论是一个列表，里面的回复又是一个列表，难道用recyclerview或者listview的嵌套？抱着不确定的态度，立马去网上查一下，果不其然，搜到的实现方式大多都是用嵌套实现的，来公司之前，其中一个项目里的评论回复功能就是用的嵌套listview，虽然处理了滑动冲突问题，但效果不佳，而且时常卡顿，所以，这里我肯定要换个思路。 网上还有说用自定义view实现的，但我发现大多没有处理view的复用，而且开发成本大，暂时不予考虑。那怎么办？无意中看到expandable这个关键词，我突然想到谷歌很早之前出过一个扩展列表的控件 - ExpandableListView，但听说比较老，存在一些问题。算了，试试再说，顺便熟悉一下以前基础控件的用法。 先来看一下最终的效果图吧： 这只是一个简单的效果图，你可以在此基础上来完善它。好了，废话不多说，下面让我们来看看效果具体如何实现的吧。大家应该不难看出来，页面整体采用了CoordinatorLayout来实现详情页的顶部视差效。同时，这里我采用ExpandableListView来实现多级列表，然后再解决它们的嵌套滑动问题。OK，我们先从ExpandableListView开始动手。 ExpandableListView官方对于ExpandableListView给出这样的解释：A view that shows items in a vertically scrolling two-level list. This differs from the ListView by allowing two levels: groups which can individually be expanded to show its children. The items come from the ExpandableListAdapter associated with this view. 简单来说，ExpandableListView是一个用于垂直方向滚动的二级列表视图，ExpandableListView与listview不同之处在于，它可以实现二级分组，并通过ExpandableListAdapter来绑定数据和视图。下面我们来一起实现上图的效果。 布局中定义首先，我们需要在xml的布局文件中声明ExpandableListView： 12345678&lt;ExpandableListView android:id=&quot;@+id/detail_page_lv_comment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:divider=&quot;@null&quot; android:layout_marginBottom=&quot;64dp&quot; android:listSelector=&quot;@android:color/transparent&quot; android:scrollbars=&quot;none&quot;/&gt; 这里需要说明两个问题： ExpandableListView默认为它的item加上了点击效果，由于item里面还包含了childItem，所以，点击后，整个item里面的内容都会有点击效果。我们可以取消其点击特效，避免其影响用户体验，只需要设置如上代码中的listSelector即可。 ExpandableListView具有默认的分割线，可以通过divider属性将其隐藏。 设置Adapter正如使用listView那样，我们需要为ExpandableListView设置一个适配器Adapter，为其绑定数据和视图。ExpandableListView的adapter需要继承自ExpandableListAdapter，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142/** * Author: Moos * E-mail: moosphon@gmail.com * Date: 18/4/20. * Desc: 评论与回复列表的适配器 */public class CommentExpandAdapter extends BaseExpandableListAdapter { private static final String TAG = &quot;CommentExpandAdapter&quot;; private List&lt;CommentDetailBean&gt; commentBeanList; private Context context; public CommentExpandAdapter(Context context, List&lt;CommentDetailBean&gt; commentBeanList) { this.context = context; this.commentBeanList = commentBeanList; } @Override public int getGroupCount() { return commentBeanList.size(); } @Override public int getChildrenCount(int i) { if(commentBeanList.get(i).getReplyList() == null){ return 0; }else { return commentBeanList.get(i).getReplyList().size()&gt;0 ? commentBeanList.get(i).getReplyList().size():0; } } @Override public Object getGroup(int i) { return commentBeanList.get(i); } @Override public Object getChild(int i, int i1) { return commentBeanList.get(i).getReplyList().get(i1); } @Override public long getGroupId(int groupPosition) { return groupPosition; } @Override public long getChildId(int groupPosition, int childPosition) { return getCombinedChildId(groupPosition, childPosition); } @Override public boolean hasStableIds() { return true; } boolean isLike = false; @Override public View getGroupView(final int groupPosition, boolean isExpand, View convertView, ViewGroup viewGroup) { final GroupHolder groupHolder; if(convertView == null){ convertView = LayoutInflater.from(context).inflate(R.layout.comment_item_layout, viewGroup, false); groupHolder = new GroupHolder(convertView); convertView.setTag(groupHolder); }else { groupHolder = (GroupHolder) convertView.getTag(); } Glide.with(context).load(R.drawable.user_other) .diskCacheStrategy(DiskCacheStrategy.RESULT) .error(R.mipmap.ic_launcher) .centerCrop() .into(groupHolder.logo); groupHolder.tv_name.setText(commentBeanList.get(groupPosition).getNickName()); groupHolder.tv_time.setText(commentBeanList.get(groupPosition).getCreateDate()); groupHolder.tv_content.setText(commentBeanList.get(groupPosition).getContent()); groupHolder.iv_like.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { if(isLike){ isLike = false; groupHolder.iv_like.setColorFilter(Color.parseColor(&quot;#aaaaaa&quot;)); }else { isLike = true; groupHolder.iv_like.setColorFilter(Color.parseColor(&quot;#FF5C5C&quot;)); } } }); return convertView; } @Override public View getChildView(final int groupPosition, int childPosition, boolean b, View convertView, ViewGroup viewGroup) { final ChildHolder childHolder; if(convertView == null){ convertView = LayoutInflater.from(context).inflate(R.layout.comment_reply_item_layout,viewGroup, false); childHolder = new ChildHolder(convertView); convertView.setTag(childHolder); } else { childHolder = (ChildHolder) convertView.getTag(); } String replyUser = commentBeanList.get(groupPosition).getReplyList().get(childPosition).getNickName(); if(!TextUtils.isEmpty(replyUser)){ childHolder.tv_name.setText(replyUser + &quot;:&quot;); } childHolder.tv_content.setText(commentBeanList.get(groupPosition).getReplyList().get(childPosition).getContent()); return convertView; } @Override public boolean isChildSelectable(int i, int i1) { return true; } private class GroupHolder{ private CircleImageView logo; private TextView tv_name, tv_content, tv_time; private ImageView iv_like; public GroupHolder(View view) { logo = view.findViewById(R.id.comment_item_logo); tv_content = view.findViewById(R.id.comment_item_content); tv_name = view.findViewById(R.id.comment_item_userName); tv_time = view.findViewById(R.id.comment_item_time); iv_like = view.findViewById(R.id.comment_item_like); } } private class ChildHolder{ private TextView tv_name, tv_content; public ChildHolder(View view) { tv_name = (TextView) view.findViewById(R.id.reply_item_user); tv_content = (TextView) view.findViewById(R.id.reply_item_content); } }} 一般情况下，我们自定义自己的ExpandableListAdapter后，需要实现以下几个方法： 构造方法，这个应该无需多说了，一般用来初始化数据等操作。 getGroupCount，返回group分组的数量，在当前需求中指代评论的数量。 getChildrenCount，返回所在group中child的数量，这里指代当前评论对应的回复数目。 getGroup，返回group的实际数据，这里指的是当前评论数据。 getChild，返回group中某个child的实际数据，这里指的是当前评论的某个回复数据。 getGroupId，返回分组的id，一般将当前group的位置传给它。 getChildId，返回分组中某个child的id，一般也将child当前位置传给它，不过为了避免重复，可以使用getCombinedChildId(groupPosition, childPosition);来获取id并返回。 hasStableIds，表示分组和子选项是否持有稳定的id，这里返回true即可。 isChildSelectable，表示分组中的child是否可以选中，这里返回true。 getGroupView，即返回group的视图，一般在这里进行一些数据和视图绑定的工作，一般为了复用和高效，可以自定义ViewHolder，用法与listview一样，这里就不多说了。 getChildView，返回分组中child子项的视图，比较容易理解，第一个参数是当前group所在的位置，第二个参数是当前child所在位置。 这里的数据是我自己做的模拟数据，不过应该算是较为通用的格式了，大体格式如下： 一般情况下，我们后台会通过接口返回给我们一部分数据，如果想要查看更多评论，需要跳转到“更多页面”去查看，这里为了方便，我们只考虑加载部分数据。 Activity中使用接下来，我们就需要在activity中显示评论和回复的二级列表了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576private ExpandableListView expandableListView;private CommentExpandAdapter adapter;private CommentBean commentBean;private List&lt;CommentDetailBean&gt; commentsList;...@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); } private void initView() { expandableListView = findViewById(R.id.detail_page_lv_comment); initExpandableListView(commentsList); } /** * 初始化评论和回复列表 */ private void initExpandableListView(final List&lt;CommentDetailBean&gt; commentList){ expandableListView.setGroupIndicator(null); //默认展开所有回复 adapter = new CommentExpandAdapter(this, commentList); expandableListView.setAdapter(adapter); for(int i = 0; i&lt;commentList.size(); i++){ expandableListView.expandGroup(i); } expandableListView.setOnGroupClickListener(new ExpandableListView.OnGroupClickListener() { @Override public boolean onGroupClick(ExpandableListView expandableListView, View view, int groupPosition, long l) { boolean isExpanded = expandableListView.isGroupExpanded(groupPosition); Log.e(TAG, &quot;onGroupClick: 当前的评论id&gt;&gt;&gt;&quot;+commentList.get(groupPosition).getId()); // if(isExpanded){// expandableListView.collapseGroup(groupPosition);// }else {// expandableListView.expandGroup(groupPosition, true);// } return true; } }); expandableListView.setOnChildClickListener(new ExpandableListView.OnChildClickListener() { @Override public boolean onChildClick(ExpandableListView expandableListView, View view, int groupPosition, int childPosition, long l) { Toast.makeText(MainActivity.this,&quot;点击了回复&quot;,Toast.LENGTH_SHORT).show(); return false; } }); expandableListView.setOnGroupExpandListener(new ExpandableListView.OnGroupExpandListener() { @Override public void onGroupExpand(int groupPosition) { //toast(&quot;展开第&quot;+groupPosition+&quot;个分组&quot;); } }); } /** * by moos on 2018/04/20 * func:生成测试数据 * @return 评论数据 */ private List&lt;CommentDetailBean&gt; generateTestData(){ Gson gson = new Gson(); commentBean = gson.fromJson(testJson, CommentBean.class); List&lt;CommentDetailBean&gt; commentList = commentBean.getData().getList(); return commentList; } 就以上代码作一下简单说明： ExpandableListView在默认情况下会为我们自带分组的icon（▶️），当前需求下，我们根本不需要展示，可以通过expandableListView.setGroupIndicator(null)来隐藏。 一般情况下，我们可能需要默认展开所有的分组，我就可以通过循环来调用expandableListView.expandGroup(i);方法。 ExpandableListView为我们提供了group和child的点击事件，分别通过setOnGroupClickListener和setOnChildClickListener来设置。值得注意的是，group的点击事件里如果我们返回的是false，那么我们点击group就会自动展开，但我这里碰到一个问题，当我返回false时，第一条评论数据会多出一条。通过百度查找方法，虽然很多类似问题，但终究没有解决，最后我返回了ture，并通过以下代码手动展开和收缩就可以了： 12345if(isExpanded){ expandableListView.collapseGroup(groupPosition);}else { expandableListView.expandGroup(groupPosition, true);} 此外，我们还可以通过setOnGroupExpandListener和setOnGroupCollapseListener来监听ExpandableListView的分组展开和收缩的状态。 评论和回复功能为了模拟整个评论和回复功能，我们还需要手动插入收据并刷新数据列表。这里我就简单做一下模拟，请忽略一些UI上的细节。 插入评论数据插入评论数据比较简单，只需要在list中插入一条数据并刷新即可： 123456789101112String commentContent = commentText.getText().toString().trim();if(!TextUtils.isEmpty(commentContent)){ //commentOnWork(commentContent); dialog.dismiss(); CommentDetailBean detailBean = new CommentDetailBean(&quot;小明&quot;, commentContent,&quot;刚刚&quot;); adapter.addTheCommentData(detailBean); Toast.makeText(MainActivity.this,&quot;评论成功&quot;,Toast.LENGTH_SHORT).show();}else { Toast.makeText(MainActivity.this,&quot;评论内容不能为空&quot;,Toast.LENGTH_SHORT).show();} adapter中的addTheCommentData方法如下： 123456789101112131415/** * by moos on 2018/04/20 * func:评论成功后插入一条数据 * @param commentDetailBean 新的评论数据 */public void addTheCommentData(CommentDetailBean commentDetailBean){ if(commentDetailBean!=null){ commentBeanList.add(commentDetailBean); notifyDataSetChanged(); }else { throw new IllegalArgumentException(&quot;评论数据为空!&quot;); }} 代码比较容易理解，就不多做说明了。 插入回复数据首先，我们需要实现点击某一条评论，然后@ta,那么我们需要在group的点击事件里弹起回复框： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859expandableListView.setOnGroupClickListener(new ExpandableListView.OnGroupClickListener() { @Override public boolean onGroupClick(ExpandableListView expandableListView, View view, int groupPosition, long l) { showReplyDialog(groupPosition); return true; } }); ....../** * by moos on 2018/04/20 * func:弹出回复框 */ private void showReplyDialog(final int position){ dialog = new BottomSheetDialog(this); View commentView = LayoutInflater.from(this).inflate(R.layout.comment_dialog_layout,null); final EditText commentText = (EditText) commentView.findViewById(R.id.dialog_comment_et); final Button bt_comment = (Button) commentView.findViewById(R.id.dialog_comment_bt); commentText.setHint(&quot;回复 &quot; + commentsList.get(position).getNickName() + &quot; 的评论:&quot;); dialog.setContentView(commentView); bt_comment.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { String replyContent = commentText.getText().toString().trim(); if(!TextUtils.isEmpty(replyContent)){ dialog.dismiss(); ReplyDetailBean detailBean = new ReplyDetailBean(&quot;小红&quot;,replyContent); adapter.addTheReplyData(detailBean, position); Toast.makeText(MainActivity.this,&quot;回复成功&quot;,Toast.LENGTH_SHORT).show(); }else { Toast.makeText(MainActivity.this,&quot;回复内容不能为空&quot;,Toast.LENGTH_SHORT).show(); } } }); commentText.addTextChangedListener(new TextWatcher() { @Override public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) { } @Override public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) { if(!TextUtils.isEmpty(charSequence) &amp;&amp; charSequence.length()&gt;2){ bt_comment.setBackgroundColor(Color.parseColor(&quot;#FFB568&quot;)); }else { bt_comment.setBackgroundColor(Color.parseColor(&quot;#D8D8D8&quot;)); } } @Override public void afterTextChanged(Editable editable) { } }); dialog.show(); } 插入回复的数据与上面插入评论类似，这里贴一下adapter中的代码： 123456789101112131415161718192021/** * by moos on 2018/04/20 * func:回复成功后插入一条数据 * @param replyDetailBean 新的回复数据 */public void addTheReplyData(ReplyDetailBean replyDetailBean, int groupPosition){ if(replyDetailBean!=null){ Log.e(TAG, &quot;addTheReplyData: &gt;&gt;&gt;&gt;该刷新回复列表了:&quot;+replyDetailBean.toString() ); if(commentBeanList.get(groupPosition).getReplyList() != null ){ commentBeanList.get(groupPosition).getReplyList().add(replyDetailBean); }else { List&lt;ReplyDetailBean&gt; replyList = new ArrayList&lt;&gt;(); replyList.add(replyDetailBean); commentBeanList.get(groupPosition).setReplyList(replyList); } notifyDataSetChanged(); }else { throw new IllegalArgumentException(&quot;回复数据为空!&quot;); }} 需要注意一点，由于不一定所有的评论都有回复数据，所以在插入数据前我们要判断ReplyList是否为空，如果不为空，直接获取当前评论的回复列表，并插入数据；如果为空，需要new一个ReplyList，插入数据后还要为评论set一下ReplyList。 解决CoordinatorLayout与ExpandableListView嵌套问题如果你不需要使用CoordinatorLayout或者NestedScrollView，可以跳过本小节。一般情况下，我们产品为了更好的用户体验，还需要我们加上类似的顶部视差效果或者下拉刷新等，这就要我们处理一些常见的嵌套滑动问题了。 由于CoordinatorLayout实现NestedScrollingParent接口,RecycleView实现了NestedScrollingChild接口,所以就可以在NestedScrollingChildHelper的帮助下实现嵌套滑动，那么我们也可以通过自定义的ExpandableListView实现NestedScrollingChild接口来达到同样的效果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Author: Moos * E-mail: moosphon@gmail.com * Date: 18/4/20. * Desc: 自定义ExpandableListView,解决与CoordinatorLayout滑动冲突问题 */public class CommentExpandableListView extends ExpandableListView implements NestedScrollingChild{ private NestedScrollingChildHelper mScrollingChildHelper; public CommentExpandableListView(Context context, AttributeSet attrs) { super(context, attrs); mScrollingChildHelper = new NestedScrollingChildHelper(this); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { setNestedScrollingEnabled(true); } } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2, MeasureSpec.AT_MOST); super.onMeasure(widthMeasureSpec, expandSpec); } @Override public void setNestedScrollingEnabled(boolean enabled) { mScrollingChildHelper.setNestedScrollingEnabled(enabled); } @Override public boolean isNestedScrollingEnabled() { return mScrollingChildHelper.isNestedScrollingEnabled(); } @Override public boolean startNestedScroll(int axes) { return mScrollingChildHelper.startNestedScroll(axes); } @Override public void stopNestedScroll() { mScrollingChildHelper.stopNestedScroll(); } @Override public boolean hasNestedScrollingParent() { return mScrollingChildHelper.hasNestedScrollingParent(); } @Override public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow) { return mScrollingChildHelper.dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, offsetInWindow); } @Override public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow) { return mScrollingChildHelper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow); } @Override public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed) { return mScrollingChildHelper.dispatchNestedFling(velocityX, velocityY, consumed); } @Override public boolean dispatchNestedPreFling(float velocityX, float velocityY) { return mScrollingChildHelper.dispatchNestedPreFling(velocityX, velocityY); }} 代码就不解释了，毕竟这不是本篇文章等重点，大家可以去网上查阅NestedScrollView相关文章或者源码去对照理解。 完整的布局代码比较多，篇幅有限，大家可以去github上面查看：https://github.com/Moosphan/CommentWithReplyView-master 也欢迎大家加入Android集中营，一起探讨技术：","link":"/2018/04/25/comment-reply-component/"},{"title":"Dart入门？一篇文章足矣","text":"近期公司准备启动新项目，经过技术团队一番调研，决定采用 Flutter 来开发第一版App，故作此文，常来回顾温习。由于项目采用敏捷开发模式，故本文主要总结和记录 Dart 常用语法，更多高级和生僻用法将在后面开发过程中不定期更新。 First of all在我们正式接触 Dart 语法之前，需要铭记以下内容，这将会对后续 Dart 语法的学习、理解和应用有很大帮助： 万物皆对象， 每个对象都是一个类的实例。在 Dart 中，甚至连数字、方法和 null 都是对象，并且所有的对象都继承于 Object 类。 尽管 Dart 语言是一种强类型语言，但你在类型声明时仍然可以不指定类型，因为 Dart 可以自动进行类型推断。如在代码 var number = 5; 中，number 变量的类型就被推断为 int，当你并不想显式地声明类型时，你可以使用特有的类型 dynamic 来标识。 Dart 语言同样支持泛型，如 List&lt;int&gt;、List&lt;dynamic&gt;（同 Java 中的 List&lt;Object&gt;）。 Dart 语言支持顶级方法（即不与类绑定的方法，如上的 main 方法），以及绑定类和实例的方法（分别对应静态方法和实例方法），而且还支持方法嵌套（同 Python 和 JS）。 同样，Dart 还支持顶级变量，以及在类中定义的变量（如静态变量和实例变量）。 和 Java 不同的是，Dart 没有 public、 protected 以及 private 关键字。它通过给变量或者方法名加上 _ 前缀来将其标识为私有域。 变量你可以通过 var 或者特定的类型来修饰变量，如果变量的类型不是固定的，也可以通过 dynamic 或者 Object 来修饰。如： 123456// 类型推断var name = 'Bob';// 指定类型String name = 'Bob';// 类型不局限于stringdynamic name = 'Bob'; 默认值Dart 中声明时如果未初始化，会被自动初始化为null： 12int lineCount;assert(lineCount == null); 注：assert 只在开发环境有效，在实际的生产环境无效。 final 与 constfinal 和 const 标识该变量只能被赋值一次，区别在于 final 是运行时赋值，const 是编译时赋值。 123final String nickname = 'Jack';// final修饰时, 可省略类型声明final name = 'Jack'; const不仅可以用来声明变量，还能用来创建常量值，如： 12345678// 此时不能在对列表a进行更新操作var a = const [1, 2];// 注意以下 const 修饰的区别var foo = const [];const baz = []; // Equivalent to `const []`...foo = [1, 2, 3]; // Was const []baz = [42]; // Error: Constant variables can't be assigned a value. 数据类型Dart 语言支持的数据类型与 Java 类似，但也有所不同，下面我们来按照“求同存异”的法则来分别认识它们。 数字类型Dart 中的数字类型只有两种：Int 和 double。与 Java 不同的是，它并没有提供 float 类型。例如，我们可以通过以下方式来定义数字： 123456// 定义整型var x = 123;var hex = 0xDEADBEEF;// 定义双精度类型var y = 1.199;var exponents = 1.42e5; 再来看下常用的数据转换该如何执行： 123456789101112131415// String -&gt; intvar a = int.parse('1');assert(a == 1);// String -&gt; doublevar b = double.parse('1.1');assert(b == 1.1);// int -&gt; StringString c = 1.toString();assert(c == '1');// double -&gt; StringString d = 3.14159.toStringAsFixed(2);assert(d == '3.14'); int 类型可以执行传统的按位移位( &lt;&lt;，&gt;&gt; )，AND( &amp; )和OR( | )运算符，如： 123assert((3 &lt;&lt; 1) == 6); // 0011 &lt;&lt; 1 == 0110assert((3 &gt;&gt; 1) == 1); // 0011 &gt;&gt; 1 == 0001assert((3 | 4) == 7); // 0011 | 0100 == 0111 字符串类型字符串的声明可以通过单引号或者双引号来引入： 1234var s1 = 'Single quotes work well for string literals.';var s2 = \"Double quotes work just as well.\";var s3 = 'It\\'s easy to escape the string delimiter.';var s4 = \"It's even easier to use the other delimiter.\"; 字符串拼接可以通过 + 或者 换行 来实现，如： 123456var a = '123' + '456'var b = '123' '456';assert(a == b)print(a);// Out: 123456 另外，可以通过三重引号来修饰多行字符串（维持特定格式）： 1234567var s1 = '''You can createmulti-line strings like this one.''';var s2 = \"\"\"This is also amulti-line string.\"\"\"; 布尔类型Dart 中的 bool 类型可以通过 if-else 或者是 assert 来检查，如： 123456789101112131415// Check for an empty string.var fullName = '';assert(fullName.isEmpty);// Check for zero.var hitPoints = 0;assert(hitPoints &lt;= 0);// Check for null.var unicorn;assert(unicorn == null);// Check for NaN.var iMeantToDoThis = 0 / 0;assert(iMeantToDoThis.isNaN); 数组类型在 Dart 语言中，数组即列表，列表即数组。 123456789void main() { var list = [1, 2, 3]; list.add(4); list.remove(3); list[1] = 5; var last = list[list.length - 1]; print('list is $list'); print('last is $last');} 另外，你可以通过 … 或者 ...?（避免空异常） 来批量插入多个元素： 12345var list1 = [1, 2, 3];var list2 = [0, ...list1];var list3;var list24 = [0, ...?list3]; 除此以外，还可以通过 if 或者 for 条件运算符来插入元素： 12345678910111213var nav = [ 'Home', 'Furniture', 'Plants', if (promoActive) 'Outlet'];var listOfInts = [1, 2, 3];var listOfStrings = [ '#0', for (var i in listOfInts) '#$i'];assert(listOfStrings[1] == '#1'); Set 和 MapDart中的Set是无序的唯一项的集合。要创建一个空集合，有以下两种方式： 123var names = &lt;String&gt;{};Set&lt;String&gt; names = {}; // This works, too.// var names = {}; // Creates a map, not a set. 通过以下方式创建常量 Set： 12345678final constantSet = const { 'fluorine', 'chlorine', 'bromine', 'iodine', 'astatine',};// constantSet.add('helium'); // Uncommenting this causes an error. 至于 Map 存储的是键值对数据，key 和 value 可以是任何类型。可以通过以下方式创建一个 Map： 123456789101112var gifts = Map();gifts['first'] = 'partridge';gifts['second'] = 'turtledoves';gifts['fifth'] = 'golden rings';// 或者通过以下方式var gifts = { // Key: Value 'first': 'partridge', 'second': 'turtledoves', 'fifth': 'golden rings'}; 函数Dart 是一门完全面向对象的语言，即使它的函数也是一个对象，并且有自己的类型—— Function。这就意味着函数可以被赋值为一个变量，或者作为一个参数在其他函数之间传递。 对于只包含一个表达式的方法体，你也可以使用 =&gt; 的简写形式，如： 123456void say() { print('123');}// 该写法与以上有同样效果void say2() =&gt; print('123'); 此外，函数同样支持类型推断，如： 1234bool isNoble(int atomicNumber) =&gt; _nobleGases[atomicNumber] != null;// 与下面的效果一样isNoble(atomicNumber) =&gt; _nobleGases[atomicNumber] != null; 可选参数与 kotlin 语言类似，Dart 的 函数同样支持可选参数这一功能，主要分为命名可选参数和位置可选参数，它们不能在一个函数中同时使用。但它们都支持默认参数设置。 命名可选参数 命名可选参数通过花括号 {} 来指定可选的命名参数，如： 1234567void main() { hello(name: 'Tom');}void hello({@required String name='Jack', int age=18}) { print('Hello, my name is $name, i\\'m $age years old.');} 我们可以为命名可选参数设置默认值，在使用的时候如果不指定该可选参数的值，那么它就会自动使用默认值。另外，我们可以通过 @required 来标注那些不想被忽略的参数。 位置可选参数 顾名思义，可选位置参数就允许我们在使用某个函数时可以忽略某个参数，如： 1234567891011void main() { sayHello('Tom', 19);}void sayHello(String name, int age, [String hobby = null]) { var result = 'Hello, my name is $name, i\\'m $age years old'; if (hobby != null) { result += ', my bobby is $hobby.'; } print(result);} 匿名函数不管什么语言，好像都能看到匿名函数的身影，我们可以通过以下方式来简单声明一个匿名函数： 12345var loge = (msg) =&gt; Logger.print(Logger.Error, msg);void main() { loge(\"there has some errors\");} Dart 中 list 就提供了匿名函数 —— forEach，如： 1234var list = ['apples', 'bananas', 'oranges'];list.forEach((item) { print('${list.indexOf(item)}: $item');}); 常用操作符Dart 提供了很多功能强大的操作符，这里列举几个常用的： 类型判断 如：**is** 相当于 Java 中的 instanceof 整除 如：**a ~/ b** 等价于 (a /b) as int 非空调用 如：**a?.b** 相当于 a == null ? null : a.b 三目运算 如：**a??b** 相当于 a == null ? b : a 三目赋值运算 如：**a ??= b** 相当于 a = a == null ? b : a 类型转换 如：**a as int** 相当于 Java 中的 (int) a 级联操作符 级联操作符用**..** 来表示，主要用来对一个对象进行连续操作，有点类似 kotlin 中的 apply 和 let，如： 12345678910var button = Button(this);button.text = 'Confirm';button.color = Color.parse(\"#f3f355\");button.onClick.listen((v) =&gt; toast('Confirmed'));// 等价于下面写法Button(this) ..text = 'Confirm' // Use its members. ..color = Color.parse(\"#f3f355\") ..onClick.listen((v) =&gt; toast('Confirmed')); 异常处理抛异常在 Dart 中可以抛出非空对象（不仅仅是 Exception 或 Error）作为异常。抛出异常的方式很简单，只需要这样： 12345throw FormatException('Expected at least 1 section');throw 'Out of llamas!';void distanceTo(Point other) =&gt; throw UnimplementedError(); 捕获异常我们可以通过 try-on 来捕获某个特定异常，如： 12345try { breedMoreLlamas();} on OutOfLlamasException { buyMoreLlamas();} 当然，你可以抛出多个类型的 Exception，但是由第一个 catch 到的分句来处理如果 catch 分句没有指定类型，那么它可以处理任何类型的异常： 1234567try { throw 'This a Exception!'; } on Exception catch(e) { print('Unknown exception: $e'); } catch(e) { print('Unknown type: $e'); } 无论是否发生异常，如果想要执行某段代码，可以通过 finally 实现： 1234567try { throw 'This a Exception!'; } catch(e) { // 如果去掉 catch 语句，那么异常将会在finally代码块之后传递。 print('Catch Exception: $e'); } finally { print('Close'); } 类和对象Dart 中，所有的对象都是类的实例，并且所有的类都是 Object 的子类。 类的定义和构造函数类的定义用 class 关键字，如果未显式定义构造函数，会默认一个空的构造函数，这一点与 Java 不谋而合。另外，Dart 还提供 命名构造函数这一功能，格式为：Class.costructorName(var params)。这种用法在某些场景下很实用，比如： 1234567891011121314151617class Person{ String name; int age; bool sex; String hobby; Person(this.name, this.age, this.sex, this.hobby); /// 命名构造函数 Person.fromJson(Map json){ print(\"Person constructor...\"); this.name = json['name']; this.age = json['age']; this.sex = json['sex']; this.hobby = json['hobby']; }} 通过命名构造函数，我就可以直接通过多种方式来生成当前类的实例，这里通过 Json 格式数据生成 Person 对象。另外，如果构造函数只是简单的参数传递，也可以直接在构造函数后加 : 来对参数进行赋值，多个参数可通过 , 相连： 123456789101112131415161718class Point { num x; num y; num z; Point(this.x, this.y, z) { //第一个值传递给this.x，第二个值传递给this.y this.z = z; } Point.fromeList(var list): //命名构造函数，格式为Class.name(var param) x = list[0], y = list[1], z = list[2]{//使用冒号初始化变量 } //当然，上面句你也可以简写为： //Point.fromeList(var list): this(list[0], list[1], list[2]); String toString() =&gt; 'x:$x y:$y z:$z';} 如果你要创建一个不可变的对象，你可以定义编译时常量对象需要在构造函数前加 const： 123456class ImmutablePoint { final num x; final num y; const ImmutablePoint(this.x, this.y); // 常量构造函数 static final ImmutablePoint origin = const ImmutablePoint(0, 0); // 创建一个常量对象不能用new，要用const} 属性访问器即我们常说的 Setter/Getter，主要是用来读写一个属性的方法。每个字段都对应一个隐式的 Getter 和 Setter ，但是调用的时候是 obj.name，而不是 obj.name()。当然，你可以通过 get 和 set 关键字扩展功能来实现自己的 Setter/Getter ， 如果字段为 final 或者 const 的话，那么它只能有一个 getter 方法。如： 123456789101112131415161718class Rectangle { num left, top, width, height; Rectangle(this.left, this.top, this.width, this.height); // Define two calculated properties: right and bottom. num get right =&gt; left + width; set right(num value) =&gt; left = value - width; num get bottom =&gt; top + height; set bottom(num value) =&gt; top = value - height;}void main() { var rect = Rectangle(3, 4, 20, 15); assert(rect.left == 3); rect.right = 12; assert(rect.left == -8);} 工厂构造函数并不是任何时候我们都需要创建一个新的对象，如：可以返回一个已经缓存好的对象或者该类的子类对象。我们以返回该类的一个缓存对象为例： 1234567891011121314151617181920class Logger { final String name; bool mute = false; // _cache is library-private, thanks to // the _ in front of its name. static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;{}; factory Logger(String name) { return _cache.putIfAbsent( name, () =&gt; Logger._internal(name)); } Logger._internal(this.name); void log(String msg) { if (!mute) print(msg); }} 注意：factory 构造函数不能通过 this 关键字来获取类的成员。 抽象类Dart 中并没有 interface 关键字，只有 abstract 来修饰”抽象类”，但是，这里的抽象类既可以被继承（extends），也可以被实现（implements）。如： 12345678910111213141516171819202122232425abstract class Person { // 可以不用 abstract 修饰，如果加上 abstract 的话 Person 不能被实例化 String greet(who); }class Student implements Person { String name; Student(this.name); String greet(who) =&gt; 'Student: I am $name!'; } class Teacher implements Person { String name; Teacher(this.name); String greet(who) =&gt; 'Teacher: I am $name!'; } void main() { Person student = new Student('Wang'); Person teacher = new Teacher('Lee'); print( student.greet('Chen')); print(teacher.greet('Chen')); } 同样地，Dart 中的类是单继承，多实现。这里使用的 implements 后，子类 Student 无法去访问父类 Persion 中的变量，但是抽象方法必须显式实现。相反，如果使用 extends 继承，子类就可以直接使用父类的非私有变量，倘若父类不是抽象类，那么子类同样不需要显式实现里面方法。如： 12345678910111213141516171819202122232425// A person. The implicit interface contains greet().class Person { // In the interface, but visible only in this library. final _name; // Not in the interface, since this is a constructor. Person(this._name); // In the interface. String greet(String who) =&gt; 'Hello, $who. I am $_name.';}// An implementation of the Person interface.class Impostor implements Person { get _name =&gt; ''; String greet(String who) =&gt; 'Hi $who. Do you know who I am?';}String greetBob(Person person) =&gt; person.greet('Bob');void main() { print(greetBob(Person('Kathy'))); print(greetBob(Impostor()));} 运算符重载以下的运算符支持重载功能： | &lt; | + | | | [] || —- | —- | —- | —- || &gt; | / | ^ | []= || &lt;= | ~/ | &amp; | ~ || &gt;= | * | &lt;&lt; | == || – | % | &gt;&gt; | | 这一点与 kotlin 语言中的运算符重载功能类似。我们以下面这个表示平面向量的类为例，为它增加两个向量相加和相减功能： 12345678910111213141516171819class Vector { final int x, y; Vector(this.x, this.y); Vector operator +(Vector v) =&gt; Vector(x + v.x, y + v.y); Vector operator -(Vector v) =&gt; Vector(x - v.x, y - v.y); // Operator == and hashCode not shown. For details, see note below. // ···}void main() { final v = Vector(2, 3); final w = Vector(2, 2); assert(v + w == Vector(4, 5)); assert(v - w == Vector(0, 1));} 枚举枚举的使用比较简单，和 Java 中的用法类似，声明的元素 index 值从 0 开始计算。 12345enum Color { red, green, blue }......assert(Color.red.index == 0);assert(Color.green.index == 1);assert(Color.blue.index == 2); Mixin 混合模式Mixins 是一种在多个类的层级中复用类中代码的一种方式。在类名后添加 with 关键字，并在 with 后紧跟类的标识符列表，通过逗号分隔，如： 1234567class Maestro extends Person with Musical, Aggressive, Demented { Maestro(String maestroName) { name = maestroName; canConduct = true; }} 如果想要声明一个混合模式，可以通过 mixin 来代替 class 定义一个不含构造方法的类： 123456789101112131415mixin Musical { bool canPlayPiano = false; bool canCompose = false; bool canConduct = false; void entertainMe() { if (canPlayPiano) { print('Playing piano'); } else if (canConduct) { print('Waving hands'); } else { print('Humming to self'); } }} 当然，我们也可以指定某个类来使用定义的混合模式，通过 on 关键字： 123mixin MusicalPerformer on Musician { // ···} 静态变量和函数定义静态变量和函数的方法与 Java 类似： 1234567891011121314151617181920class Point { num x, y; Point(this.x, this.y); static const originalPoint = Point(0, 0); static num distanceBetween(Point a, Point b) { var dx = a.x - b.x; var dy = a.y - b.y; return sqrt(dx * dx + dy * dy); }}// usagevoid main() { var a = Point(2, 2); var b = Point(4, 4); var distance = Point.distanceBetween(a, b); assert(2.8 &lt; distance &amp;&amp; distance &lt; 2.9); print(distance);} 异步操作Dart 是单线程执行的，如果进行 I/O 操作或进行耗时的操作时，程序可能会发生阻塞。Dart 库中的很多函数都返回 Future 或者 Stream 对象，这些方法都是异步执行的，它们可以在建立一个耗时操作之后返回，而无需等待耗时操作执行完成。 我们可以通过两种方式来实现异步操作： 通过 async 和 await 实现 借助于 Future API 来实现 async 和 await通过 async 和 await 关键字，我们可以轻松实现异步操作。要使用 await，必须要将函数用 async 修饰，同时函数会返回一个 Future 对象。简单用法如下： 1234567Future checkVersion() async { try { version = await lookUpVersion(); } catch (e) { // React to inability to look up the version }} 生成器 *同步生成器 — sync** 值得注意的是，同步生成器会返回 Iterable 对象： 1234Iterable&lt;int&gt; naturalsTo(int n) sync* { int k = 0; while (k &lt; n) yield k++;} *异步生成器 — async** 异步生成器返回 Stream 对象： 1234Stream&lt;int&gt; asynchronousNaturalsTo(int n) async* { int k = 0; while (k &lt; n) yield k++;} *yield** 通过 yield* 在递归中提升性能： 123456Iterable&lt;int&gt; naturalsDownFrom(int n) sync* { if (n &gt; 0) { yield n; yield* naturalsDownFrom(n - 1); }} 将类对象作为函数调用Dart 允许我们将一个类的对象作为函数来调用，只需要实现 call() 函数即可： 123456789class WannabeFunction { call(String a, String b, String c) =&gt; '$a $b $c!';}main() { var wf = new WannabeFunction(); var out = wf(\"Hi\",\"there,\",\"gang\"); print('$out');} 未完待续 此文只是 Dart 征程的一个起点，亦是 Flutter 中的一块基石，后续还有更多进阶用法和细节 API 等着我们去挖掘，keep learning！","link":"/2019/08/20/dart-learning/"},{"title":"Flutter 之 AppBar 这样的骚操作你知道吗？","text":"好久不见了，这阵子在忙公司的项目，加班比较严重，这周终于抽了点时间来学习一下新技术。由于去年九月份在上海参加过 Google 举办的 Google develop days， 受益颇多，特别在其目前正在大力热推的 Flutter 框架。相比于目前热门的跨平台框架 React Native，Flutter在 UI 绘制以及性能方便不遑多让。因此，这款 app 打算基于 Dart 语言，并采用 Flutter 框架来完成。 花了大概几天时间熟悉了下 Dart 语法和 Flutter 基本组成控件，就开始摸索着做一个练手项目。AppBar 想必大家都用过，当其处于启动页面时是隐藏 leading 的，而处于其他页面时左边默认携带返回按钮。目前，我们的需求是：首页的 AppBar 最左边为用户头像，点击用户头像可以自动打开左侧抽屉栏。 最终效果图如下所示： 初学者一开始总是痛苦的，还好，解决问题的途径“万变不离其宗”。我们先来查看一下 Flutter 官方文档 发现，要使用 AppBar来操作页面，决定其左边点击事件的属性就是 leading ： 12345678910111213141516171819AppBar({Key key,Widget leading,bool automaticallyImplyLeading: true,Widget title,List&lt;Widget&gt; actions,Widget flexibleSpace,PreferredSizeWidget bottom,double elevation,Color backgroundColor,Brightness brightness,IconThemeData iconTheme,TextTheme textTheme,bool primary: true,bool centerTitle,double titleSpacing: NavigationToolbar.kMiddleSpacing,double toolbarOpacity: 1.0,double bottomOpacity: 1.0}) 可以看到，我们 AppBar 中的 leading 属性是一个 Widget 类型，那么它接收的参数范围就很广了，换句话说，我们可以直接将一个按钮传递给它，并在 onPressed 方法中处理左边侧滑栏的开启和关闭状态。👌，有思路了咱们久开始试验一下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950final GlobalKey&lt;ScaffoldState&gt; _scaffoldKey = new GlobalKey();@override Widget build(BuildContext context) { return new DefaultTabController( length: _pages.length, child: new Scaffold( key: _scaffoldKey, appBar: new AppBar( /// 第一种方式 /// 通过可监听点击的IconButton传入widget， /// 并在onPressed中处理drawer开启，借助于GlobalKey leading: new IconButton( icon: new Container( padding: EdgeInsets.all(3.0), child: new CircleAvatar( radius: 30.0, backgroundImage: AssetImage(&quot;assets/images/moosphon_logo.jpeg&quot;) ), ), onPressed: (){ _scaffoldKey.currentState.openDrawer(); }, ), centerTitle: true, title: new TabBar( isScrollable: true, labelPadding: EdgeInsets.all(14), indicatorSize: TabBarIndicatorSize.label, indicatorColor: Colors.white, tabs: _titles.map((String title) =&gt; new Tab(text: title)).toList() ), actions: &lt;Widget&gt;[ new IconButton( icon: new Icon(Icons.search), tooltip: '搜索', onPressed: (){ NavigatorUtil.intentToPage(context, new SearchPage(), pageName: &quot;SearchPage&quot;); } ) ], ), body: new TabBindingView(), drawer: new Drawer( child: new HomeLeftDrawerPage(), ), ) ); } 为了不影响篇幅，这里我只贴了关键代码，至于 Drawer 用法相信大家没什么问题，这里我们给 AppBar 的leading 参数传了一个 IconButton 控件，里面我还实现了圆形头像。这样一来，我们的用户头像就可以被点击了响应了，接下来我们需要处理头像点击事件与 Drawer 的联动性了。这里我们通过设置 GlobalKey 来让 Scaffold 容器获取到其内部的 Drawer 组件，进而控制它的开闭，这样，我们就已经可以通过点击自定义的用户头像来开启左边侧滑栏啦😄。 细心的小伙伴一定会发现，上面的代码中我注释这只是第一种实现方式，难道还有第二种实现方式？哈哈，没错，的确还有第二种思路。其实，通过查看 AppBar 的源码，我们可以发现：AppBar内部已经自动实现了 AppBar 的 leading 与 Drawer 抽屉栏的关联： 12345678910111213141516171819Widget leading = widget.leading; if (leading == null &amp;&amp; widget.automaticallyImplyLeading) { if (hasDrawer) { leading = IconButton( icon: const Icon(Icons.menu), onPressed: _handleDrawerButton, tooltip: MaterialLocalizations.of(context).openAppDrawerTooltip, ); } else { if (canPop) leading = useCloseButton ? const CloseButton() : const BackButton(); } } if (leading != null) { leading = ConstrainedBox( constraints: const BoxConstraints.tightFor(width: _kLeadingWidth), child: leading, ); } 由于代码较多，这里我只放上了 build 方法中关于 leading 部分的关键代码，通过分析我们可以发现： leading 如果 为空并且 automaticallyImplyLeading 属性为true，那么就会自动推断出 leading 的 Widget 的类型和用途，另外如果当前 Scaffold 中存在 Drawer ，则会自动创建一个 IconButton 作为leading 使用，同时它的点击事件中处理了与 Drawer 抽屉栏的关联事件，无需开发者再处理。也就是说，在这种情况下，如果我们自定义了 leading （例如当前我们给它传的是用户的头像 Widget ），那么 leading 就无法自动关联 Drawer ，也就是说关联 Drawer 的这部分代码需要开发者自行实现。 如果 leading 不为空呢？并且 automaticallyImplyLeading 开关关闭，那么 leading 的空间就会被 title 给占据。 说了这么多，最终的结论是：如果我们想要自定义 leading ,那么目前官方源码中 AppBar 中 leading 自动关联 Drawer 的处理我们没办法使用。如果我们非要用呢？那就只能修改源码啦： 123456789101112131415161718192021/// 注意，前方高能来袭，以下为修改的部分code Widget leading = widget.leading; if (/*leading == null &amp;&amp; */widget.automaticallyImplyLeading) { if (hasDrawer) { leading = IconButton( icon: /*const Icon(Icons.menu)*/ leading ?? Icon(Icons.home), // 如果leading指定了widget那么 onPressed: _handleDrawerButton, tooltip: MaterialLocalizations.of(context).openAppDrawerTooltip, ); } else { if (canPop) leading = useCloseButton ? const CloseButton() : const BackButton(); } } if (leading != null) { leading = ConstrainedBox( constraints: const BoxConstraints.tightFor(width: _kLeadingWidth), child: leading, ); } 铛铛铛铛～这就改好啦，改动的地方是不是很少？哈哈😄，其实只要把 leading 为空的限制条件去掉，并且可以传入我们自己定义的 Widget 就好啦！ 这样一来，我们就不用手动去处理 leading 与 Drawer 的关联事件，只需要交给系统帮我们完成就可以啦： 12345678910111213141516171819202122232425262728293031323334353637383940414243@override Widget build(BuildContext context) { return new DefaultTabController( length: _pages.length, child: new Scaffold( key: _scaffoldKey, appBar: new DrawerAutoBindingAppBar( /// 第二种方式 /// 通过修改[AppBar]源码来将普通widget作为icon传给IconButton /// 源码中已处理onPressed关联drawer事件，无需额外处理，详情见[DrawerAutoBindingAppBar] leading: new Container( padding: EdgeInsets.all(3.0), child: new CircleAvatar( radius: 30.0, backgroundImage: AssetImage(&quot;assets/images/moosphon_logo.jpeg&quot;) ) ), centerTitle: true, title: new TabBar( isScrollable: true, labelPadding: EdgeInsets.all(14), indicatorSize: TabBarIndicatorSize.label, indicatorColor: Colors.white, tabs: _titles.map((String title) =&gt; new Tab(text: title)).toList() ), actions: &lt;Widget&gt;[ new IconButton( icon: new Icon(Icons.search), tooltip: '搜索', onPressed: (){ NavigatorUtil.intentToPage(context, new SearchPage(), pageName: &quot;SearchPage&quot;); } ) ], ), body: new TabBindingView(), drawer: new Drawer( child: new HomeLeftDrawerPage(), ), ) ); } 代码就不多做解释了，效果是和之前一样的，好啦，这样我们就更加了解 AppBar 的用法以及 leading 的背后“小彩蛋”啦😁。 感谢大家的阅读，以后我将给大家带来更多好玩实用的应用型开发技巧，如果大家有任何建议，欢迎留言👏。 QQ群： 601924443 一起玩技术～","link":"/2019/03/01/flutter-appbar/"},{"title":"Google develop days 2018 之旅","text":"经过两天 Google Develop Day 之旅，强烈感受到谷歌的奉献精神，与国内其他大会不同，它更注重开发者和用户的意见，一直在为开发者提供便捷开发工具和接口的同时，也在为提高交互流畅性和用户体验度的道路上努力前进着。我将针对 Google 大会中对于开发者而言比较重要的几个部分，结合个人看法简单说明一下大会中的主要内容。 Android JetPackGoogle 在本次开发者盛会中，依旧将 Android 作为主要的分享主题，而 Android JetPack 也是作为本次 Android 分会馆中比较重要的一部分。正如本次大会介绍的那样，JetPack 作为 “Android开发加速器”，它是一系列的组件、工具和架构指南。主要从四个方面提升 Android 开发的效率： 架构： WorkManager：后台任务执行 Navigation：页面之间跳转 Paging：数据分页功能 Data Binding：数据绑定 Lifecycles：生命周期处理 LiveData：数据与UI实时更新 Room：数据缓存 ViewModel：UI与数据管理 行为： Slices：简化交互和操作 Download Manager：内置下载器 Media&amp;Playback：多媒体 Permissions：权限申请 Notifications：通知 Sharing：共享 界面： Fragment Layout Palette Animation &amp; Translations Auto，TV &amp; Wear Emoji 基础： Kotlin Extensions AppCompat Multidex Test JetPack也提供了向后兼容的特性，能让较低sdk版本的应用依旧可以享受这些工具组件带来的便利。 FireBase什么是 FireBase？FireBase 是一个云端数据存储平台，可以轻松实现数据的实时更新。它旨在轻松打造富有吸引力的app，帮助了解用户行为以及诊断和监控 app 的表现，然后根据用户的操作来定位用户范围。 ML Kit 将谷歌机器学习方面的成果带给移动应用开发者： 数据分析能力： 通过机器学习，并动态绑定训练模型，应用不需要升级就可以更新模型。 崩溃信息采集： 可以通过 Crashlytics 提供的 sdk 可以将应用的一些崩溃信息采集到FireBase上面。 更多： ​ FlutterFlutter 可以媲美原生的交互体验，相对于 react native 来说，绘制过程省去了一个环节，能够更加快速的渲染。同时也支持与原生 Android 和 iOS 业务功能的代码混编。 为什么使用 Flutter？ 可自定义的流畅页面 可同时在 Android 和 iOS 设备上进行原生编译 高效的开发工具，如 hot load(热重载) 响应式编程 各种快捷实用的插件（imagepicker，设置滤镜，社交平台分享等，比原生更加方便） ARCore应用场景： 购物、AR特效、游戏、社交 主要功能： 运动跟踪 ARCore 利用摄像头图像中的视觉差异特征并结合设备中惯性传感器的测量结果，估算设备的位置和方向。 光估测 ARCore 可以检测其环境光线的相关信息，并提供给定摄像头图像的平均光强度和色彩校正，达到能与周围环境相同的光照来照亮虚拟物体，提高它们的真实感。 环境理解 ARCore通过检测特征点来检测平面，并让这些平面可以由我们的应用来运作平面。 同时，ARCore可以通过云锚点将锚点和附近特征点发送至云端托管，然后可以与其他用户进行环境共享和交互。 TensorFlowTensorFlow 是目前世界上最热门的机器学习类开源框架。它可以让模型通过不断的机器学习来产生一套规则，来达到我们预期的效果，进而来处理大量数据，代替人工处理的成本。","link":"/2018/09/21/google-io-2018/"},{"title":"Android将library代码发布到jcenter","text":"作为一名Android开发者，日常开发工作中肯定会用到一些强大的第三方开源库，有了这些开源的帮助，开发工作可谓是如鱼得水。很多时候，我们自己写了一套代码，为了让别人体验到自己代码的便捷之处，通常我们需要将其部署到github，发布到jcenter，然后生成gradle代码供他人使用。网上对于这部分的教程很多，不管是通过gradle-bintray-plugin插件或者是bintray-release插件，实现流程几乎一致，但有些细节存在差异，最终都可以通过compile或者implemention引用。具体步骤可以参考以下两篇文章： 通过bintray-release插件发布：https://blog.csdn.net/lmj623565791/article/details/51148825 通过gradle-bintray-plugin插件发布：https://www.cnblogs.com/AbrahamCaiJin/p/7058147.html 当然，发布过程并不是百分百成功的，难免会遇到以下常见问题： 终端输入gradlew install命令后出现bash: gradlew: command not found问题： 该问题的原因一般是没有配置gradle的环境变量，我们可以将gradle所在位置复制到环境变量中去，windows较为简单，Mac比较特殊，这里特别说明一下，可以参考这篇文章：https://blog.csdn.net/u013424496/article/details/52684213 权限问题： 可能会遇到-bash: /Applications/Android Studio3.0.app/Contents/gradle/gradle-4.1/bin/gradle: Permission denied问题，一般是gradle权限引起的，我们可以在as终端输入： 12$ chmod +x gradle$ chmod +x gradle.bat 一般情况下，重新执行gradlew 命令就没问题了，如果还是不行，可以在gradlew xxx命令前加上./,如： 1234./gradlew clean build bintrayUpload -PbintrayUser=xxx -PbintrayKey=xxxxxxxxxxxxxxxxxxxxxx -PdryRun=false 执行jcenter发布命令时出现Execution failed for task ':library:bintrayUpload'. Bintray user cannot be empty!问题： 这种问题可能是user为空，没有设置，也可能是发布命令中间多了空格符合或者换行符号，不要从网上复制命令直接执行，最好先复制到文本编辑器查看格式是否正确。 library发布成功后，一定要记得先在jcenter个人仓库的项目页点击add to jcenter审核通过后才能使用compile和maven。 如果jcenter审核通过，可以通过compile....命令复制到gradle中编译一下，如果出现： 12Error:(32, 13) Failed to resolve: com.android.support:support-annotations:27.1.0 Install Repository and sync projectShow in File. 可以尝试在project到build.gradle文件中添加如下代码： 123456allprojects { repositories { maven { url &quot;https://maven.google.com&quot; } jcenter() }} 重新编一下看能否通过。 如果使用classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:xx'插件，发布到jcenter版本version必须通过library的gradle文件中定义： 12version = &quot;1.0.0&quot; 方可在jcenter正常显示版本号，否则会出现版本号未知的问题。 如果使用classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:xx插件，最终jcenter中的compile依赖项目名会自动使用你library的moudle名作为最终的项目名，如，我的library的moudle名为library，那么最终生成的compile代码会是： 1com.moos:library:1.0.0 因此，在发布之前，请务必确认好最终的名字。这里，强烈推荐使用classpath 'com.novoda:bintray-release:0.x.x'插件来进行jcenter发布操作，真的很方便！ 最后，如果你的library中有中文的注释，可能会有编码问题，可以在project的build.gradle文件中添加如下代码： 123456789allprojects { tasks.withType(Javadoc) { options{ encoding &quot;UTF-8&quot; charSet 'UTF-8' links &quot;http://docs.oracle.com/javase/8/docs/api&quot; } }} ​","link":"/2018/03/25/jcenter-publish/"},{"title":"Android 实现本地图片和视频选择器功能","text":"哈喽，大家好，好久不见了，很久没有更新 Android 方面的技术文章了，最近在忙公司的 AR 类的新产品，其中涉及到本地图片和视频的选择和上传功能。至于为什么不用系统提供的图片和视频选择器，原因你懂的，系统提供的选择器只能通过 Intent 方式去获取，这意味着需要离开当前页面前往系统的媒体库，选择完毕后在onActivityResult 方法中拿到结果。这显然存在很多弊端： UI的定制化很差 需要离开当前页面，体验不好 不同机型可能会出现各种问题 系统选择器并不支持多选功能 ​其实，我们最希望的是拿到手机中的图片和视频数据，至于UI的绘制和交互细节都由我们自己来定制。你说你想用 ListView 或者 RecyclerView 来展示所有图片和视频，ok，当然可以，那是你的自由！让我们先来看一下最终实现的效果图吧： 不要直接一看效果图以为还是前往的另一个页面，那和其他图片选择器有什么分别？客官先别急，这里的效果图只是为了美观而已，反正数据给你了，想怎么安排UI就看你们设计喵了😄～，比如可以这样： 看到这你可能会以为很复杂，其实不然，代码量很少，而且涉及到的核心知识点如：获取系统图片和视频数据、单选和多选功能，相信大家一看就明了。好了，喝口茶，且听我慢慢道来。 获取手机所有图片和视频数据一般地，获取手机内部图片和视频数据有两种方式：通过遍历文件夹获取图片和视频资源，或者通过ContentResolver来获取。虽然第一种方式拿到的图片比较齐全，但文件遍历操作过于耗时，这里我推荐采用第二种方式。ContentResolver即内容解析器，可以对ContentProvider中的数据库进行增删改查操作，其中主要包含联系人、短信、相册、视频、音频等一系列数据。我们来看看具体获取系统图片数据实现代码吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * &lt;pre&gt; * @author moosphon (about me: &lt;a&gt;https://github.com/Moosphan&lt;a/&gt;) * @date 2018/09/16 * @desc get all pictures of the phone. * &lt;pre/&gt; */fun getLocalPictures(mContext: Context?): List&lt;ImageMediaEntity&gt;? { val images = ArrayList&lt;ImageMediaEntity&gt;() val resolver = mContext?.contentResolver var cursor: Cursor? = null queryImageThumbnails(resolver!!, arrayOf(MediaStore.Images.Thumbnails.IMAGE_ID, MediaStore.Images.Thumbnails.DATA)) try { cursor = resolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, arrayOf(MediaStore.Images.ImageColumns.DATA, MediaStore.Images.ImageColumns._ID, MediaStore.Images.ImageColumns.SIZE, MediaStore.Images.ImageColumns.MIME_TYPE), null, null, null) return if (cursor == null || !cursor.moveToFirst()) { null } else { do { val picPath = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA)) val id = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media._ID)) val size = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.SIZE)) val mimeType = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.MIME_TYPE)) val image = ImageMediaEntity.Builder(id, picPath) .setMimeType(mimeType) .setSize(size) .setThumbnailPath(mThumbnailMap?.get(id)) .build() images.add(image) mThumbnailMap = null }while (cursor.moveToNext()) return images } } finally { if (cursor != null) { cursor.close() } }} /** * search for thumbnails for local images * * @author moosphon */ private fun queryImageThumbnails(cr: ContentResolver, projection: Array&lt;String&gt;) { var cur: Cursor? = null try { cur = MediaStore.Images.Thumbnails.queryMiniThumbnails(cr, MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI, MediaStore.Images.Thumbnails.MINI_KIND, projection) if (cur != null &amp;&amp; cur.moveToFirst()) { do { val imageId = cur.getString(cur.getColumnIndex(MediaStore.Images.Thumbnails.IMAGE_ID)) val imagePath = cur.getString(cur.getColumnIndex(MediaStore.Images.Thumbnails.DATA)) mThumbnailMap = mapOf(imageId to imagePath) } while (cur.moveToNext() &amp;&amp; !cur.isLast) } } finally { cur?.close() } } 可以通过代码看到，我们借助于 ContentResolver.query 方法来查询匹配的图片数据，我们可以设置需要获取的图片的数据字段，如 MediaStore.Images.ImageColumns.DATA 就表示图片存储的路径信息，其他的可以获取的信息还有图片ID、图片大小、图片类型等，大家可以参照代码去网上查看具体含义，这里不再赘述。此外，系统还为我们存储了图片以及视频的缩略图数据，我们为了提高图片加载速度，可以通过获取和展示缩略图的形式来增强体验效果。获取图片缩略图的方式采用系统自带的，也比较简单，大家可以自行查看一下文档。 另外，大家可能会发现 ImageMediaEntity 这个类，明白人应该很快就会知道这个数据类主要存储一些图片相关的数据。的确，这个是我个人封装的一层针对图片的数据类，而它还有个父类，名叫 BaseMediaEntity ,我们来看看里面都有些啥： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * base entity data for local media * * @author Moosphon */public abstract class BaseMediaEntity implements Parcelable{ protected enum TYPE{ IMAGE, VIDEO } protected String path; protected String id; protected String size; public Boolean isSelected = false; public BaseMediaEntity() { } public BaseMediaEntity(String path, String id) { this.path = path; this.id = id; } public BaseMediaEntity(Parcel in) { this.path = in.readString(); this.id = in.readString(); this.size = in.readString(); } public abstract TYPE getMediaType(); public String getPath() { return path; } public void setPath(String path) { this.path = path; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getSize() { return size; } public void setSize(String size) { this.size = size; } public Boolean getSelected() { return isSelected; } public void setSelected(Boolean selected) { isSelected = selected; } @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeString(this.path); dest.writeString(this.id); dest.writeString(this.size); }} 可以看到，这是我们抽离出的公共基类，因为图片和视频等多媒体数据都有公共的数据字段id、path和size，差异性由它的子类来实现就OK了。至于 ImageMediaEntity 和 VideoMediaEntity 具体代码就先省略不放了，影响篇幅长度，最后面会有完整的sample代码。 看完了本地图片数据的获取，自然而然就能知道视频数据也是采用相同的方式获取，没错，这里就直接上代码了，其实实现方式是一样的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * &lt;pre&gt; * @author moosphon (about me: &lt;a&gt;https://github.com/Moosphan&lt;a/&gt;) * @date 2018/09/16 * @desc get all videos of the phone. * &lt;pre/&gt; */fun getLocalVideos(mContext: Context?) : List&lt;VideoMediaEntity&gt;?{ val videos = ArrayList&lt;VideoMediaEntity&gt;() val resolver = mContext?.contentResolver var cursor: Cursor? = null try { cursor = resolver?.query(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, arrayOf(MediaStore.Images.ImageColumns.DATA, MediaStore.Video.Media._ID, MediaStore.Video.Media.DISPLAY_NAME, MediaStore.Video.Media.RESOLUTION, MediaStore.Video.Media.SIZE, MediaStore.Video.Media.DURATION, MediaStore.Video.Media.DATE_MODIFIED), MediaStore.Video.Media.MIME_TYPE + &quot;=?&quot;, arrayOf(&quot;video/mp4&quot;), null) return if (cursor == null || !cursor.moveToFirst()) { null } else { while (cursor.moveToNext()){ // video path val path = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DATA)) // video id val id = cursor.getLong(cursor.getColumnIndexOrThrow(MediaStore.Video.Media._ID)) // video display name val name = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DISPLAY_NAME)) // video resolution val resolution = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.RESOLUTION)) // video size val size = cursor.getLong(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.SIZE)) // video duration val duration = cursor.getLong(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DURATION)) val date = cursor.getLong(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DATE_MODIFIED)) val video = VideoMediaEntity.Builder(id.toString(), path) .setTitle(name) .setDateTaken(date.toString()) .setDuration(duration.toString()) .setSize(size.toString()) .build() videos.add(video) } return videos } } finally { if (cursor != null) { cursor.close() } }} 通过上面代码我们可以发现，这几乎和获取图片数据的代码一样啊，没错，是几乎一样，但留意的人会发现，这里我调用 ContentResolver.query 时多传了一个selection参数，它是query方法的第三个参数，主要用来设置一些查询的条件，已达到过滤功能，大家可以根据自己需要自行设置，这里我只是想拿到mp4格式的视频数据。还有人可能会问：为什么我这里没有获取视频的缩略图数据呢？系统虽为我们也提供了获取视频缩略图的方式，但是，并不是所有的视频都存在视频缩略图，这就造成你想加载视频的缩略图的时候会出现大片空白数据问题。同时，可能会有人想借助于其他方式获取，但主流的几种方式都比较耗时，不建议在正式项目中采用。其实，通过查看很多优秀的开源视频选择器框架发现，很多都采用了分批加载功能，比如手机中一共有一千个视频数据，如果一次性获取显然很耗时，而且体验不好，我们可以分批获取数据，每页100条限制，这就极大的节省了获取数据的时间，然后再在列表滑动到底部时加载下一批数据。这里我暂时使用的是 Glide 来加载我们的视频数据，后续会寻找更佳方案代替。 下面，我们来看看图片视频的多选、单选效果实现。用过 RecyclerView 和 CheckBox 组合的开发者都知道，RecyclerView复用性会导致 CheckBox 选择状态混乱，即onCheckChanged方法的“神秘回调”，解决方案也有很多种，网上有些方案没有解决问题的也有很多。常见的方案有：自定义 checkbox、通过 checkbox 的 onclick 事件来处理选中状态，adapter数据刷新或者 checkbox 每次选中前移除上次的选中事件等等，我只选两种进行简单说明。为了节省时间，我这里将实现图片多选和视频的单选功能，它们 checkbox 问题的处理各自采用不同的方式。 我们先来看看图片多选功能实现，前方高能，代码来袭： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * &lt;pre&gt; * author: moosphon * date: 2018/09/16 * desc: 本地视频的适配器 * &lt;pre/&gt; */class LocalImageAdapter: RecyclerView.Adapter&lt;LocalImageAdapter.LocalImageViewHolder&gt;() { lateinit var context: Context private var mSelectedPosition: Int = 0 var listener: OnLocalImageSelectListener? = null private lateinit var data: List&lt;ImageMediaEntity&gt; /** 存储选中的图片 */ private var chosenImages : HashMap&lt;Int, String&gt; = HashMap() /** 存储选中的状态 */ private var checkStates : HashMap&lt;Int, Boolean&gt; = HashMap() override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): LocalImageViewHolder { context = parent.context val view = LayoutInflater.from(parent.context).inflate(R.layout.rv_item_local_video_layout, parent, false) return LocalImageViewHolder(view) } override fun getItemCount(): Int { return data.size } override fun onBindViewHolder(holder: LocalImageViewHolder, position: Int) { val thumbnailImage: ImageView = holder.view.find(R.id.local_video_item_thumbnail) val checkBox: CheckBox = holder.view.find(R.id.local_video_item_cb) /** 通过map存储checkbox选中状态,放置rv复用机制导致的状态混乱状态 */ checkBox.setOnCheckedChangeListener(null) checkBox.isChecked = checkStates.containsKey(position) val options = RequestOptions() .diskCacheStrategy(DiskCacheStrategy.NONE) .error(R.mipmap.ic_launcher) .placeholder(R.mipmap.ic_launcher) Glide.with(context) .asBitmap() .load(data[position].thumbnailPath) .apply(options) .thumbnail(0.2f) .into(thumbnailImage) checkBox.setOnCheckedChangeListener{ _, isChecked -&gt; if (isChecked){ checkStates[position] = true // 将当前选中的图片存入map chosenImages[position] = data[position].path }else{ // 从选中列表中移除 checkStates.remove(position) chosenImages.remove(position) } if (listener != null){ val selectedImages = ArrayList&lt;String&gt;() for (v in chosenImages.values){ selectedImages.add(v) } listener!!.onImageSelect(holder.view, position, selectedImages) } } } fun setData(data: List&lt;ImageMediaEntity&gt;){ this.data = data for (i in 0 until data.size) { if (data[i].isSelected) { mSelectedPosition = i } } } class LocalImageViewHolder(val view: View) : RecyclerView.ViewHolder(view) /** 自定义的本地视频选择监听器 */ interface OnLocalImageSelectListener{ fun onImageSelect(view: View, position:Int, images: List&lt;String&gt;) }} 可以看到，我们这里通过 HashMap 存储已选中 CheckBox 的状态，并在 checkBox.setOnCheckedChangeListener 前移除上一次 CheckBox 的监听器，然后再在 onCheckChanged 方法中判断当前选中状态，如果选中，那么map存入 CheckCox 选中状态，否则移除当前位置的value数据，这样，就解决了 滑动RecyclerView 后 CheckBox 状态混乱问题。同时，我们用 Map 存储每个选中后的图片路径信息，然后在自己的回调中返回这些选中的图片，最后在 Activity 或者 Fragment 中展示就可以了。 实现了图片的多选效果，我们就来看看视频单选的实现吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * &lt;pre&gt; * author: moosphon * date: 2018/09/16 * desc: 本地视频的适配器 * &lt;pre/&gt; */class LocalVideoAdapter: RecyclerView.Adapter&lt;LocalVideoAdapter.LocalVideoViewHolder&gt;() { lateinit var context: Context private var mSelectedPosition: Int = -1 var listener: OnLocalVideoSelectListener? = null private lateinit var data: List&lt;VideoMediaEntity&gt; private var checkState: HashSet&lt;Int&gt; = HashSet() override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): LocalVideoViewHolder { context = parent.context val view = LayoutInflater.from(parent.context).inflate(R.layout.rv_item_local_video_layout, parent, false) return LocalVideoViewHolder(view) } override fun getItemCount(): Int { return data.size } override fun onBindViewHolder(holder: LocalVideoViewHolder, position: Int) { val thumbnailImage: ImageView = holder.view.find(R.id.local_video_item_thumbnail) val checkBox: CheckBox = holder.view.find(R.id.local_video_item_cb) checkBox.isChecked = checkState.contains(position) val options = RequestOptions() .diskCacheStrategy(DiskCacheStrategy.NONE) .error(R.mipmap.ic_launcher) .placeholder(R.mipmap.ic_launcher) Glide.with(context) .asBitmap() .load(data[position].path) .apply(options) .thumbnail(0.2f) .into(thumbnailImage) checkBox.setOnClickListener { if (mSelectedPosition!=position){ //先取消上个item的勾选状态 checkState.remove(mSelectedPosition) notifyItemChanged(mSelectedPosition) //设置新Item的勾选状态 mSelectedPosition = position checkState.add(mSelectedPosition) notifyItemChanged(mSelectedPosition) }else if(checkBox.isChecked){ checkState.add(position) }else if(!checkBox.isChecked){ checkState.remove(position) } if (listener != null){ listener!!.onVideoSelect(holder.view, position) } } } fun setData(data: List&lt;VideoMediaEntity&gt;){ this.data = data for (i in 0 until data.size) { if (data[i].isSelected) { mSelectedPosition = i } } } class LocalVideoViewHolder(val view: View) : RecyclerView.ViewHolder(view) /** 自定义的本地视频选择监听器 */ interface OnLocalVideoSelectListener{ fun onVideoSelect(view:View, position:Int) }} 此处主要利用 checkBox.setOnClickListener 以及 HashSet 来处理单选事件，先通过一个mSelectedPosition字段来保存当前选中的 Checkbox 的位置，然后在点击事件中进行分情况处理，由于这里是单选，所以在设置新的选中状态前移除上一次的CheckBox 选中状态。代码没什么复杂的，主要是一种思路，具体逻辑理清楚就好了，这里大家可以自己琢磨一下。 Github传送门：https://github.com/Moosphan/LocalVideoImage-selector 欢迎大家提出改进意见或者帮助我一起完善下去～","link":"/2018/09/22/image-selector/"},{"title":"Android Kotlin 快速开发之 Anko 魔法","text":"众所周知，目前 kotlin 已经作为 Google 官方推荐的 Android 开发语言，目前 GitHub 上面关于 kotlin 的项目已然呈现一片势不可挡的热度。作为一名 Android 开发者，学好 koltin 已经成为我们必须 get 的技能，而想要在工作中使用 kotlin 快速开发项目，Anko 无疑成为首选利器！ ​ 那么 Anko 到底是什么呢？可以为我们做哪些事情呢？ ​ Anko 是一款 kotlin 的扩展库，可以帮助我们更加简单、快速的开发 Android 应用。它能够让我们的代码更加洁净易读，并且忘记 Java 那种繁琐、复杂的编程方式。Anko 库主要分为以下几个部分： Anko Commons（通用扩展库）：一个轻量级的帮助库，可以让我们使用少量代码就可以轻松、快速使用 Intent、Dialog、 Log、 Toast 、 SnackBar 等常用功能。 Anko Layouts（布局扩展库）：一种快速、类型安全的方式去通过代码动态编写 Android 布局，有点类似 swift 中的方式。 Anko SQLite（SQLite扩展库）：一个针对Android的SQLite查询DSL和解析器的集合。 Anko Coroutines（kotlin协程扩展库）：基于 kotlinx.coroutines 库的扩展 由于一篇文章篇幅较长，故分为上下两部分来讲解，上篇主要介绍Anko Commons扩展库的相关功能。 ###Anko Commons 该库主要包含一些常见功能的扩展和封装，常见的有 dialogs 、intent、toast、snackBar 等，下面我们先来看看具体如何使用它们。首先需要依赖一下扩展包： 12// Anko Commonsimplementation &quot;org.jetbrains.anko:anko-commons:0.10.8&quot; ####Toasts Toast（吐司）算是我们最常用的功能，大家项目中或多或少都对其进行了一层封装，anko 中使用也很方便，只需要这样： 123toast(&quot;login success!&quot;)toast(R.string.login_success)longToast(&quot;Wow, nice work!&quot;) SnackBarsSnackBar 是Android5.0后 material design 中常用控件之一，它的出现和 Toast 差不多，为了给用户带来一些提示性信息，具体特点可以自行查阅相关文章。通过 Anko 我们只需要通过以下方式就可以直接体会到它的魅力： 1234view.snackbar(&quot;login success!&quot;)view.snackbar(R.string.login_success)view.longSnackbar(&quot;Wow, nice work!&quot;)view.snackbar(&quot;Action, reaction&quot;, &quot;Click me!&quot;) { doSomeThing() } DialogsDialog 是我们最常用的功能之一，它较为醒目，层级较高，其中最常用的当属 AlertDialog 了，通常我们这样使用： 1234567AlertDialog.Builder(this) .setPositiveButton(R.string.btn_allow_text) { _, _ -&gt; request.proceed() } .setNegativeButton(R.string.btn_deny_text) { _, _ -&gt; request.cancel() } .setCancelable(false) .setTitle(&quot;提示&quot;) .setMessage(&quot;我们需要请求使用您手机的部分权限，是否同意？&quot;) .show() 虽然是链式调用，但使用较多时依旧很麻烦，通过 Anko，我们可以直接通过下面代码来实现相同功能： 123456789alert(&quot;我们需要请求使用您手机的部分权限，是否同意？&quot;, &quot;提示&quot;){ yesButton { request.proceed() } noButton { request.cancel() }}.show() 比较下来，是不是很方便，节省了一多半的代码量。 当然，很多时候我们需要使用 AppCompat 下的 AlertDialog ，因为它提供了向下兼容的特性，保证在不同Android系统上尽量达到相同效果，这时我们需要依赖针对 AppCompat 的扩展包： 12// Appcompat-v7 (only Anko Commons)implementation &quot;org.jetbrains.anko:anko-appcompat-v7-commons:0.10.8&quot; 然后我就可以直接这样使用 AppCompat 下的 AlertDialog 了： 123456789alert(Appcompat, &quot;我们需要请求使用您手机的部分权限，是否同意？&quot;, &quot;提示&quot;){ yesButton { request.proceed() } noButton { request.cancel() }}.show() 如果我们想自定义弹窗的布局呢？别着急，Anko 同样为我们提供方式实现： 12345alert { customView { editText() }}.show() 什么？这就完了？没错，如果你想在弹窗里放一个输入框，这样就实现了。你肯定会好奇，怎么设置layout呢？先别急，这是anko为我们提供的另外一个强大功能，这块将在后面说到，先卖卖关子😁。 你可能又会突然想起来，AlertDialog 还为我们提供了列表单选功能呢，哈哈，anko 同样为我们考虑到了，我们只需要这样写： 1234567891011121314alert(Appcompat, &quot;Please select your country where you come from&quot;, &quot;Tips&quot;){ yesButton { } noButton { } val countries = listOf(&quot;Russia&quot;, &quot;USA&quot;, &quot;Japan&quot;, &quot;Australia&quot;) selector(&quot;Where are you from?&quot;, countries) { _, i -&gt; toast(&quot;So you're living in ${countries[i]}, right?&quot;) } }.show() 怎么样，是不是也很方便？只需要在alert域中通过 selector 实现就可以了。 另外，Anko 同样为我们提供了快速使用 ProgressDialog 方式，例如： 1val dialog = progressDialog(message = &quot;Please wait…&quot;, title = &quot;Tips&quot;) ####Intent 开发过 Android 都知道，Intent 是我们构建页面时必不可少的工具，它是四大组件通信的”信使”。一般地，我们在项目中这样使用： 1234val intent = Intent(this, SomeOtherActivity::class.java)intent.putExtra(&quot;id&quot;, 5)intent.setFlag(Intent.FLAG_ACTIVITY_SINGLE_TOP)startActivity(intent) 而我们通过 Anko 就完全可以通过一行代码实现： 1startActivity(intentFor&lt;SomeOtherActivity&gt;(&quot;id&quot; to 5).singleTop()) 怎么样，是不是超级方便？而且它给我们提供的链式调用，很清晰，此外，它还为我们提供了 Intent 常用功能，例如拨打电话、发邮件、分享等等： Goal Solution Make a call makeCall(number) without tel: Send a text sendSMS(number, [text]) without sms: Browse the web browse(url) Share some text share(text, [subject]) Send a email email(email, [subject], [text]) LogLog 日志功能我们平时应该说用的最多了，通常用来打印一些关键信息，测试一些关键逻辑正确性。Anko 为我们提供了自己的扩展封装，使用起来很方便： 1234567class SomeActivity : Activity(), AnkoLogger { private fun someMethod() { info(&quot;London is the capital of Great Britain&quot;) debug(5) // .toString() method will be executed warn(null) // &quot;null&quot; will be printed }} 或者不想通过实现接口方式，可以借助以下方式： 12345678class SomeActivity : Activity() { private val log = AnkoLogger(this.javaClass) private val logWithASpecificTag = AnkoLogger(&quot;my_tag&quot;) private fun someMethod() { log.warning(&quot;Big brother is watching you!&quot;) }} 对应的日志打印方法如下： android.util.Log AnkoLogger v() verbose() d() debug() i() info() w() warn() e() error() wtf() wtf() ####其他特殊扩展功能 Colors Anko为我们提供了两种针对色彩的扩展功能来让我们的代码更佳易读，如： Function Result 0xff0000.opaque 不透明的红色 0x99.gray.opaque 不透明的#999999（灰色） Dimensions 你可以指定 dimension 的 dip (density-independent pixels) 或 sp (scale-independent pixels)值: dip(dipValue) 或 sp(spValue). 注意 textSize属性默认接受sp (textSize = 16f). 使用 px2dip 和 px2sp 相互转换. applyRecursively applyRecursively 方法将lambda表达式应用于传递 View 的本身，如果它是 ViewGroup ，则递归到它的每个字节点，例如这样： 1234567891011121314verticalLayout { editText { hint = &quot;Name&quot; } editText { hint = &quot;Password&quot; } button(&quot;login now&quot;) { onClick { toast(&quot;login success!&quot;) } }}.applyRecursively { view -&gt; when(view) { is EditText -&gt; view.textSize = 20f is Button -&gt; view.text = &quot;点我呀～&quot;}} Anko Commons 基础扩展库已经介绍的差不多了，怎么样？看完 Anko 施加在 Android 上的“魔法”，是不是迫不及待地想去大展身手了？原来代码还可以这样简洁明了，方便易用。哈哈，Android快速开发之Anko魔法（下篇）也将在不久于大家不见不散😄。 QQ交流群：601924443 欢迎Android或者kotlin爱好者加入探讨交流。","link":"/2018/12/11/kotlin-anko/"},{"title":"Kotlin中的静态变量和静态方法","text":"在日常开发过程中，静态变量 和 静态方法 是我们常见的用法，Java中相信大家并不陌生了，那么在 Kotlin 中该如何使用呢？其实很简单，只需要一个将变量和方法包含在 companion object 域中即可，比如这样： 123456789101112131415161718class Constant { companion object { // 接口根地址 const val BASE_URL = &quot;http://xxxx.xxx.xxx/&quot; // 友盟 const val UMENG_APP_KEY = &quot;xxxxxxxxxx&quot; const val UMENG_CHANNEL = &quot;umeng&quot; // 微博 const val WEIBO_APP_KEY = &quot;xxxxxxxx&quot; const val WEIBO_SECRET = &quot;xxxxxxxxxx&quot; fun getVideoFactor(){ // do some work } }} 看后是不是很简单？在纯kotlin代码中可以直接这样使用： 123//初始化各平台的APIKey PlatformConfig.setWeixin(Constant.WECHAT_APP_ID, Constant.WECHAT_APP_SECRET) PlatformConfig.setSinaWeibo(Constant.WEIBO_APP_KEY, Constant.WEIBO_SECRET, Constant.WEIBO_AUTH_RETURN_URL) 然而，如果我们使用的是Java和kotlin混合开发，在Java代码中就无法通过 Constant.静态变量 的方式来使用静态变量或者方法来，而是通过如下方式： 123//初始化各平台的APIKey PlatformConfig.setWeixin(Constant.Companion.WECHAT_APP_ID, Constant.WECHAT_APP_SECRET) PlatformConfig.setSinaWeibo(Constant.Companion.WEIBO_APP_KEY, Constant.WEIBO_SECRET, Constant.WEIBO_AUTH_RETURN_URL) 如果我们想像kotlin那样直接通过 类名.静态变量 方式使用呢？我们可以借助于注解 @JvmField 和 @JvmStatic 来分别标注静态变量和静态方法，之后我就能在Java代码中像以前方式那样直接使用静态的成员啦！例如这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @author moosphon on 2018/12/12 * desc: 异常的统一处理者 */class ExceptionHandler { companion object { @JvmField var errorCode = NetRequestStatus.UNKNOWN_ERROR @JvmField var errorMessage = &quot;请求失败，请稍后重试&quot; @JvmStatic fun handleException(e : Throwable): String{ e.printStackTrace() when(e){ is SocketException -&gt; { Logger.e(&quot;ExceptionHandler&quot;, &quot;网络连接异常： &quot; + e.message) errorCode = NetRequestStatus.NETWORK_ERROR errorMessage = &quot;网络连接异常&quot; } is JsonParseException -&gt; { Logger.e(&quot;ExceptionHandler&quot;, &quot;数据解析异常： &quot; + e.message) errorCode = NetRequestStatus.PARSE_ERROR errorMessage = &quot;数据解析异常&quot; } else -&gt; { try { Logger.e(&quot;ExceptionHandler&quot;, &quot;其他错误： &quot; + e.message) } catch (e1: Exception) { Logger.e(&quot;ExceptionHandler&quot;, &quot;未知错误： &quot; + e.message) } errorCode = NetRequestStatus.UNKNOWN_ERROR errorMessage = &quot;未知错误，一起祷告快点好起来吧～&quot; } } return errorMessage } }} 前段时间比较忙，之后会继续为大家带来kotlin方面的文章，大家拭目以待。Android-kotlin交流群：601924443","link":"/2018/12/11/kotlin-static/"},{"title":"带你领略 Kotlin 中的 “when”魔法","text":"提到 **when**，大家都会联想到 Java 中的 **switch**，然而在 kotlin 中，when 显然比 Java 中的 switch 要强大得多。首先，我们先来看看 when 的特点： 它可以作为表达式使用 使用更加安全 强大灵活的分支结构 可以不带参数 接下来，我来带大家逐步领略这些特点。以下面这段 Java 功能代码为例： 1234567891011121314151617181920212223switch(animal) { case EAGLE: System.out.println(\"鸟类\"); break; case DOLPHIN: System.out.println(\"兽类\"); break; case LOCUST: System.out.println(\"昆虫类\"); break; case CARP: System.out.println(\"鱼类\"); break; case TIGER: System.out.println(\"兽类\"); break; case DUCK: System.out.println(\"鸟类\"); break; default: System.out.println(\"未知动物\"); break;} 从以上代码可以看出，我们这里实现的功能是：通过用户输入一个动物名称来得到其对应的种类信息。乍一看，你可能会觉得上面的代码再正常不过，但是倘若我们的输入情形很多的话，就会增加密密麻麻的限制条件，这肯定是我们不想看到的。那么，让我们来看看通过 Kotlin 的 when 表达式如何实现相同功能： 1234567when(animal) { EAGLE, DUCK -&gt; println(\"鸟类\") DOLPHIN, TIGER -&gt; println(\"兽类\") CARP -&gt; println(\"鱼类\") LOCUST -&gt; println(\"昆虫类\") else -&gt; println(\"未知动物\")} OK，以上就是该功能代码的 kotlin 实现方式，代码不仅简化了很多，也省去了大量的 break 语句，避免了 Java 中因遗漏 break 而导致的 bug，增强了安全性。如果匹配成功，对应的分支便会执行，同时也可以把多个情况合并到同一个分支，只需要通过逗号隔开，并没有额外的代码。 PS：每个条件分支的处理通过在 -&gt; 之后来进行。 作为表达式使用首先，我们需要重温一下表达式与语句的区别。表达式有值，并能作为另一个表达式的一部分来使用；而语句没有返回值。Java 中的控制结构皆为语句。而在 Kotlin 中，除了循环体结构外，大多数控制结构都是表达式。举个栗子😄，还是上面的例子，我们可以将其优化为以下代码： 123456789var result = when(animal) { EAGLE, DUCK -&gt; \"鸟类\" DOLPHIN, TIGER -&gt; \"兽类\" CARP -&gt; \"鱼类\" LOCUST -&gt; \"昆虫类\" else -&gt; \"未知动物\"}// 输入：DUCK，返回：当前动物的种类为：鸟类println(\"当前动物的种类为： $result\") 此外，我们也可以直接通过表达式函数来直接得到最终的结果： 12345678fun displayAnimalType(animal: Animal) = when(animal) { Animal.EAGLE, Animal.DUCK -&gt; \"鸟类\" Animal.DOLPHIN, Animal.TIGER -&gt; \"兽类\" Animal.CARP -&gt; \"鱼类\" Animal.LOCUST -&gt; \"昆虫类\" else -&gt; \"未知动物\" } 强大灵活的分支Kotlin 中的 when 远比 Java 当中的 switch 要强大得多。switch 只能以常量作为分支条件，而 when 允许使用任意对象。emmm～举个简单的例子吧： 1234567fun handleResult(score: Int) = when(score) { in 0..39 -&gt; \"fail to go up to the next grade.\" in 40 until 60 -&gt; \"not pass, should test again.\" 97,98,99,100 -&gt; \"learning outstanding results.\" else -&gt; \"pass the test.\" } Java 当中，当我们的分支情况比较多或者每种分支可能会重复多次时，势必会通过 if-else 来各种判断，而在 Kotlin 当中，一个 when 就能帮我们完成这些操作。 此外，如果你想判断一个未知变量的类型，而其可能类型有很多种可能性，那么也可以通过 when 来实现，例如： 1234567fun judgeAnimalKind(animal: Any) = when(animal) { is Bird -&gt; \"这是鸟类\" is Fish -&gt; \"这是鱼类\" judgeIfInsect(animal) -&gt; \"这是昆虫\" else -&gt; \"我不知道这是什么动物\" } 当然，我们也可以将代码块作为我们的分支体，这时候，代码块中最后一个表达式或者变量就是该分支体的返回结果，如： 1234567891011121314fun judgeAnimalKind(animal: Any) = when(animal) { is Bird -&gt; \"这是鸟类\" is Fish -&gt; \"这是鱼类\" judgeIfInsect(animal) -&gt; \"这是昆虫\" else -&gt; { val kind = if (judgeDolphin(animal) || judgeTiger(animal)) { \"这是兽类\" }else { \"我不知道这是什么动物\" } kind } } 上述代码中，kind 即为我们的 else 分支块中的最终返回结果。 无参的情况特别地，when 中的参数可能并非满足我们的需求，我们可以选择省略该参数，例如这样： 1234when { phoneNumber?.length != 11 -&gt; toast(\"illegal phone number.\") password.isNullOrEmpty() -&gt; toast(\"please input password\")} 总结通过以上的介绍，我们不难发现：**when** 的使用场景要比 Java 的 switch 灵活、强大的多，同时，我们也可以借助 when 来重构和优化复杂的 if-else 结构，以简化我们的代码，提高代码的可读性。","link":"/2019/05/21/kotlin-when/"},{"title":"Mac中常用快捷键","text":"作为一名开发者，如果你使用Mac，那么下面这些快捷键不可或缺，能很大程度上提高开发效率。先来看一下熟悉一下键盘： 通用 command（⌘）+ tab ：应用程序间实现快速切换 command（⌘）+ H : 隐藏当前窗口 command（⌘）+ M : 将窗口最小化 command（⌘）+ N : 新建一个窗口 command（⌘）+ O : 打开当前文件 command（⌘）+ S : 保存当前文件 command（⌘）+ shift + S : 另存为 command（⌘）+ P : 打印 command（⌘）+ W : 关闭 command（⌘）+ Q : 退出 工具 command（⌘）+ shift + 3 ：截屏（截取整个屏幕） command（⌘）+ shift + 4 :截屏（截取选择区域） command（⌘）+ shift + 4 + 空格：截取选择的窗口 文件 space（空格）：快速查看 command（⌘）+ A : 选择全部 command（⌘）+ I : 显示简介 command（⌘）+ N : 新建文件夹 command（⌘）+ F : 快速搜索 command（⌘）+ C : 复制 command（⌘）+ V : 粘贴 command（⌘）+ delete : 删除 command（⌘）+ shift + delete：清空回收站 浏览器 command（⌘）+ + ：放大 command（⌘）+ - ：缩小 command（⌘）+ T : 新建选项卡 command（⌘）+ N : 新建窗口 command（⌘）+ R : 刷新页面 command（⌘）+ F : 搜索 command（⌘）+ W : 关闭当前选项卡 系统 command（⌘）+ shift + ⇪(介质推出键) ：关闭显示器 command（⌘）+ option + esc ：强制退出应用程序 command（⌘）+ option + ⇪ ：睡眠 command（⌘）+ control + ⇪ ：关闭所有应用程序并重新启动 command（⌘）+ shift + Y : 用当前选中的文字生成便签 command（⌘）+ space（空格）：切换输入法（2017新款不适用）","link":"/2018/01/28/mac-keyboard/"},{"title":"Android版微信跳一跳小游戏如何利用技术手段达到高分！","text":"本文主要来讲个个好玩的东西，近来微信刚出的跳一跳微信小程序的游戏很火，看到很多人都达到了二三百分就各种刷朋友圈了。 最终我们达到的分数却是这样的： 一定会有人拍手叫好，“黄金右手”！说真的，我已经不用右手好多年，而且我玩这个游戏压根就没用手，而是意念！哈哈，别喷我，开个玩笑而已，肯定是利用技术手段啦，什么技术？python喽～哈哈，不过不是我写的，我自己是做Android开发的，我对于python从来没有接触，只是恰好在蛋哥公众号看到关于这个游戏的文章，觉得有意思，就花了点时间试着搞了一下，没想到还跑成功了，收获也挺多的😄。本文针对mac系统+Android全面屏手机，如想了解其他系统或者手机的教程，可以到项目主页或者issue中探索一下。好了，下面给大家看看它的“庐山真面目”。 关于游戏脚本，作者已经开源在了github，地址在https://github.com/wangshub/wechat_jump_game，有兴趣的可以先去看看。一般的，手机型号比较老（像Android4.3以下的），或者比较新（像vivox20，小米mix2等等刚出的全面屏手机），再或者比较稀有的（像TCL，联想，诺基亚等等），顺利的跑起脚本还是挺难的，多少都会有些问题，由于脚本是作者几个小时就写好的，已经很厉害了，适配的这些问题不可能全部都面面具到，毕竟Android机型千千万呀！希望大家多多体谅，作者精力也是有限，不可能及时回答每一个人的问题，大家毕竟也是搞技术的，有些问题应该都有能力解决的，例如issue，度娘等等。这里我简单说明以下自己用mac和vivox20如何跑起来的。 首先，我们到作者的源码地址看看原理和Android的使用步骤,如下： 将手机点击到《跳一跳》小程序界面；用 ADB 工具获取当前手机截图，并用 ADB 将截图 pull 上来 12adb shell screencap -p /sdcard/autojump.pngadb pull /sdcard/autojump.png . 计算按压时间手动版：用 Matplotlib 显示截图，用鼠标点击起始点和目标位置，计算像素距离；自动版：靠棋子的颜色来识别棋子，靠底色和方块的色差来识别棋盘；用 ADB 工具点击屏幕蓄力一跳； 1adb shell input swipe x y x y time(ms) 原来是利用adb来计算和模拟位置的，我们暂时不需要关心这个，再来看看Android手机使用步骤： 安卓手机打开 USB 调试，设置》开发者选项》USB 调试 电脑与手机 USB 线连接，确保执行adb devices可以找到设备 ID 界面转至微信跳一跳游戏，点击开始游戏 运行python wechat_jump_auto.py，如果手机界面显示 USB 授权，请点击确认 请按照你的手机分辨率从./config/文件夹找到相应的配置，拷贝到 *.py 同级目录./config.json（如果屏幕分辨率能成功探测，会直接调用 config 目录的配置，不需要复制） OK，我就按照步骤一步一步来： 打开手机开发者选项和usb调试，这一步我想不需要多说了，大家应该都知道怎么做； 需要确保adb devices可以找到设备。 搞移动端开发的应该都知道adb吧，不过可能有些人没有接触过，这里就简单说明一下如何执行adb命令。首先需要下载adb工具，一般Android studio的sdk中自带了，我们只需要配置一下环境变量就可以了，想知道如何配置，可以遵循如下步骤： 12345678910- 打开mac的terminal终端，输入 cd ~/ 【进入当前用户的home目录】- 输入 touch .bash_profile 【如果没有.bash_profile这个文件，则创建一个这个文件】- 输入 open .bash_profile 【打开我们创建的这个文件，此时应该弹出一个文本编辑框，如果是第一次配置环境，那么文本编辑框为空白】- 在打开的文本编辑器中写入如下代码： export ANDROID_HOME=/usr/local/opt/android-sdk export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools- 注意的ANDROID_HOME后面应该根据自己的sdk路径来填写，其余可以直接复制。至于sdk路径，可以打开Android Studio，在preference(Windows的setting)中搜索sdk来查看。在终端中输入 source .bash_profile 【使我们的改动生效】- 输入 adb 【验证是否完成配置，如果不显示 adb: command not found，说明配置完成 】 如果没有用过Android studio，那么可以去百度一下如何安装，我相信这对于大家来说不是一件困难的事，安装完成后只需要按照上面说的配置一下环境变量就可以了。接下来我们将手机连接到电脑，并开启第一步中的设置选项后，在电脑终端输入： 1adb devices 不出意外的话，终端会出现类似如下内容： 1234Last login: Mon Jan 1 20:20:11 on ttys000MoosdeMacBook-Pro:~ moos$ adb devicesList of devices attacheda619aaxx device 这样就代表我们adb设备连接成功了。 打开我们的微信中“跳一跳”游戏小程序，点击开始游戏，手机出现游戏初始界面； 要求我们运行脚本项目中的python文件，这就需要我们安装python了，不用担心，一般mac系统自带了python，我们终端输入如下命令： 1python 如果出现如下内容，则说明我们已经安装过了： 12345MoosdeMacBook-Pro:~ moos$ pythonPython 2.7.10 (default, Jul 15 2017, 17:16:57) [GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.31)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 如果没有安装python，可以参考该文章：http://blog.csdn.net/u010828718/article/details/70257622下面我们就需要运行wechat_jump_auto.py这个脚本文件了，这个是自动玩游戏，你也可以选择手动玩，运行wechat_jump_py3.py即可，如何运行？很简单，只需要把github上面的项目下载下来，并进入到该目录下，执行如下命令即可（以自动版为例）： 1python wechat_jump_auto.py 这样，我们就可以跑起来这个脚本了，但是你可能会遇到这个问题： 12345Traceback (most recent call last): File &quot;wechat_jump_auto.py&quot;, line 8, in &lt;module&gt; from PIL import Image, ImageDrawImportError: No module named PILMoosdeMacBook-Pro:wechat_jump_game-master moos$ 只需要安装pillow，执行如下命令即可： 1sudo pip install Pillow 记得加上sudo，需要获取系统权限。 这样，应该基本可以跑起来脚本了。但是，vivox20手机运行了脚本之后，一直没有自动游戏，后来发现，可能是不同手机分辨率和尺寸差异，导致脚本没有是识别到对应的模拟按压的坐标位置，可以修改一下对应的按压参数为320，1210，720，910，对应的修改位置是wechat_jump_auto.py中的如下参数： 1swipe['x1'], swipe['y1'], swipe['x2'], swipe['y2'] = 320, 410, 320, 410 该修改意见已经被作者合并到主分支了，打开该文件就可以看到了。再跑一下试试，发现还是不行，程序在运行，位置坐标也在变化，但游戏没有进行，那可能就是手机的问题了，尝试开启开发者设置中的usb安全验证设置，我再跑，嘿，可以了：请忽略这渣图，vysor还没有很好的适配vivox20，并不是gif的问题😢，再看看终端的数据： 1234567891011121314151617181920212223242526('scan_start_y: ', 720)(1514815959, 0, 0, 0, 0)adb shell input swipe 320 1210 720 910 200('scan_start_y: ', 670)(1514815962, 0, 0, 0, 0)adb shell input swipe 320 1210 720 910 200('scan_start_y: ', 670)(1514815966, 0, 0, 0, 0)adb shell input swipe 320 1210 720 910 200('scan_start_y: ', 820)(1514815971, 338, 1224, 788, 968)adb shell input swipe 320 1210 720 910 710('scan_start_y: ', 920)(1514815976, 697, 1203, 400, 1008)adb shell input swipe 320 1210 720 910 487('scan_start_y: ', 820)(1514815979, 320, 1275, 839, 940)adb shell input swipe 320 1210 720 910 847('scan_start_y: ', 870)(1514815984, 392, 1194, 718, 1009)adb shell input swipe 320 1210 720 910 514('scan_start_y: ', 870)(1514815987, 660, 1167, 450, 1052)adb shell input swipe 320 1210 720 910 328('scan_start_y: ', 770)... 这样就没毛病了，同时，我还修改了2160x1080的配置参数，提高了跳跃的准确度，达到几千分不是问题，并且已经被作者同意了合并了，无需再做额外修改了。 在借用该脚本作者的一句话： 1事实证明，机器人比人更会玩儿游戏。 好了，大家是不是已经迫不及待想去刷分了呢😄，不过分高虽好，可不要“贪杯”哟，会没朋友的。","link":"/2018/01/01/python-game/"},{"title":"微信小游戏开发笔记（下）","text":"上次我们介绍了基于laya实现微信小游戏的排行榜功能，过程中免不了遇到一些坑，主要包含一些图片加载、逻辑处理、排行榜绘制、微信头像跨域等问题，具体可参考下面的记录文档。 2018/08/01 设置laya舞台全屏显示出现游戏崩溃问题： 错误信息：Stage is not defined 解决方案：增加前缀包名Laya1Laya.stage.scaleMode = Laya.Stage.SCALE_SHOWALL; 第二个boss出现后，boss子弹发生了重叠： 解决方案：在生成每个boss前移除之前的boss12345678910111213141516171819202122/** * 根据关卡生成boss */function generateBoss(level,grade,hp,shootType){ if(this.boss!=null){ this.boss.removeSelf(); //回收到对象池 Laya.Pool.recover(&quot;role&quot;,this.boss); } isLastTime = true; //在循环中创建敌人 Laya.timer.frameLoop(1,this,onLoop); this.boss = new Role(); this.boss.init(&quot;boss&quot;+level+&quot;_&quot;+grade,1,hp,0,60 ); this.boss.shootType = shootType; this.boss.shootInterval = 800; //boss出现位置 this.boss.pos(187, 100); this.boss.visible = true; //添加到舞台上 this.roleBox.addChild(this.boss);} 第一个boss被击败后，需要根据第二个boss刷新攻击属性和伤害值：1234567891011121314function appearBoss(){ Laya.timer.clear(this, onNextBossWarning); removeEnemys(); generateBoss(currentLevel,this.bossGrade,20,1); console.log(&quot;当前选中的技能是&quot;+levelWeaponData[this.weapon_ready_list.selectedIndex]); if(levelWeaponData[this.weapon_ready_list.selectedIndex] != (currentLevel*10 + this.bossGrade)){ //如果派出的boss与选中的武器属性不吻合，那么降低伤害值 console.log(&quot;70%火力～&quot;); upgradeBullet(false); }else{ console.log(&quot;100%火力～&quot;); upgradeBullet(true); }} 2018/08/02 laya图集打包后，部分图片加载不出来的问题： 错误日志：1234567[warn]Retry to load: war/war/bg_second_level.png[warn]Retry to load: war/hero_down1.png[warn]Retry to load: war/hero_down2.png[warn]Retry to load: war/hero_down3.png[warn]Retry to load: war/hero_down4.png[error]Failed to load: war/war/bg_second_level.png 问题原因：图集打包最大只允许2048x512，而最终打包后的图片大小超出了范围，导致无法显示出来。 解决方案：可以分开打包图集 2018/08/03 将boss的出现改在答题之前后，战机无法发射子弹或者一直warning： 解决方案：需要修改generateBoss方法逻辑，将继续游戏与boss出现功能代码分离，先在warning结束时生成boss，然后在答题结束后调用resume方法继续游戏。 退出当前关卡后，进入下一关，然后再退出，游戏场景卡住不返回首页的问题： 问题原因：没有合适的移除UI资源 解决方案：关闭游戏场景前需要移除里面的背景资源、场景资源以及角色资源，并判断首页UI是否存在，如果存在需要回收，然后新建。12345678910111213function onGameLeave(){ dialog.close(); console.log(&quot;结束游戏～&quot;); removeGame(); this.removeChildren(); this.removeSelf(); if(!GameScene.homePage){ GameScene.homePage = null; } GameScene.homePage = new HomePageUI(); Laya.stage.addChild(GameScene.homePage); } 2018/08/06 给点击事件的回调方法添加参数回调：123456789101112131415161718192021222324252627btn_use.on(Laya.Event.CLICK, this,onUseEquipment, [index]);....../** * list中对应位置的使用按钮的点击事件处理 * @param {*} index */ function onUseEquipment(index){ console.log(&quot;当前使用了第&quot;+index+&quot;个装备&quot;); for(var i=0; i&lt;data.length; i++){ if(i === index){ //设置选中的状态 console.log(&quot;当前boss级别-&gt;&quot;+(currentLevel*10 + this.bossGrade)+&quot;，当前选中的武器-&gt;&quot;+levelWeaponData[index]); if((currentLevel*10 + this.bossGrade) === levelWeaponData[index]){ //使用的武器与boss是对应的 console.log(&quot;100%火力～&quot;); upgradeBullet(true); }else{ console.log(&quot;70%火力～&quot;); upgradeBullet(false); } } }} 2018/08/07 开放域打包集成到主域后，出现以下问题： 日志信息：123gameSubContextThirdScriptErrorwx.getFileSystemManager is not a function;at onMessage callback functionTypeError: wx.getFileSystemManager is not a function 问题原因：开放域中的图集资源并没有成功加载 解决方案：开放域中并不能加载图集资源，可以直接加载图片集1234567891011_proto.loadResource = function(){ Laya.loader.load([&quot;comp/bg_line.png&quot;,&quot;comp/ranking1.png&quot;,&quot;comp/ranking2.png&quot;, &quot;comp/ranking3.png&quot;,&quot;comp/userholder_img.png&quot;], Laya.Handler.create(null,function(){ console.log(&quot;开放域资源加载完毕～&quot;); //sample.dialog = new RankDialogUI(); sample.rankView = new RankingViewUI(); Laya.stage.addChild(sample.rankView); })); } 开放域代码打包到微信小游戏项目中时无法运行的问题： 错误信息：1dispatchMessage is not defined;at onMessage callback function ReferenceError: dispatchMessage is not defined 解决方案：通过_proto来创建方法：123456789101112131415161718192021var _proto = LayaUISample.prototype; /** * 写入排行榜数据 */ _proto.writeRankingData = function(rankingData){ //KVDataList代表排行数据,可以为多个,多个代表多个排行 //key-排行类型,value-排行分数 window['wx'].setUserCloudStorage({ KVDataList: [ //{ key: '击杀排行', value: &quot;&quot; + 1 }, { key: '分数排行', value: &quot;&quot; + 100 },//需要改成动态的值 ], success: function (res) { console.log('setUserCloudStorage', 'success', res) }, fail: function (res) { console.log('setUserCloudStorage', 'fail') } }); } 2018/08/08 开放域绘制的排行榜被主域的dialog覆盖的问题： 问题原因：开放域与主域的视图层级不一样，dialog的层级远远大于普通视图容器。 解决方案：dialog的默认层级zOrder为1000，最简单的方式是将shareCanvas的容器sprite的层级zOrder大于1000即可。123456789101112131415161718/** * 设置共享Canvas */function showShareCanvas(){ window['sharedCanvas'].width = rankViewWidth; window['sharedCanvas'].height = rankViewHeight; //主域显示开放域内容??? //window['sharedCanvas'].sharedCanvas = window['wx'].getOpenDataContext().canvas; Laya.timer.once(1000, this, function () { var sprite = new Laya.Sprite(); sprite.zOrder = 1008; sprite.pos(0, 0); var texture = new Laya.Texture(window['sharedCanvas']); texture.bitmap.alwaysChange = true;//小程序使用，非常费 sprite.graphics.drawTexture(texture, (screenWidth - rankViewWidth)/2, (screenHeight - rankViewHeight)/2, texture.width, texture.height); Laya.stage.addChild(sprite); });} 提交排行榜数据时出现以下问题： 错误信息：setUserCloudStorage:fail invalid KVData item。 问题原因：提交数据的格式错误，key与value都应该是string类型 参考：https://developers.weixin.qq.com/minigame/dev/document/open-api/data/KVData.html 2018/08/09 小游戏分享失败的问题： 问题原因：在开放域分享用户排名后，提示无该方法，开放域官方只提供了几个有限的api接口，应该在主域去请求分享1234567891011121314151617181920212223242526 window['wx'].showShareMenu({ withShareTicket:false, success:function(res){ console.log(&quot;开启转发成功～&quot;); }, fail:function(res){ console.log(&quot;开启转发失败～&quot;); }, complete:function(res){ } });window['wx'].onShareAppMessage(function () { // 用户点击了“转发”按钮 return { title: '我在飞机大战游戏中排名又上升了,快来挑战我吧～' }})window['wx'].shareAppMessage({ title: '我在飞机大战游戏中排名又上升了,快来挑战我吧～', imageUrl: canvas.toTempFilePathSync({ destWidth: 500, destHeight: 400 })}); 提交排行榜分数：12345678910111213141516171819202122232425262728293031323334/** * 向开放域发送消息，并接收开放域返回过来的数据， * 可根据发送参数和接收数据在主域这边进行下步处理 * @param message * @param caller * @param callback */function wxPostMessage(message, caller, callback){ window['wx'].postMessage(message); Laya.timer.once(300, this, function (){ //回调处理 if (caller == null || caller == undefined) { callback(message); } else { caller.callback(message); } });}/** * 提交分数到微信服务器 */function postScoreToWXServer(){ wxPostMessage({ command: 2, text: &quot;提交玩家分数&quot;, rankingData: { fightScore:this.score*scoreFactor, fightTime:new Date().getTime() } }, null, function (message) { console.log(&quot;提交分数的回调&quot;); });} 2018/08/10 调取用户好友排行数据并排序整合后，得到的nickName为undefine： 问题原因：获取好友排行榜的数据中当前登录用户的昵称是空值 解决方案：先通过getUserInfo获取当前用户的数据，然后通过avatarUrl去查找好友排行榜中数据，如果相同，说明为同一个用户，将当前用户昵称复制给好友排行榜中当前用户的昵称。 统计三关分数，并对它们的总分进行排序的解决思路： 可以通过微信提供的排行榜分类统计功能，这样就无需理会玩家是一次性通关还是多次选择关卡通关的问题了。只要将玩家玩每一关通过时的分数通过key(关卡)、value(分值)键值对形式存储，然后每次重复选择都会刷新关卡的分值。而获取好友排行榜数据时，需要将分数先转化为number，然后累加进行排序，并展示即可。 关闭排行榜后，再次打开，数据没了或者出现混乱的问题： 解决方案：需要重新清空重置数据，并渲染list：123456789101112/** * 关闭排行榜 */ _proto.closeRankingDialog = function(){ //dialog.close(); console.log(&quot;关闭排行榜～&quot;); sortData = []; lastRenderIndex = -1; sample.rankView.removeChildren(); sample.rankView = null; } 关于如何在laya游戏引擎中显示外部网页的问题： 方法一：通过设置href来添加外部网页资源。但这种方法无法关闭和设置外部网页的位置和大小。1Laya.Browser.window.location.href = &quot;http://www.baidu.com&quot;; 方法二：通过iframe来添加外部网页并控制其位置、大小以及移除：12345678910111213 var iframe = Laya.Browser.document.createElement(&quot;iframe&quot;); iframe.style.position =&quot;absolute&quot;;//设置布局定位。这个不能少。 iframe.style.zIndex = 1006;//设置层级 iframe.style.left = &quot;36px&quot;; iframe.style.top = &quot;136px&quot;;iframe.width = 180;iframe.height = 220; iframe.src = &quot;http://ask.layabox.com/&quot;; Laya.Browser.document.body.appendChild(iframe);function onHelpClose(){ Laya.Browser.document.body.removeChild(iframe);; dialog.close(); } 2018/08/13 无法加载微信用户头像的问题： 错误信息：123gameThirdScriptErrormodule &quot;code.js&quot; is not definedError: module &quot;code.js&quot; is not defined 解决方案：应该是变量的作用域不同造成的，需要定义一个外部的全局变量，并将this.userLogoImage赋值给它，然后在获取完毕微信头像信息后加载该全局变量即可。 关于如何让laya的label内容超出空间大小后自动滚动的问题： 解决方案：可以通过Panel组件来包裹label控件，让其达到滚动效果。 使用panel组件后，里面的label内容超过本身大小后无法滚动的问题： 解决方案：panel组件只是让其内部的控件在大小超过其容器(即panel)的时候，尽量达到滑动显示全部信息，所以，需要将里面的label控件高度设置尽量大，以保证文字内容全部显示出来。 打包成微信小游戏后包太大无法预览上传的问题： 问题原因：微信限制上传的代码包不得超过4m。 解决方案： 压缩图片资源 去除index中没有使用到的library 删除图集打包生成的多余的文件 头像设置的遮罩无效的问题： 问题原因：为了降低包大小，不小心将webgl代码库注释了，导致mask遮罩无法渲染成功 2018/08/14 ios手机中无法播放游戏声音的问题： 问题原因：laya引擎内部的方法播放音频只对Android手机有效，对ios的机型没有效果 解决方案：需要借助于微信自带的接口来播放音频1234var audio = wx.createInnerAudioContext()audio.src = &quot;res/sound/game_over.mp3&quot; // src 可以设置 http(s) audio.obeyMuteSwitch = falseaudio.play(); 调试模式下可以正常显示用户的头像，但在非调试模式下无法显示用户头像问题： 问题原因：微信用户授权方法失效引起的 解决方案： 排行榜玩家昵称不显示问题以及排序错乱问题： 问题原因：没有正确复制好友排行榜的数据，头像链接、分数等都可以获取到，但是偏偏昵称获取为undefined，排行榜排序方式也有问题。 解决方案：由于直接拿到微信返回的排行榜数据中用户昵称是存在的，而通过变量赋值获取后便为undefined了，可以拿到原始数据res.data[i].nickname，然后复制给变量currentPlayer，再便遍历添加到数组集合。排序可以通过sort方法，通过比较目标集合中的两个任意对象的分值，从大到小排列：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//取出所有好友数据 window['wx'].getFriendCloudStorage({ keyList: [ //'击杀排行', '第1关', '第2关', '第3关' ], success: res =&gt; { console.log(&quot;wx.getFriendCloudStorage success&quot;, res); let data = res.data; for (let i = 0; i &lt; data.length; i++) { var playerInfo = data[i]; var currentPlayer = res.data[i].nickname; console.log(&quot;当前排行玩家昵称为=&gt;&quot;+res.data[i].nickname); var kvList = playerInfo.KVDataList; var scoreSum = 0; if(kvList.length&gt;0){ for(var j = 0;j&lt;kvList.length;j++){ if(kvList[j].key != null){ //将value转化为int再累加 scoreSum+=Number(kvList[j].value); } } } if (data[i].avatarUrl == userData.avatarUrl) { //获取群好友的时候,没有自己的名字?? data[i].nickName = userData.nickName; myRanking = i+1; console.log(&quot;此ID为自己,当前排名第&quot;+myRanking); } //填充总分信息 sortData.push({ nickName: currentPlayer, avatarUrl: data[i].avatarUrl, totalScore: scoreSum }); } sortData.sort((a, b) =&gt; { var score1 = Number(a.totalScore); var score2 = Number(b.totalScore); if (score1 &gt; score2) { return -1; }else if(score1 &lt; score2){ return 1; }else{ return 0; } }); showRankingDialog(); }, fail: res =&gt; { console.log(&quot;拉取好友信息失败&quot;, res); }, }); 三张背景图打包图集后，有一张无法显示出来的问题： 问题原因：图集打包的图片超过了最大限制 解决方案：可以不打包图片，直接在bin中使用 2018/08/15 laya绘制的好友排行榜在微信开发工具无法滑动的问题： 问题原因：主域和开放域的排行榜的位置坐标矩阵不同步造成的 解决方案：需要将主域和开放域的排行榜对应位置坐标矩阵同步123456789101112131415161718192021222324252627282930313233主域代码：// 解决显示对象和鼠标错位而导致的排行榜滑动无效问题 var globalPosition = dialog.ranking_list.localToGlobal(new Laya.Point()); var originMatrix = Laya.stage._canvasTransform; var mat = new Laya.Matrix(originMatrix.a, 0, 0, originMatrix.d, globalPosition.x * originMatrix.a, globalPosition.y * originMatrix.d); //var mat = new Laya.Matrix(Laya.Browser.clientWidth/Laya.stage.width, 0, 0, Laya.Browser.clientHeight/Laya.stage.height); mat.translate(globalPosition.x * mat.a, globalPosition.y * mat.d); wxPostMessage({ command: 0, text: &quot;设置开放域canvas大小&quot;, canvasData: { width: rankViewWidth * mat.a, height: rankViewHeight * mat.d, matrix: mat //width:rankViewWidth, height:rankViewHeight, matrix: Laya.stage._canvasTransform }, isLoad: false }, null, function (message) { console.log(&quot;再次往开放域发请求&quot;); window['wx'].postMessage({ command: 1, text: '开放域加载资源', }); }); 开放域代码： var openMatrix = new Laya.Matrix(); openMatrix.a = mainMatrix.a; openMatrix.b = mainMatrix.b; openMatrix.c = mainMatrix.c; openMatrix.d = mainMatrix.d; openMatrix.tx = mainMatrix.tx; openMatrix.ty = mainMatrix.ty; //重置矩阵 Laya.stage._canvasTransform = openMatrix; 主域修改了坐标矩阵的同步代码后，小游戏排行榜无法显示： 错误信息：123gameSubContextThirdScriptErrorCannot read property 'ranking_list' of undefined;at api getFriendCloudStorage success callback functionTypeError: Cannot read property 'ranking_list' of undefined 问题原因：laya平台自身问题，只是存在以下代码，开放域的排行榜便无法绘制：1234567// 解决显示对象和鼠标错位而导致的排行榜滑动无效问题 ...... var mat = new Laya.Matrix(Laya.Browser.clientWidth/Laya.stage.width, 0, 0, Laya.Browser.clientHeight/Laya.stage.height); mat.translate(globalPosition.x * mat.a, globalPosition.y * mat.d); ...... 2018/08/21 将游戏发布到微信平台后，微信头像无法显示的问题： 问题原因：微信头像url跨域了 解决方案：获取到微信头像地址后，需要将其传到服务器，让服务器复制一份生成自己的服务器图片url","link":"/2018/09/11/wechat-game-2/"},{"title":"微信小游戏开发笔记（上）","text":"好久不见～最近两个月一直在忙公司的微信小游戏项目，没时间打理博客，很多人留言可能没有及时回复，接下来我将继续和大家探索Android方面的好玩的东西。之前没有接触过游戏开发和前端开发，一开始上手可能较为困难。微信小游戏一般要借助于主流的游戏引擎进行开发，常见的有laya、cocos、egret等，这里我选用了laya游戏引擎，laya相对于其他游戏引擎来说，文档记录可能不够全面，而且社区问题反馈效率较低，但好在功能较为齐全，需要自己花时间研究，如有想开发小游戏的可以自行选择。 本来想要按照开发流程写一个系列教程，但是发现这样写下去篇幅较长，而且开发过程中依靠的大多还是官方的文档和之前累积的开发经验，这里还是先放一下日常的开发文档吧，后续将写文章记录一下微信排行榜绘制等难点。 2018/07/04 修改Layabox的初始化页面： 以actionScript为例，需要修改actionScriptProperties、asconfig.json、xxx.as3proj、xxx.max.js中的target关键字，target指代目标的替换初始化页面。 将laya项目打包出微信小游戏项目时出错： 错误信息：[ERR]|FileNotFound: /Users/moos/Documents/Emerson/EmersonGame/src/LayaUISample.js。 解决方案：全局搜索关键词并删除该相关类信息 2018/07/05 layabox简单适配： 边距位置适配 left、right、top、bottom四个属性分别基于父容器的左边缘、右边缘、上边缘、下边缘。这里特别要注意的是，left、right、top、bottom的属性效果是基于父容器（页面）的各个边缘，而不是屏幕的各个边缘。父容器（页面）的分辨率一定要与项目中Laya.init()设置的分辨率相同，如果没有设置成相同，那么并不能实现效果。 边距的拉伸适配 除了居于某一个边缘的适配作用外，同时设置left、right、top、bottom的属性值，还可以根据不同屏幕对组件进行拉伸适配。Tips：拉伸适配的边距设置方式通常需要结合九宫格来实现。 中心位置适配 中心适配常用于基于屏幕中间的游戏启动LOGO，弹出提示框等。我们可以通过centerX、centerY进行位置居中设置. bin目录下的index文件中的js文件声明顺序决定了UI渲染的顺序。 1234&lt;script src=&quot;../src/GameInfo.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../src/Role.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../src/BackGround.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../src/Game.js&quot;&gt;&lt;/script&gt; layaUI.max.all.js文件中加载UI的图片资源是bin目录下的图集。注意：如果没有特别设置，创建的UI组件都会被打包成图集存储在bin/res/atlas目录下。 2018/07/09 UI组件的图片资源加载失败的问题： 日志信息： 12lose skin template/StartDialog/btn_dialog_close.pnglose skin template/StartDialog/btn_start_game.png 问题原因：没有待资源加载完毕就将组件添加到舞台了。解决方法：在添加UI到舞台之前需要预加载UI图集资源 12345function beginLoad(){ Laya.loader.load(&quot;res/atlas/template/HomePage.atlas&quot;, Handler.create(null, onLoaded)); // 预加载弹窗的UI资源 Laya.loader.load(&quot;res/atlas/template/StartDialog.atlas&quot;, Handler.create(null, onLoaded));} 加载dialog时出现崩溃异常： 异常信息：dialog is not defined 解决方案：dialog并不属于HomePageUI 12345678910111213141516function onSecondLevelLoad() { console.log(&quot;第二关准备中～&quot;); var dialog = new StartDialogUI(); Laya.stage.addChild(dialog); dialog.popup(); dialog.title_start_dialog.font dialog.title_start_dialog.text = &quot;第二关&quot;; dialog.btn_start_game.on(Laya.Event.CLICK, this, onGameStart); dialog.btn_start_dialog_close.on(Laya.Event.CLICK, this, onDialogClose); function onDialogClose(){ console.log(&quot;关闭对话框～&quot;); dialog.close(); } } 新建GameScene并添加到舞台后，出现如下异常： 异常信息： 123456789101112131415161718192021&quot;TypeError: Cannot read property 'call' of undefined at Function.&lt;anonymous&gt;(file:///Users/moos/Company/Emerson-AirWar/EmersonGame/bin/libs/laya.core.js:130:41) at new GameScene(file:///Users/moos/Company/Emerson-AirWar/EmersonGame/src/GameScene.js:4:19) at HomePageUI.onGameStart(file:///Users/moos/Company/Emerson-AirWar/EmersonGame/src/HomePage.js:78:27) at EventHandler.__proto.runWith(file:///Users/moos/Company/Emerson-AirWar/EmersonGame/bin/libs/laya.core.js:724:59) at Button.__proto.event(file:///Users/moos/Company/Emerson-AirWar/EmersonGame/bin/libs/laya.core.js:499:30) at TouchManager.__proto.sendEvents(file:///Users/moos/Company/Emerson-AirWar/EmersonGame/bin/libs/laya.core.js:3340:7) at TouchManager.__proto.onMouseUp(file:///Users/moos/Company/Emerson-AirWar/EmersonGame/bin/libs/laya.core.js:3499:10) at MouseManager.__proto.onMouseUp(file:///Users/moos/Company/Emerson-AirWar/EmersonGame/bin/libs/laya.core.js:3043:18) at MouseManager.__proto.check(file:///Users/moos/Company/Emerson-AirWar/EmersonGame/bin/libs/laya.core.js:3070:13) at MouseManager.__proto.check(file:///Users/moos/Company/Emerson-AirWar/EmersonGame/bin/libs/laya.core.js:3063:15)&quot; 问题原因：cmd+点击GameSceneUI跳转不到定义的地方，应该是找不到GameSceneUI定义，将ui.去掉即可，修改所在目录。 2018/07/10 图集资源加载完毕的回调函数没有回调问题： 12345//加载图集资源Laya.loader.load(&quot;res/atlas/war.json&quot;,Laya.Handler.create(this,this.onLoaded),null,Laya.Loader.ATLAS);function onLoaded(){console.log(&quot;准备加载背景了～&quot;);} 解决方案：需要将onloaded方法移到Game()方法的内部，否则无法找到onloaded方法。 游戏运行成功后，游戏里的角色图片素材都发生了破碎和模糊问题： 问题原因：游戏中的角色素材是以打包图集的方式被游戏加载出来的，在未知原因下，图集中资源个数以及位置发生了变化，导致之前图集json文件中位置参数等无效，所以，需要将图集资源图片替换成之前的内容。 2018/07/12 打包assets下的war文件夹中的图集后并没有在对应的文件夹下生成图集资源问题： 问题原因：资源路径需要选择图片所在的上上级文件夹才能生成。 解决方案：选择assets目录作为要打包的图片资源的目标路径。 加载progressbar失败问题： 日志信息： 1234[warn]Retry to load: GameScene/progress.png[warn]Retry to load: GameScene/progress$bar.png[error]Failed to load: GameScene/progress.png[error]Failed to load: GameScene/progress$bar.png 解决方案：问题出在ui编辑页面的progressBar的skin资源路径不全，需要包含其根路径。 2018/07/16 使用定时器来实现警告效果，无法关闭定时器问题： 注册定时器的时候和移除定时器时绑定的回调函数需要是同一个： 123456789101112131415161718192021222324proto.startWarning = function(){ Laya.timer.frameLoop(10,this,onWarn); } .......function onWarn(){ this.warningTime++; if(this.warningState){ hideWarning(); }else{ showWarning(); } if(this.warningTime === 5){ console.log(&quot;该结束警告了～&quot;); Laya.timer.clear(this, onWarn); this.warningState = false; this.warning_title.visible = false; this.warning_content.visible = false; } } UI编辑页面的右侧控件属性栏无法显示的问题： 点击窗口栏选择重置面板即可 实现点击弹窗dialog外部，不关闭dialog： 需要在laya全局初始化之前设置以下属性： 1UIConfig.closeDialogOnSide = false; 自定义了RadioGroup后，发现radio的状态图片资源并没有出现： 问题原因：没有预加载dialog的UI资源，导致图片加载失败，在首页预加载以下就可以了： 1234 Laya.loader.load(&quot;res/atlas/template/StartDialog.atlas&quot;, Handler.create(null));Laya.loader.load(&quot;res/atlas/template/LeaveDialog.atlas&quot;, Handler.create(null));Laya.loader.load(&quot;res/atlas/template/RankDialog.atlas&quot;, Handler.create(null));Laya.loader.load(&quot;res/atlas/template/QuestionDialog.atlas&quot;, Handler.create(null)); 2018/07/19 laya自定义RadioGroup后，每个radio的icon的skin资源无法加载问题： 问题原因：laya中自定义radioGroup如果要设置每个选项的文字信息，不能通过指定radioGroup的labels属性来实现，否则icon不会显示。解决方案：可以通过获取radioGroup的每一个radio来动态为它们设置label： 1234567891011121314function completeHandler(e){ dialog.title_question_dialog.visible = false; dialog.radioGroup_question.visible = true; console.log(e); console.log(e.result.question); answer = e.result.answerIndex; console.log(answer); dialog.subtitle_question_dialog.text = e.result.question; dialog.radioGroup_question.getChildAt(0).label = e.result.choices[0].content; dialog.radioGroup_question.getChildAt(1).label = e.result.choices[1].content; dialog.radioGroup_question.getChildAt(2).label = e.result.choices[2].content; dialog.radioGroup_question.getChildAt(3).label = e.result.choices[3].content; } laya中网络请求的正确姿势： 查看官方文档，并按照文档中教程来，发现网络请求虽然进行了，但无法回调获取到数据，可以通过以下方式： 1234567891011121314151617181920212223//网络请求答题数据 var xhr = new Laya.HttpRequest(); xhr.http.timeout = 10000;//设置超时时间； xhr.on('complete',this,completeHandler); xhr.on('error',this,errorHandler); xhr.send(&quot;http://www.wanandroid.com/tools/mockapi/4080/question&quot;,&quot;&quot;,&quot;get&quot;,&quot;json&quot;); function completeHandler(e){ dialog.title_question_dialog.visible = false; dialog.radioGroup_question.visible = true; console.log(e); console.log(e.result.question); answer = e.result.answerIndex; console.log(answer); dialog.subtitle_question_dialog.text = e.result.question; dialog.radioGroup_question.getChildAt(0).label = e.result.choices[0].content; dialog.radioGroup_question.getChildAt(1).label = e.result.choices[1].content; dialog.radioGroup_question.getChildAt(2).label = e.result.choices[2].content; dialog.radioGroup_question.getChildAt(3).label = e.result.choices[3].content; } function errorHandler(data){ console.log(&quot;网络出错了哟，先检查一下网络吧～&quot;); } 2018/07/20 laya游戏打包成微信小游戏后，运行失败： 错误信息：gameThirdScriptErrorwindow.focus is not a functionTypeError: window.focus is not a function。 问题原因：使用laya自带的httpRequest请求网络数据后出现该问题 子弹的处理逻辑： 英雄战机子弹 Boss子弹 碰撞结果 1 0 1 0 1 1 1 1 0 0 0 1 2018/07/26 游戏结束重新开始游戏后，boss生命值没有被重置的问题： 问题原因：boss角色对象被回收，hp属性值变为0，导致boss瞬间死亡 解决方案： 回收方案：将boss回收后，可以通过判断当前是否存在boss，并且hp值小于1时才提示； 非回收方案：不回收的话需要及时重置boss的血量值，restart过程中设置，并隐藏boss，并利用isCanAttack来判断当前是否可以被攻击，需要增加一些额外逻辑，因为，boss即使设置了visible属性，攻击boss位置，依旧会掉血。 laya中无法渲染list的问题： 解决方案：需要现将目标的那些组件打包成box类型，然后为其指定renderType为render。 1234567891011121314151617dialog.equipment_list.array = data;dialog.equipment_list.renderHandler = new Handler(this, onRender);function onRender(cell, index){ console.log(&quot;装备列表的渲染回调&quot;); if(index &gt; data.length)return; //获取当前渲染条目item的数据 var equipmentData = data[index]; //根据子节点的名字weapon，获取子节点对象 //var weaponData = cell.getChildByName(&quot;weapon&quot;); var weaponData = equipmentData.weapon; //获取子条目各项数据 var weaponImg = weaponData.res; var weaponName = weaponData.name; console.log(&quot;装备列表中武器名称=&quot;+weaponName+&quot;,武器资源=&quot;+weaponImg); } 2018/07/27 根据答题逻辑和打boss等逻辑需要，需要后台返回的随机问题数据格式如下： 12345678910111213141516171819202122232425262728293031323334{ &quot;code&quot;:200, &quot;message&quot;:&quot;success&quot;, &quot;result&quot;:{ &quot;question&quot;:&quot;调整型孔板流量计中间不开孔的主要原因是？&quot;, &quot;answerIndex&quot;:1, &quot;choices&quot;:[ { &quot;choiceId&quot;:0, &quot;choiceHead&quot;:&quot;A&quot;, &quot;content&quot;:&quot;中间开孔不好看&quot; }, { &quot;choiceId&quot;:1, &quot;choiceHead&quot;:&quot;B&quot;, &quot;content&quot;:&quot;中间开孔抗干扰能力差&quot; }, { &quot;choiceId&quot;:2, &quot;choiceHead&quot;:&quot;C&quot;, &quot;content&quot;:&quot;中间开孔不利于安装&quot; }, { &quot;choiceId&quot;:3, &quot;choiceHead&quot;:&quot;D&quot;, &quot;content&quot;:&quot;以上都不正确&quot; } ], &quot;weaponType&quot;:&quot;11&quot;, &quot;weaponName&quot;:&quot;内藏孔板(变送器)&quot;, &quot;weaponInfo&quot;:&quot;流量量程比大于10：1，四螺栓设计，孔板沟槽密封和对中，带内抛光直管段，耐压900#（过程连接1500#），计算标准兼容ASME MFC-14M和SO/TR15377&quot; } } 筛选出重复问题及其对应的重复武器数据，防止list中重复展示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 获取装备数据 */ function getListData(){ data = []; //根据当前关卡来判断存在哪些武器 levelWeaponData = []; if(currentLevel === 1){ console.log(&quot;加载第一关武器数据&quot;); levelWeaponData.push(11); levelWeaponData.push(12); }else if(currentLevel === 2){ console.log(&quot;加载第二关武器数据&quot;); levelWeaponData.push(21); levelWeaponData.push(22); levelWeaponData.push(23); }else if(currentLevel === 3){ console.log(&quot;加载第三关武器数据&quot;); levelWeaponData.push(31); levelWeaponData.push(32); levelWeaponData.push(33); } console.log(&quot;levelWeaponData数量为=&quot;+levelWeaponData.length); console.log(&quot;answerData数量为=&quot;+answerData.length); if(answerData.length &gt; 0){ for(var i = 0;i&lt;levelWeaponData.length;i++){ //根据关卡筛选数据，需要防止重复性数据 console.log(&quot;当前关卡中武器代号为=&quot;+levelWeaponData[i]); for(var j = 0;j&lt;answerData.length;j++){ //如果已获取的武器里存在当前关卡武器中，那么存入data var currentAnswer = answerData[j].weapon.code; if(currentAnswer === levelWeaponData[i]){ console.log(&quot;当前装备代号为=&quot;+currentAnswer); data.push(answerData[j]); //一旦查询到数据，关闭二级循环，防止数据重叠 break; } } } } console.log(&quot;列表数据数目为=&quot;+data.length); dialog.equipment_list.array = data; dialog.equipment_list.renderHandler = new Handler(this, onRender); } 2018/07/30 问题选项无法重复选中的问题： 问题原因：由于radiogroup采用了复用原则，所以，第二次展示答题卡选项时依旧会记录上次的选择。 解决方案：只需要在每次点击下一题按钮时重置选中状态即可： 1dialog.radioGroup_question.selectedIndex = -1; 技能栏的实现： 可以通过listview实现，监听每个item的选中状态： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//显示待使用的武器技能列表 if(this.weaponCount &gt; 0){ this.weapon_ready_list.visible = true; this.weapon_ready_list.array = data; this.weapon_ready_list.selectEnable = true; this.weapon_ready_list.renderHandler = new Handler(this, onWeaponRender); this.weapon_ready_list.selectHandler = new Handler(this, onSelect); } /** * item 的渲染处理 * @param {*} cell * @param {*} index */ function onWeaponRender(cell,index){ console.log(&quot;渲染待使用武器列表的回调～&quot;); if(index &gt; data.length)return; //获取当前渲染条目item的数据 var equipmentData = data[index]; //根据子节点的名字weapon，获取子节点对象 var weaponData = equipmentData.weapon; //获取子条目各项数据 var weaponImg = weaponData.res; var weaponName = weaponData.name; console.log(&quot;装备列表中武器名称=&quot;+weaponName+&quot;,武器资源=&quot;+weaponImg); var icon = cell.getChildByName(&quot;icon_weapon&quot;); icon.skin = weaponImg; } /** * item的点击选中处理 * @param {*} index */ function onSelect(index){ console.log(&quot;当前选中了第&quot;+index+&quot;个武器&quot;); for(var i=0; i&lt;data.length; i++){ var cell = this.weapon_ready_list.getCell(index); var bg_weapon = cell.getChildByName(&quot;bg_weapon&quot;); if(i === index){ //设置选中的状态 bg_weapon.skin = &quot;template/GameScene/bg_weapon_selected.png&quot;; }else{ //设置未选中状态 bg_weapon.skin = &quot;template/GameScene/bg_weapon_unselected.png&quot;; } } } 重置list的item的选中状态时游戏崩溃问题： 日志信息：”Cannot read property ‘getChildByName’ of null”。 解决方案：将获取index位置的item容器改为获取第i位置的： 1234567891011121314151617181920/** * item的点击选中处理 * @param {*} index */ function onSelect(index){ console.log(&quot;当前选中了第&quot;+index+&quot;个武器&quot;); for(var i=0; i&lt;data.length; i++){ var cell = this.weapon_ready_list.getCell(i); var bg_weapon_img = cell.getChildByName(&quot;bg_weapon&quot;); if(i === index){ //设置选中的状态 bg_weapon_img.skin = &quot;template/GameScene/bg_weapon_selected.png&quot;; }else{ //设置未选中状态 bg_weapon_img.skin = &quot;template/GameScene/bg_weapon_unselected.png&quot;; } } } 2018/07/31 laya请求后台的问题接口后无法获取数据： 需要后台处理一下跨域的问题 排行榜UI实现： 通过laya提供的UI组件list来实现，判断item位置进而进行差异化渲染，从而实现前三名的独特效果。此外，圆形头像需要通过mask蒙版来进行处理。 装备列表只渲染一次的问题： 问题原因：没有设置repeatx和repeaty，而且list的box设置的高度太大，导致渲染一次。 解决方案：设置repeatx和repeaty属性，代表横向和纵向列表中item的数量","link":"/2018/08/31/wechat-game-1/"},{"title":"基于Laya游戏引擎实现微信小游戏排行榜","text":"我们都知道，微信小游戏和小程序目前风头十足，很多公司都逐渐增加了相关业务线来迅速推广自己的产品和抢占用户群。说到微信小游戏，就不得不提到排行榜这个功能，就目前游戏行业，似乎都离不开排行榜这个重要功能，用户很大一部分留存都是依仗这个看似不起眼的模块。那么，微信小游戏中具体该如何借助laya引擎实现排行榜这个功能呢？我们先来看一下最终的效果图： 按照微信官方的说法，如果我们要使用微信官方提供的好友关系链的数据，我们就不能直接在项目中绘制排行榜，我们需要借助于开放域来绘制排行榜： ​ 如果想要展示通过关系链 API 获取到的用户数据，如绘制排行榜等业务场景，需要将排行榜绘制到 sharedCanvas 上，再在主域将 sharedCanvas 渲染上屏。简单来说，sharedCanvas 是主域和开放数据域都可以访问的一个离屏画布。在开放数据域调用 wx.getSharedCanvas() 将返回 sharedCanvas。更多相关详情可以去看看官网的介绍：https://mp.weixin.qq.com/debug/wxagame/dev/tutorial/open-ability/open-data.html 那么我们来实际动手操作一下吧。 主域绘制通过效果可以看出来，我们排行榜是一个弹窗形式展示的，由于开放域只负责排行榜UI绘制，所以，除此以外的UI以及交互我们需要在主域绘制和处理。因此，这里的弹窗 dialog 需要在主域绘制，然后将对应的排行榜需要显示的位置信息和长宽映射到开放域，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123 /** * 显示排行榜数据 */ function onRankInfoLoad(){ console.log(&quot;查看排行榜～&quot;); var dialog = new RankDialogUI(); showShareCanvas(); // 解决显示对象和鼠标错位而导致的排行榜滑动无效问题 var globalPosition = dialog.ranking_list.localToGlobal(new Laya.Point()); var originMatrix = Laya.stage._canvasTransform; var mat = new Laya.Matrix(originMatrix.a, 0, 0, originMatrix.d, globalPosition.x * originMatrix.a, globalPosition.y * originMatrix.d); wxPostMessage({ command: 0, text: &quot;设置开放域canvas大小&quot;, canvasData: { width: rankViewWidth * mat.a, height: rankViewHeight * mat.d, matrix: mat }, isLoad: false }, null, function (message) { console.log(&quot;再次往开放域发请求&quot;); window['wx'].postMessage({ command: 1, text: '开放域加载资源', }); }); Laya.stage.addChild(dialog); dialog.ranking_list.visible = false; dialog.popup(); Laya.timer.once(400,this,function(){ wxPostMessage({ command: 3, text: &quot;获取排行榜数据～&quot; }, null, function (message) { console.log(&quot;获取排行榜的回调～&quot;); }); }); dialog.btn_rank_dialog_share.on(Laya.Event.CLICK, this, onGameRankShare); dialog.btn_rank_dialog_back.on(Laya.Event.CLICK, this, onDialogClose); function onDialogClose(){ wxPostMessage({ command: 4, text: &quot;关闭排行榜～&quot; }, null, function (message) { console.log(&quot;关闭排行榜的回调～&quot;); }); dialog.close(); } function onGameRankShare(){ console.log(&quot;分享排行榜～&quot;); window['wx'].showShareMenu({ withShareTicket:false, success:function(res){ console.log(&quot;开启转发成功～&quot;); }, fail:function(res){ console.log(&quot;开启转发失败～&quot;); }, complete:function(res){ } }); window['wx'].onShareAppMessage(function () { return { title: '我在飞机大战游戏中排名又上升了,快来挑战我吧～' } }) window['wx'].shareAppMessage({ title: '我在飞机大战游戏中排名又上升了,快来挑战我吧～', imageUrl: canvas.toTempFilePathSync({ x: (screenWidth - rankViewWidth)/2 - 10, y: (screenHeight - rankViewHeight)/2+80, width: (rankViewWidth - 30)*4, height: (rankViewHeight - 40)*4, destWidth: 500, destHeight: 600 }) }); } } /** * 设置共享Canvas */ function showShareCanvas(){ window['sharedCanvas'].width = rankViewWidth; window['sharedCanvas'].height = rankViewHeight; //主域显示开放域内容??? //window['sharedCanvas'].sharedCanvas = window['wx'].getOpenDataContext().canvas; Laya.timer.once(1000, this, function () { var sprite = new Laya.Sprite(); sprite.zOrder = 1008; sprite.pos(0, 0); var texture = new Laya.Texture(window['sharedCanvas']); texture.bitmap.alwaysChange = true;//小程序使用，非常费 sprite.graphics.drawTexture(texture, (screenWidth - rankViewWidth)/2, (screenHeight - rankViewHeight)/2, texture.width, texture.height); Laya.stage.addChild(sprite); }); }/** * 向开放域发送消息，并接收开放域返回过来的数据， * 可根据发送参数和接收数据在主域这边进行下步处理 * @param message * @param caller * @param callback */ function wxPostMessage(message, caller, callback){ window['wx'].postMessage(message); Laya.timer.once(400, this, function (){ //回调处理 if (caller == null || caller == undefined) { callback(message); } else { caller.callback(message); } }); } 这边主要发送的消息体中携带了command字段，用于在开放域执行不同的功能代码，这边大体分为：资源加载命令、初始化排行榜大小命令、获取关系链(排行榜)数据命令以及关闭排行榜的命令，大家可以根据业务具体需要适当增减。 开放域绘制根据官方的说明，开放数据域 是一个封闭、独立的 JavaScript 作用域。要让代码运行在开放数据域，需要在 game.json 中添加配置项 openDataContext 指定开放数据域的代码目录。添加该配置项表示小游戏启用了开放数据域，这将会导致一些 限制。这些限制主要包含： 无法设置sharedCanvas的宽高 只能使用有限的接口(如逐帧动画、Timer、触摸事件以及获取和设置关系链数据等接口) 下面我们一步步来在开放域绘制排行榜。 首先，需要新建一个项目作为开放域，这个项目目录是与主域项目平行的(主域就是未做排行榜之前的项目目录)，比如我的项目目录是这样的： 接着，我们需要在开放域中接收主域发送的消息并处理不同的功能命令，UI就不放了，看看具体代码吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263/** * 监听从主域发过来的消息 */ function wxOnMessage(){ if(window['wx'] != undefined){ window['wx'].onMessage(function (message){ dispatchMessage(message); }); }else{ console.log(&quot;微信接口无法使用～&quot;); } } /** * 处理消息 * @param {*} message */ function dispatchMessage(message){ switch(message.command){ //设置开放域画布大小 case 0: sample.setCanvasSize(message.canvasData); break; //加载资源 case 1: sample.loadResource(); break; //写入排行榜数据 case 2: sample.writeRankingData(message.rankingData); break; //获取微信排行榜数据 case 3: sample.getRankingData(); break; //关闭排行榜 case 4: sample.closeRankingDialog(); break; default: console.log(JSON.stringify(message)); } } /** * 设置开放域画布大小 * @param {*} size */ _proto.setCanvasSize = function(size){ console.log(&quot;设置开放域canvas大小～&quot;); window['sharedCanvas'].width = size.width; window['sharedCanvas'].height = size.height; //Laya.stage.width = size.width; //Laya.stage.width = size.height; /** * 将主域的canvasTransform映射到开放域 */ if(size.matrix!=null){ console.log(&quot;收到主域的同步canvasTransform了～&quot;); } var mainMatrix = size.matrix; var openMatrix = new Laya.Matrix(); openMatrix.a = mainMatrix.a; openMatrix.b = mainMatrix.b; openMatrix.c = mainMatrix.c; openMatrix.d = mainMatrix.d; openMatrix.tx = mainMatrix.tx; openMatrix.ty = mainMatrix.ty; //重置矩阵 Laya.stage._canvasTransform = openMatrix; //监听舞台的鼠标移动事件 Laya.stage.mouseEnabled = true; } /** * 用户自己的排名 */ var myRanking = -1; /** * 获取微信排行榜数据 */ _proto.getRankingData = function(){ window['wx'].getUserInfo({ openIdList: ['selfOpenId'], success: (userRes) =&gt; { console.log('success', userRes.data); //索引代表各个好友0为自己 let userData = userRes.data[0]; console.log(&quot;取信息索引0&quot; + userData.nickName); //取出所有好友数据 window['wx'].getFriendCloudStorage({ keyList: [ //'击杀排行', '第1关', '第2关', '第3关' ], success: res =&gt; { console.log(&quot;wx.getFriendCloudStorage success&quot;, res); let data = res.data; /*data.sort((a, b) =&gt; { if (a.KVDataList.length == 0 &amp;&amp; b.KVDataList.length == 0) { return 0; } if (a.KVDataList.length == 0) { return 1; } if (b.KVDataList.length == 0) { return -1; } return b.KVDataList[0].value - a.KVDataList[0].value; });*/ for (let i = 0; i &lt; data.length; i++) { var playerInfo = data[i]; var currentPlayer = res.data[i].nickname; console.log(&quot;当前排行玩家昵称为=&gt;&quot;+res.data[i].nickname); var kvList = playerInfo.KVDataList; var scoreSum = 0; if(kvList.length&gt;0){ for(var j = 0;j&lt;kvList.length;j++){ if(kvList[j].key != null){ //将value转化为int再累加 scoreSum+=Number(kvList[j].value); } } } if (data[i].avatarUrl == userData.avatarUrl) { //获取群好友的时候,没有自己的名字?? data[i].nickName = userData.nickName; myRanking = i+1; console.log(&quot;此ID为自己,当前排名第&quot;+myRanking); } //填充总分信息 sortData.push({ nickName: currentPlayer, avatarUrl: data[i].avatarUrl, totalScore: scoreSum }); } sortData.sort((a, b) =&gt; { var score1 = Number(a.totalScore); var score2 = Number(b.totalScore); if (score1 &gt; score2) { return -1; }else if(score1 &lt; score2){ return 1; }else{ return 0; } }); showRankingDialog(); }, fail: res =&gt; { console.log(&quot;拉取好友信息失败&quot;, res); }, }); }, fail: (res) =&gt; { console.log(&quot;拉取个人信息失败&quot;) } }); } /** * 加载资源 */ _proto.loadResource = function(){ Laya.loader.load([&quot;comp/bg_line.png&quot;,&quot;comp/ranking1.png&quot;,&quot;comp/ranking2.png&quot;, &quot;comp/ranking3.png&quot;,&quot;comp/userholder_img.png&quot;], Laya.Handler.create(null,function(){ console.log(&quot;开放域资源加载完毕～&quot;); sample.rankView = new RankingViewUI(); Laya.stage.addChild(sample.rankView); })); } /** * 写入排行榜数据 */ _proto.writeRankingData = function(rankingData){ console.log(&quot;写入排行榜数据～&quot;); //KVDataList代表排行数据,可以为多个,多个代表多个排行 //key-排行类型,value-排行分数 window['wx'].setUserCloudStorage({ KVDataList: [ //{ key: '击杀排行', value: &quot;&quot; + 1 }, { key: '第'+rankingData.fightLevel+'关', value: rankingData.fightScore+&quot;&quot; },//需要改成动态的值 ], success: function (res) { console.log('setUserCloudStorage', 'success', res) }, fail: function (res) { console.log('setUserCloudStorage', 'fail') } }); } var sortData = []; /** * 渲染排行榜列表 */ function showRankingDialog(){ console.log(&quot;拿到好友排行榜信息&quot;, sortData); sample.rankView.ranking_list.vScrollBarSkin = &quot;&quot;; sample.rankView.ranking_list.array = sortData; sample.rankView.ranking_list.renderHandler = new Laya.Handler(this, onRender); sample.rankView.ranking_list.selectHandler = new Laya.Handler(this, onSelect); } var lastRenderIndex = -1; function onRender(cell, index){ if (index == lastRenderIndex) { return; } lastRenderIndex = index; //根据子节点的name获取子节点对象 var name = cell.getChildByName(&quot;item_rank_name&quot;); var ranking = cell.getChildByName(&quot;item_rank_text&quot;); var userlogo = cell.getChildByName(&quot;item_rank_logo&quot;); var score = cell.getChildByName(&quot;item_rank_score&quot;); var rank_icon = cell.getChildByName(&quot;item_rank_icon&quot;); name.text = sortData[index].nickName; console.log(&quot;渲染排行榜当前的用户名为=&quot;+sortData[index].nickName+&quot;，渲染索引：&quot;+lastRenderIndex); ranking.text = (index+1)+&quot;&quot;; userlogo.skin = sortData[index].avatarUrl; score.text = sortData[index].totalScore+&quot;分&quot;; if(lastRenderIndex === 0 || lastRenderIndex === 1 || lastRenderIndex === 2){ ranking.visible = false; rank_icon.visible = true; rank_icon.skin = &quot;comp/ranking&quot;+(lastRenderIndex+1)+&quot;.png&quot;; }else{ rank_icon.visible = false; ranking.visible = true; } } function onSelect(index){ console.log(&quot;当前选择的索引是：&quot;+index); } /** * 关闭排行榜 */ _proto.closeRankingDialog = function(){ //dialog.close(); console.log(&quot;关闭排行榜～&quot;); sortData = []; lastRenderIndex = -1; sample.rankView.removeChildren(); sample.rankView = null; } _proto.start = function(){ console.log(&quot;开始接收主域的消息～&quot;); wxOnMessage(); }} 可以看到，我们这里通过 wx.onMessage 方法来获取主域发送的数据，然后借助 dispatchMessage 方法作消息的分发处理。值得注意的是，我们在设置开放域canvas大小的时候，需要重置坐标矩阵，将主域的排行榜显示位置映射到开放域中来，否则会发生滑动无效的问题。我这里设置的排行榜数据有三条，大家可以根据具体需求来传入，获取到排行榜数据后，需要对它进行排序处理并展示，这里直接借助于laya中的 List 控件展示就可以了，对于它用法不熟悉的可以去laya官网了解一下：https://ldc.layabox.com/doc/?nav=zh-js-6-0-0 开放域图片加载问题：用过laya游戏引擎的都知道，我们一般用官方推荐的打包图集的方式来加载游戏中的图片资源，这种方式在主域中是可行的，然而，在开放域中却不能成功加载图片资源。因此，开放域中，我们不需要将图片资源打包成图集，只要像下面这样直接加载图片即可： 123456789101112/** * 加载资源 */ _proto.loadResource = function(){ Laya.loader.load([&quot;comp/bg_line.png&quot;,&quot;comp/ranking1.png&quot;,&quot;comp/ranking2.png&quot;, &quot;comp/ranking3.png&quot;,&quot;comp/userholder_img.png&quot;], Laya.Handler.create(null,function(){ console.log(&quot;开放域资源加载完毕～&quot;); sample.rankView = new RankingViewUI(); Laya.stage.addChild(sample.rankView); })); } 然后，我们还需要将对应的图片文件夹拷贝到wx_publish目录下，否则会提示找不到图片资源。 合并主域和开放域主域和开放域功能代码实现了之后，我们就需要打包成微信小游戏项目了。首先，我们需要先将主域项目发布成微信小游戏，发布目录直接为项目的根目录，如上图的 wx_publish 目录。然后，在该目录下创建src/myOpenDataContext目录。接着，我们需要将开放域项目也发布成微信小游戏，目录可以选择桌面，名称为 wx_open，发布成功后，进入该目录，将code.js、weapp-adapter.js以及index.js文件复制到 wx_publish/src/myOpenDataContext 目录下，并在 game.json 文件中增加开放域映射目录： 123456789101112{ &quot;deviceOrientation&quot;: &quot;portrait&quot;, &quot;showStatusBar&quot;: &quot;false&quot;, &quot;networkTimeout&quot;: { &quot;request&quot;: 10000, &quot;connectSocket&quot;: 10000, &quot;uploadFile&quot;: 10000, &quot;downloadFile&quot;: 10000 }, &quot;openDataContext&quot;: &quot;src/myOpenDataContext&quot;} 到这里，微信小游戏排行榜功能就算实现了，到头来发现，其实实现起来并不难，难的是缺乏资料，此文仅用来抛砖引玉，如有问题欢迎提出。","link":"/2018/09/20/wechat-game-rank/"}],"tags":[{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"Proguard","slug":"Proguard","link":"/tags/Proguard/"},{"name":"MotionLayout","slug":"MotionLayout","link":"/tags/MotionLayout/"},{"name":"Android 动画","slug":"Android-动画","link":"/tags/Android-%E5%8A%A8%E7%94%BB/"},{"name":"Android tools","slug":"Android-tools","link":"/tags/Android-tools/"},{"name":"ConstraintLayout","slug":"ConstraintLayout","link":"/tags/ConstraintLayout/"},{"name":"Flutter","slug":"Flutter","link":"/tags/Flutter/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"MVP","slug":"MVP","link":"/tags/MVP/"},{"name":"Android architecture","slug":"Android-architecture","link":"/tags/Android-architecture/"},{"name":"地图导航","slug":"地图导航","link":"/tags/%E5%9C%B0%E5%9B%BE%E5%AF%BC%E8%88%AA/"},{"name":"高德地图","slug":"高德地图","link":"/tags/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/"},{"name":"输入提示","slug":"输入提示","link":"/tags/%E8%BE%93%E5%85%A5%E6%8F%90%E7%A4%BA/"},{"name":"自定义Marker","slug":"自定义Marker","link":"/tags/%E8%87%AA%E5%AE%9A%E4%B9%89Marker/"},{"name":"Marker聚合","slug":"Marker聚合","link":"/tags/Marker%E8%81%9A%E5%90%88/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"评论回复","slug":"评论回复","link":"/tags/%E8%AF%84%E8%AE%BA%E5%9B%9E%E5%A4%8D/"},{"name":"UI效果","slug":"UI效果","link":"/tags/UI%E6%95%88%E6%9E%9C/"},{"name":"Dart","slug":"Dart","link":"/tags/Dart/"},{"name":"AppBar","slug":"AppBar","link":"/tags/AppBar/"},{"name":"Google","slug":"Google","link":"/tags/Google/"},{"name":"Google develop days","slug":"Google-develop-days","link":"/tags/Google-develop-days/"},{"name":"展会","slug":"展会","link":"/tags/%E5%B1%95%E4%BC%9A/"},{"name":"Jcenter","slug":"Jcenter","link":"/tags/Jcenter/"},{"name":"开源","slug":"开源","link":"/tags/%E5%BC%80%E6%BA%90/"},{"name":"Image selector","slug":"Image-selector","link":"/tags/Image-selector/"},{"name":"Anko","slug":"Anko","link":"/tags/Anko/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"快捷键","slug":"快捷键","link":"/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"开发效率","slug":"开发效率","link":"/tags/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/"},{"name":"微信小游戏","slug":"微信小游戏","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"游戏脚本","slug":"游戏脚本","link":"/tags/%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC/"},{"name":"Layabox","slug":"Layabox","link":"/tags/Layabox/"},{"name":"游戏排行榜","slug":"游戏排行榜","link":"/tags/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/"},{"name":"未来规划","slug":"未来规划","link":"/tags/%E6%9C%AA%E6%9D%A5%E8%A7%84%E5%88%92/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"读书","slug":"读书","link":"/tags/%E8%AF%BB%E4%B9%A6/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"地图开发","slug":"Android/地图开发","link":"/categories/Android/%E5%9C%B0%E5%9B%BE%E5%BC%80%E5%8F%91/"},{"name":"开源","slug":"Android/开源","link":"/categories/Android/%E5%BC%80%E6%BA%90/"},{"name":"Flutter","slug":"Flutter","link":"/categories/Flutter/"},{"name":"Google","slug":"Google","link":"/categories/Google/"},{"name":"Jcenter","slug":"Jcenter","link":"/categories/Jcenter/"},{"name":"Kotlin","slug":"Kotlin","link":"/categories/Kotlin/"},{"name":"Mac","slug":"Mac","link":"/categories/Mac/"},{"name":"微信小游戏","slug":"微信小游戏","link":"/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/"},{"name":"Dart","slug":"Flutter/Dart","link":"/categories/Flutter/Dart/"},{"name":"Meeting","slug":"Google/Meeting","link":"/categories/Google/Meeting/"},{"name":"个人总结","slug":"个人总结","link":"/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"},{"name":"Proguard","slug":"Android/Proguard","link":"/categories/Android/Proguard/"},{"name":"动画","slug":"Android/动画","link":"/categories/Android/%E5%8A%A8%E7%94%BB/"},{"name":"Android Gradle","slug":"Android-Gradle","link":"/categories/Android-Gradle/"},{"name":"Architecture","slug":"Android/Architecture","link":"/categories/Android/Architecture/"}]}